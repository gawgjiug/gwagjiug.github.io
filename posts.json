[
  {
    "title": "JS 'this' ",
    "link": "https://velog.io/@gawgjiug/JS-this",
    "description": "<h3 id=\"this는-무엇인가\">this는 무엇인가?</h3>\n<hr>\n<ul>\n<li><p>대부분의 경우 <code>tihs</code>의 값은 함수를 호출한 방법에 의해 결정된다.</p>\n</li>\n<li><p><code>this</code> 는 호출한 놈을 말한다.</p>\n</li>\n<li><p>기본적으로는 <code>this</code> 는 window 객체를 말한다.</p>\n</li>\n<li><p>예외의 경우 </p>\n</li>\n</ul>\n<ol>\n<li><p>화살표 함수에서 <code>this</code> 가 조금 달라진다.</p>\n</li>\n<li><p>Strict Mode에서는 <code>this</code> 가 조금 달라진다.</p>\n</li>\n</ol>\n<h4 id=\"this\">this</h4>\n<hr>\n<ul>\n<li>대부분의 경우 <code>this</code> 의 값은 함수를 호출한 방법 즉,  호출한 놈에 의해 결정된다.</li>\n</ul>\n<pre><code class=\"language-js\">function printThis() {\n  console.log(this);\n}\nprintThis(); // window 객체\n\nlet person1 = {\n  name: &#39;김길동&#39;,\n  whoIsThis: printThis,\n};\n\nlet person2 = {\n  name: &#39;홍길동&#39;,\n  whoIsThis: printThis,\n};\n\nlet person3 = {\n  name: &#39;짐길동&#39;,\n  whoIsThis: printThis,\n};\n\nperson1.whoIsThis(); // person1 객체\nperson2.whoIsThis(); // person2 객체\nperson3.whoIsThis(); // person3 객체</code></pre>\n<h4 id=\"bind-함수\">bind 함수</h4>\n<ul>\n<li><code>bind</code> 함수로 <code>this</code>를 설정할 수 있다.</li>\n</ul>\n<pre><code class=\"language-js\">function print() {\n  console.log(&#39;this: &#39;, this);\n  console.log(&#39;this.fullname: &#39;, this.fullname);\n}\n\nlet person1 = {\n  fullname: &#39;홍길동&#39;,\n};\nlet person2 = {\n  fullname: &#39;김길동&#39;,\n};\nlet bindPrint = print.bind(person1); // person1 객체로 바인딩\nbindPrint(); // person1\nlet bindPrint2 = bindPrint.bind(person2);\nbindPrint2(); // person1! bind는 단 한번만 할 수 있다.</code></pre>\n<h4 id=\"arrow-function-this\">Arrow Function this</h4>\n<hr>\n<ul>\n<li><p>화살표 함수가 나오기 전 까지는 함수는 어떻게 호출되는지에 따라 자신의 <code>this</code> 값을 정의했다.</p>\n</li>\n<li><p>하지만 화살표 함수는 자신을 포함하고 있는 외부 Scope에서 this를 계승받는다.</p>\n</li>\n</ul>\n<pre><code class=\"language-js\">let person = {\n  name: &#39;곽지욱&#39;,\n  printThis: function () {\n    console.log(this) //person 객체\n    setTimeout(() =&gt; {\n      console.log(this); // person 객체\n    });\n  },\n};</code></pre>\n<ul>\n<li>화살표 함수를 사용할 경우 나를 감싸고 있는 상위 스코프의 this를 계승받기 때문에 person 객체를 받는 것</li>\n</ul>\n<pre><code class=\"language-js\">let person = {\n    name: &#39;곽지욱&#39;,\n    printThis: () =&gt; {\n        console.log(this); // window 객체 출력\n    }\n};</code></pre>\n<ul>\n<li>그렇기에 위 경우에서는 상위 스코프가 전역 스코프이기 때문에 window 객체를 출력하는 것</li>\n</ul>\n<h4 id=\"strict-mode\">Strict Mode</h4>\n<hr>\n<ul>\n<li>엄격 모드에서는 호출한 놈이 없을 경우 기본값을 <code>window</code>로 하지 않고 <code>undefined</code>로 한다.</li>\n</ul>\n<pre><code class=\"language-js\">&#39;use strict&#39;;\nfunction printThis() {\n    console.log(this);\n}\nprintThis(); // undefined</code></pre>\n",
    "pubDate": "Mon, 12 Aug 2024 08:41:56 GMT",
    "thumbnail": null
  },
  {
    "title": "JS Object (객체)",
    "link": "https://velog.io/@gawgjiug/JS-Object-%EA%B0%9D%EC%B2%B4",
    "description": "<h3 id=\"object\">Object</h3>\n<hr>\n<ul>\n<li>객체는 연관된 데이터를 담는 그릇이다. 프리미티브 타입(Primitive Type)은 단 하나의 값만 나타낼 수 있고 불변이지만, 이와 달리 객체는 여러가지 값이나 복잡한 값을 나타낼 수 있으며 , 값(내용물)이 변할 수도 있음</li>\n</ul>\n<h4 id=\"객체구성\">객체구성</h4>\n<hr>\n<ul>\n<li>JS에서 객체는 키(key)와 값(value)으로 구성되어있다.</li>\n</ul>\n<pre><code class=\"language-js\">const person = {\n    name: &#39;곽지욱&#39;,\n    age: 24\n};\n// name이 키(key)이며, \n// &#39;곽지욱&#39;이 값(value)이다.</code></pre>\n<ul>\n<li>객체는 여러가지 값을 가질 수 있고, 객체가 가지고 있는 값을 <code>프로퍼티(Property)</code>라고 하며, 객체가 가지고 있는 함수를 <code>메서드</code> 라고함</li>\n</ul>\n<pre><code class=\"language-js\">const obj = {\n    name: &#39;곽지욱&#39;,    // name 프로퍼티\n    age: 20,         // age 프로퍼티\n    sayHello: function() {   // sayHello 메서드\n        console.log(&#39;Hello!&#39;);\n    },\n    sayHi() {  // 이렇게도 선언할 수 있다.\n        console.log(&#39;Hi!&#39;);\n    }\n};</code></pre>\n<h4 id=\"객체-프로퍼티-접근\">객체 프로퍼티 접근</h4>\n<hr>\n<ul>\n<li><p>객체 안에 있는 프로퍼티나 함수에 접근하기 위해서는 크게 두 가지 방법이있다.</p>\n</li>\n<li><p><code>점표기법</code> - <code>예) 객체.key</code></p>\n</li>\n</ul>\n<pre><code class=\"language-js\">person.name\nperson.age\nperson.gender\nperson.hello()\nperson.bobby.name\nperson.bobby.alert()</code></pre>\n<ul>\n<li>괄포 표기법 - <code>예) 객체[&#39;key&#39;]</code><pre><code class=\"language-js\">person[&#39;name&#39;]\nperson[&#39;age&#39;]\nperson[&#39;gender&#39;]\nperson[&#39;hello&#39;]()\nperson[&#39;hobby&#39;][&#39;name&#39;]\nperson[&#39;hobby&#39;][&#39;alert&#39;]()</code></pre>\n</li>\n</ul>\n<h4 id=\"함수-파라미터로-객체-전달하기\">함수 파라미터로 객체 전달하기</h4>\n<hr>\n<ul>\n<li>함수 파라미터로 객체를 전달하면 코드를 클린하게 만들 수 있다.</li>\n</ul>\n<p><code>Before</code></p>\n<pre><code class=\"language-js\">function printPerson(name, age, hobby) {\n  console.log(`제 이름은 ${name}이며, 나이는 ${age}살 입니다.그리고 취미는 ${hobby} 입니다.`);\n}\nprintPerson(&#39;곽지욱&#39;, 10, &#39;헬스&#39;);</code></pre>\n<p><code>After</code></p>\n<pre><code class=\"language-js\">function printPerson(person) {\n  console.log(`제 이름은 ${person.name}이며, 나이는 ${person.age}살 입니다.그리고 취미는 ${person.hobby} 입니다.`);\n}\n\nconst person = {\n  name: &#39;곽지욱&#39;,\n  age: 10,\n  hobby: &#39;헬스&#39;\n};\nprintPerson(person);</code></pre>\n<h4 id=\"구조-분해-할당\">구조 분해 할당</h4>\n<ul>\n<li>객체 속성을 개별 변수에 담을 때 변수의 순서가 아니라 key가 동일하는지가 중요하다.</li>\n</ul>\n<pre><code class=\"language-js\">const person = {\n  name: &#39;곽지욱&#39;,\n  age: 10,\n  hobby: &#39;헬스&#39;\n};\nconst { name, age, hobby } = person;</code></pre>\n<h4 id=\"팩토리-함수\">팩토리 함수</h4>\n<hr>\n<ul>\n<li>JS 로 같은 유형의 객체를 여러번 생성해야 할 때 사용하는 함수 생성 기법이다.<pre><code class=\"language-js\">const person1 = {\nname: &#39;곽지욱&#39;,\nage: 10,\nhobby: &#39;헬스&#39;\n};\nconst person2 = {\nname: &#39;홍길동&#39;,\nage: 20,\nhobby: &#39;축지법&#39;\n};\nconst person3 = {\nname: &#39;도깨비&#39;,\nage: 30,\nhobby: &#39;도술&#39;\n};\n...\nconst person10 = {\n...\n};</code></pre>\n</li>\n<li>이렇게 객체 리터럴로 반복적으로 생성하다 보면 코드의 반복도 많아지고 가독성도 그만큼 떨어짐 <code>팩토리 함수</code>를 사용해야함</li>\n</ul>\n<pre><code class=\"language-js\">function createPerson(name, age, hobby) {\n    return {\n        name: name,\n        age: age,\n        hobby: hobby\n    };\n};\n\nconst person1 = createPerson(&#39;곽지욱&#39;, 10, &#39;헬스&#39;);\nconst person2 = createPerson(&#39;홍길동&#39;, 20, &#39;헬스&#39;);\nconst person3 = createPerson(&#39;김길동&#39;, 30, &#39;헬스&#39;);\nconst person4 = createPerson(&#39;고길동&#39;, 40, &#39;헬스&#39;);\nconst person5 = createPerson(&#39;한길동&#39;, 50, &#39;헬스&#39;);\nconst person6 = createPerson(&#39;최길동&#39;, 60, &#39;헬스&#39;);</code></pre>\n<ul>\n<li>사실 여기서 정의 된 name,age,hobby 모두 key와 value가 동일하기 때문에 단축 속성명을 사용 할 수 있다. 단축 속성명은 key와 value를 각각 표기하지 않고 한번만 표기하는 것을 말함</li>\n</ul>\n<ul>\n<li>뿐만 아니라 클래스를 사용해서 객체를 생성할 수도 있다.</li>\n</ul>\n<pre><code class=\"language-js\">class Person {\n  constructor(name, age, hobby) {\n    this.name = name;\n        this.age = age;\n        this.hobby = hobby;\n  }\n}\nconst person = new Person(&#39;곽지욱&#39;, 20, &#39;헬스&#39;);\nconsole.log(person)</code></pre>\n<h4 id=\"참조타입-reference-type\">참조타입 (Reference type)</h4>\n<hr>\n<ul>\n<li><p>프리미티브 타입이 아닌 것들은 객체타입 또는 참조타입이라고 한다.</p>\n</li>\n<li><p>프리미티브 타입 값을 다른 변수에 할당하면 값 자체를 넘겨주는 것이기 때문에 값의 원형이 변경되진 않는다.</p>\n</li>\n</ul>\n<pre><code class=\"language-js\">let str1 = &#39;hello&#39;;\nlet str2 = str1;\nstr2 = &#39;world&#39;;\nconsole.log(&#39;str1: &#39;, str1);  // str1:  hello\nconsole.log(&#39;str2: &#39;, str2);  // str2:  world</code></pre>\n<ul>\n<li>하지만 객체 타입을 다른 변수에 할당하면 참조값이 할당 되기 때문에 할당 받은 변수에서 속성을 변경하면 값의 원형이 변경된다.</li>\n</ul>\n<pre><code class=\"language-js\">let obj1 = { name: &#39;곽지욱&#39;, age: 20 };\nlet obj2 = obj1;\nobj2.age = 30;\nobj2.hobby = &#39;헬스&#39;;\nconsole.log(&#39;obj1: &#39;, obj1);  // obj1:  {name: &#39;곽지욱&#39;, age: 30, hobby: &#39;헬스&#39;}\nconsole.log(&#39;obj2: &#39;, obj2);  // obj2:  {name: &#39;곽지욱&#39;, age: 30, hobby: &#39;헬스&#39;}</code></pre>\n<h4 id=\"call-by-value-vs-call-by-reference\">Call By Value vs Call By Reference</h4>\n<hr>\n<ul>\n<li>함수 호출시에 파라미터로 프리미티브 타입을 넘기는 것과 객체 타입을 넘기는 것은 차이가 있다.</li>\n</ul>\n<pre><code class=\"language-js\">function changeName(username) {\n    username = &#39;홍길동&#39;;\n}\nconst name = &#39;GYMCODING&#39;;\nchangeName(name);\nconsole.log(&#39;name: &#39;, name); // name:  GYMCODING</code></pre>\n<p><code>Call by Value</code> 는 값 자체를 username에 할당하기 때문에 username 값을 변경해도 함수밖의 name은 변경되지 않는다. 즉 값이 복사된 것.</p>\n<ul>\n<li>Call By Reference (참조에 의한 호출)</li>\n</ul>\n<pre><code class=\"language-js\">function changeName(people) {\n    people.name = &#39;홍길동&#39;;\n}\nconst person = { name: &#39;GYMCODING&#39; };\nchangeName(person);\nconsole.log(&#39;name: &#39;, person.name);  // name:  홍길동</code></pre>\n<ul>\n<li>Call By Reference 는 값 자체가 아니라 값을 가리키는 참조 값을 people에 할당 했기 때문에 people과 person이 가리키고 있는 값은 같다.</li>\n</ul>\n<h4 id=\"spread-operator-전개-구문\">Spread operator (전개 구문)</h4>\n<ul>\n<li>Spread는 펼치다 라는 뜻 <code>...</code> 표기법을 사용하여 사용할 수 있다.</li>\n</ul>\n<pre><code class=\"language-js\">let obj = {\n    name: &#39;곽지욱&#39;,\n    age: 20\n};\nlet person = {\n    ...obj,\n    hobby: &#39;헬스&#39;\n};\nconsole.log(&#39;person: &#39;, person);\n// [출력]\n// person:  {name: &#39;곽지욱&#39;, age: 20, hobby: &#39;헬스&#39;}</code></pre>\n<h4 id=\"forin\">for...in</h4>\n<hr>\n<ul>\n<li>객체에 있는 키 항목들을 반복적으로 반환한다.</li>\n</ul>\n<pre><code class=\"language-js\">const person = {\n    name: &#39;홍길동&#39;,\n    age: 20,\n    job: &#39;개발자&#39;\n};\nfor (let key in person) {\n    console.log(`key: ${key}, value: ${person[key]}`);\n}\n// [출력]\n// key: name, value: 홍길동\n// key: age, value: 20\n// key: job, value: 개발자\n</code></pre>\n<h4 id=\"키-존재-여부-확인\">키 존재 여부 확인</h4>\n<hr>\n<ul>\n<li>in operator - key in object</li>\n</ul>\n<pre><code class=\"language-js\">const person = {\n  name: &#39;곽지욱&#39;,\n};\nconsole.log(&#39;name&#39; in person)  // true\nconsole.log(&#39;age&#39; in person)   // true\n\nif (&#39;name&#39; in person) {\n  console.log(&#39;이름이 정의되어 있습니다.&#39;);\n}</code></pre>\n",
    "pubDate": "Mon, 12 Aug 2024 06:08:58 GMT",
    "thumbnail": null
  },
  {
    "title": "JS 배열",
    "link": "https://velog.io/@gawgjiug/JS-%EB%B0%B0%EC%97%B4",
    "description": "<h3 id=\"구조-분해-할당\">구조 분해 할당</h3>\n<ul>\n<li><p>구조 분해 할당 문법은 <strong>배열이나 객체의 속성을 해체</strong> 하여 그 값을 개별 변수에 담을 수 있게 하는 자바스크립트 표현식을 말한다.</p>\n</li>\n<li><p>일반 - 배열 항목을 개별 변수에 담을 때</p>\n</li>\n</ul>\n<pre><code class=\"language-js\">const fruits = [&#39;사과&#39;, &#39;바나나&#39;, &#39;딸기&#39;];\nconst apple = fruits[0];\nconst banana = fruits[1];\nconst strawberry = fruits[2];</code></pre>\n<ul>\n<li>구조 분해 할당 - 배열 항목을 개별 변수에 담을 때</li>\n</ul>\n<pre><code class=\"language-js\">const fruits = [&#39;사과&#39;, &#39;바나나&#39;, &#39;딸기&#39;, &#39;수박&#39;];\nconst [apple, ...others]  = fruits;\nconsole.log(apple);  // 사과\nconsole.log(others); // [&#39;바나나&#39;, &#39;딸기&#39;, &#39;수박&#39;]</code></pre>\n<h3 id=\"spread-syntax-전개구문\">Spread syntax (전개구문)</h3>\n<ul>\n<li>Spread는 펼치다라는 뜻으로, <code>Spread syntax</code>는 배열을 할당할 때 참조 값을 할당 하는게 아닌 배열안의 항목을 펼치는 방식으로 할당할 수 있다.</li>\n</ul>\n<pre><code class=\"language-js\">let arr = [1, &#39;two&#39;, 3, &#39;four&#39;];\nlet numberArr = [...arr, 5, &#39;six&#39;];\nconsole.log(&#39;numberArr: &#39;, numberArr);\n// [출력]\n// numberArr:  (6) [1, &#39;two&#39;, 3, &#39;four&#39;, 5, &#39;six&#39;]</code></pre>\n<h3 id=\"rest-parameters\">Rest parameters</h3>\n<ul>\n<li>나머지 매개변수 구문(Rest parameters)를 사용하면 함수가 무한한 수의 파라미터를 배열로 받을 수 있다.</li>\n</ul>\n<pre><code class=\"language-js\">function printFruits(...fruits) {\n    console.log(&#39;fruits: &#39;, fruits);\n}\nfunction printTitleAndFruits(title, ...fruits) {\n    console.log(&#39;title:&#39; , title);\n    console.log(&#39;fruits: &#39;, fruits);\n}\nprintFruits(&#39;사과&#39;, &#39;바나나&#39;, &#39;딸기&#39;);\nprintFruits(&#39;사과&#39;, &#39;바나나&#39;, &#39;딸기&#39;, &#39;포도&#39;);\nprintTitleAndFruits(&#39;과일출력&#39;, &#39;사과&#39;, &#39;바나나&#39;, &#39;딸기&#39;, &#39;포도&#39;);</code></pre>\n<h3 id=\"배열-복사하기\">배열 복사하기</h3>\n<ul>\n<li>배열은 객체이기 때문에 당연히 참조 값을 가지고 있고 <code>얇은 복사</code> 를 할 경우에는 하나의 배열을 변경하면 다른 배열도 같은 메모리 참조 값을 가지고 있기 때문에 결국에는 함께 변경이 된다</li>\n</ul>\n<pre><code class=\"language-js\">const fruits = [&#39;오렌지&#39;, &#39;포도&#39;, &#39;사과&#39;, &#39;바나나&#39;, &#39;딸기&#39;];\nconst copy = fruits;\ncopy.pop();                        // 끝에 항목 제거\nconsole.log(&#39;fruits: &#39;, fruits);   // [&#39;오렌지&#39;, &#39;포도&#39;, &#39;사과&#39;, &#39;바나나&#39;]\nconsole.log(&#39;copyFruits: &#39;, copy); // [&#39;오렌지&#39;, &#39;포도&#39;, &#39;사과&#39;, &#39;바나나&#39;]</code></pre>\n<ul>\n<li>전개 구문을 사용해서 <code>deep copy</code> 문법을 사용하면 해당 원본에 값만 가져오기 때문에 하나의 배열을 변경해도 별개로서 존재한다.</li>\n</ul>\n<pre><code class=\"language-js\">const fruits = [&#39;오렌지&#39;, &#39;포도&#39;, &#39;사과&#39;, &#39;바나나&#39;, &#39;딸기&#39;];\nconst copy = [...fruits];\ncopy.pop();                        // 끝에 항목 제거\nconsole.log(&#39;fruits: &#39;, fruits);   // [&#39;오렌지&#39;, &#39;포도&#39;, &#39;사과&#39;, &#39;바나나&#39;, &#39;딸기&#39;]\nconsole.log(&#39;copyFruits: &#39;, copy); // [&#39;오렌지&#39;, &#39;포도&#39;, &#39;사과&#39;, &#39;바나나&#39;]</code></pre>\n<ul>\n<li>혹은 Array.from () 메서드를 이용해도 된다.</li>\n</ul>\n<pre><code class=\"language-js\">const fruits = [&#39;오렌지&#39;, &#39;포도&#39;, &#39;사과&#39;, &#39;바나나&#39;, &#39;딸기&#39;];\nconst copy = Array.from(fruits);\ncopy.pop();                        // 끝에 항목 제거\nconsole.log(&#39;fruits: &#39;, fruits);   // [&#39;오렌지&#39;, &#39;포도&#39;, &#39;사과&#39;, &#39;바나나&#39;, &#39;딸기&#39;]\nconsole.log(&#39;copyFruits: &#39;, copy); // [&#39;오렌지&#39;, &#39;포도&#39;, &#39;사과&#39;, &#39;바나나&#39;]</code></pre>\n",
    "pubDate": "Fri, 09 Aug 2024 05:26:32 GMT",
    "thumbnail": null
  },
  {
    "title": "Reset.css VS Nomalize.css",
    "link": "https://velog.io/@gawgjiug/Reset.css-VS-Nomalize.css",
    "description": "<h3 id=\"resetcss-vs-nomalizecss\">Reset.css VS Nomalize.css</h3>\n<hr>\n<ul>\n<li><p><code>reset.css</code> 는 브라우저의 기본 스타일을 완전히 제거하여 모든 브라우저 환경에서 동일한 스타일을 제공할 수 있도록 설계된 CSS 파일을 말한다.</p>\n</li>\n<li><p>이 파일은 다양한 HTML 요소의 기본 스타일을 리셋하여, 스타일링을 새로 시작할 수 있는 깨끗한 상태를 제공한다.</p>\n</li>\n<li><p>쉽게 생각해보자. chrome,safari,ie 등 각 브라우저마다 HTML 요소의 기본 스타일을 가지고 있기 때문에, CSS 로 스타일링을 적용할 때 이러한 특징이</p>\n</li>\n<li><p>동일한 스타일 적용을 방해할 수 있다. 때문에 이를 해결하기 위해서 기본 스타일을 <code>백지</code>로 만들기 위한 초기화 기법이라고 생각하면 된다.</p>\n</li>\n</ul>\n<hr>\n<h4 id=\"resetcss\">Reset.css</h4>\n<ul>\n<li><code>Eric Meyer CSS Reset</code> : 말 그대로 Eric Meyer가 만든 CSS Reset 파일이다.</li>\n</ul>\n<blockquote>\n<p>기본 HTML 페이지 (Reset 전)</p>\n</blockquote>\n<pre><code class=\"language-html\">&lt;!DOCTYPE html&gt;\n&lt;html lang=&quot;en&quot;&gt;\n&lt;head&gt;\n    &lt;meta charset=&quot;UTF-8&quot;&gt;\n    &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;\n    &lt;title&gt;Before CSS Reset&lt;/title&gt;\n    &lt;style&gt;\n        /* 기본 스타일 */\n        body {\n            font-family: Arial, sans-serif;\n            background-color: #f4f4f4;\n            color: #333;\n            margin: 20px;\n        }\n\n        h1 {\n            font-size: 2em;\n            margin-bottom: 0.5em;\n        }\n\n        p {\n            line-height: 1.6;\n            margin: 0 0 1em;\n        }\n\n        ul {\n            padding: 0;\n            list-style-type: disc;\n        }\n    &lt;/style&gt;\n&lt;/head&gt;\n&lt;body&gt;\n    &lt;h1&gt;제목&lt;/h1&gt;\n    &lt;p&gt;내용&lt;/p&gt;\n    &lt;ul&gt;\n        &lt;li&gt;List item 1&lt;/li&gt;\n        &lt;li&gt;List item 2&lt;/li&gt;\n    &lt;/ul&gt;\n&lt;/body&gt;\n&lt;/html&gt;</code></pre>\n<p><img src=\"https://github.com/user-attachments/assets/b7b8bebd-e023-4aa6-8f94-917615ad81d5\" alt=\"image\"></p>\n<blockquote>\n<p>Eric Meyer&#39;s CSS Reset 적용 후</p>\n</blockquote>\n<pre><code class=\"language-css\">/* Eric Meyer’s CSS Reset */\nhtml, body, div, span, applet, object, iframe,\nh1, h2, h3, h4, h5, h6, p, blockquote, pre,\na, abbr, acronym, address, big, cite, code,\ndel, dfn, em, font, img, ins, kbd, q, s, samp,\nsmall, strike, strong, sub, sup, tt, var,\nb, u, i, center,\ndl, dt, dd,\nol, ul, li,\nfieldset, form, label, legend,\ntable, caption, tbody, tfoot, thead, tr, th, td {\n  margin: 0;\n  padding: 0;\n  border: 0;\n  font-size: 100%;\n  font: inherit;\n  vertical-align: baseline;\n}\n\narticle, aside, details, figcaption, figure,\nfooter, header, hgroup, main, mark, nav, section,\nsummary {\n  display: block;\n}\n\nbody {\n  line-height: 1;\n}</code></pre>\n<p><img src=\"https://github.com/user-attachments/assets/274f4607-bcf3-4068-9712-e7d61c47228a\" alt=\"image\"></p>\n<ul>\n<li>속성이 초기화 되어 body에 기본으로 설정된 8px의 여백이 사라지고 Heading 태그는 모두 동일한 크기로 나오게 된다.</li>\n</ul>\n<hr>\n<h4 id=\"css-normalize\">CSS Normalize</h4>\n<ul>\n<li><p>다음은 <code>CSS Normalize</code> 이다 CSS Reset 과의 차이점은 CSS Reset은 모든 속성 값을 0으로 초기화하는 방식이라면, CSS Normalize는 모든 값을 0으로 초기화 하는 것이 아니라</p>\n</li>\n<li><p>필요한 부분은 유지하면서, 서로 다른 브라우저 간의 스타일 차이를 최소화 하는 CSS 파일을 말한다. 기본적인 브라우저 스타일을 유지하면서도 일관된 스타일을 보장하려고 한다.</p>\n<pre><code class=\"language-html\">&lt;!DOCTYPE html&gt;\n&lt;html lang=&quot;en&quot;&gt;\n&lt;head&gt;\n  &lt;meta charset=&quot;UTF-8&quot;&gt;\n  &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;\n  &lt;title&gt;Before CSS Reset&lt;/title&gt;\n  &lt;link rel=&quot;stylesheet&quot; href=&quot;normalize.css&quot;&gt;\n  &lt;style&gt;\n/* Normalize.css*/\nhtml {\n  line-height: 1.15; /* 1 */\n  -webkit-text-size-adjust: 100%; /* 2 */\n}\nbody {\n  margin: 0;\n}\nmain {\n  display: block;\n}\nh1 {\n  font-size: 2em;\n  margin: 0.67em 0;\n}\nhr {\n  box-sizing: content-box; /* 1 */\n  height: 0; /* 1 */\n  overflow: visible; /* 2 */\n}\npre {\n  font-family: monospace, monospace; /* 1 */\n  font-size: 1em; /* 2 */\n}\n\na {\n  background-color: transparent;\n}\n  &lt;/style&gt;\n&lt;/head&gt;\n&lt;body&gt;\n  &lt;div class=&quot;App&quot;&gt;\n      &lt;div class=&quot;Box&quot;&gt;&lt;/div&gt;\n      &lt;h1&gt;이건 Heading 1&lt;/h1&gt;\n      &lt;h2&gt;이건 Heading 2&lt;/h2&gt;\n      &lt;h3&gt;이건 Heading 3&lt;/h3&gt;\n      &lt;p&gt;요건 P&lt;/p&gt;\n  &lt;/div&gt;\n&lt;/body&gt;\n&lt;/html&gt;</code></pre>\n</li>\n</ul>\n<pre><code class=\"language-css\">.Box {\n    background-color: #4285F4;\n    height: 100px;\n    width: 100px;\n    border: 3px solid;\n  }</code></pre>\n<p><img src=\"https://github.com/user-attachments/assets/775cfd48-2295-46d4-ae2d-4120010bf135\" alt=\"image\"></p>\n<ul>\n<li>CSS Reset과 같이 여백은 사라졌지만 Heading 태그는 살아있는 모습을 볼 수 있다.</li>\n</ul>\n<p><a href=\"https://github.com/necolas/normalize.css\">Normalize.css 원본 링크</a></p>\n<hr>\n<h3 id=\"css-reset\">CSS Reset</h3>\n<ul>\n<li><p>CSS Reset은 웹 개발자가 완전히 사용자 정의 스타일을 적용하고 싶을 때 유용하게 쓸 수 있으며, 모든 브라우저에서 동일한 출발점을 제공한다.</p>\n</li>\n<li><p>즉, 기본 스타일을 제거하고 새로 스타일을 정의해야 하는 경우 CSS Reset이 유용한 것.</p>\n</li>\n<li><p>모든 브라우저에서 스타일이 동일하게 보장되므로,  디자인의 일관성을 유지할 수 있다는 단점이 있지만, 작업량이 많아진다.. </p>\n</li>\n</ul>\n<h3 id=\"nomalizecss\">Nomalize.css</h3>\n<ul>\n<li><p>Nomalize.css 는 브라우저 간 기본 스타일 차이를 최소화하고, 일관된 스타일을 제공하고자 할 때 유용하다. 기본 스타일이 그대로 유지되므로, 특정 디자인 요구 사항을 충족 시키기 어려울 수 있음</p>\n</li>\n<li><p>즉, 특정 디자인 가이드라인이 존재하는 팀 혹은 프로젝트 요구 사항이 있을 경우 CSS Reset을 선택할 수 있지만,</p>\n</li>\n<li><p>대부분 <code>Normalize.css</code> 를 선호한다. 기본 스타일을 일부 유지하면서도 브라우저 간 일관성을 유지할 수 있기 때문이다.</p>\n</li>\n</ul>\n<h3 id=\"한줄요약\">한줄요약</h3>\n<ul>\n<li><p><code>reset CSS</code> 는 CSS의 style을 초기화 시키는 것이라면,</p>\n</li>\n<li><p><code>normalize CSS</code> 는 브라우저의 사용하기 좋은 기본값은 유지하면서 브라우저간의 차이점을 수정하는 코드이다.</p>\n</li>\n</ul>\n",
    "pubDate": "Tue, 06 Aug 2024 06:41:13 GMT",
    "thumbnail": null
  },
  {
    "title": "그리디 알고리즘 with 백준",
    "link": "https://velog.io/@gawgjiug/%EA%B7%B8%EB%A6%AC%EB%94%94-%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98-with-%EB%B0%B1%EC%A4%80",
    "description": "<h3 id=\"그리디-알고리즘greedy-alhorithm\">그리디 알고리즘(Greedy Alhorithm)</h3>\n<ul>\n<li><p>그리디 알고리즘이란?</p>\n</li>\n<li><p>최적의 값을 구해야 하는 상황에서 사용되는 근시안적인 방법론으로 &#39;각 단계에서 최적이라고 생각되는 것을 선택&#39; 해 나가는 방식으로 진행하여 최종적인 해답에 도달하는 알고리즘이다</p>\n</li>\n<li><p>이때, 항상 최적의 값을 보장하는 것이 아니라 사실은 최적의 값의 &#39;근사한 값&#39; 을 목표로 하고 있는 것</p>\n</li>\n<li><p>순간마다 하는 선택은 그 순간 기점으로 지역적으로 최적의 선택이지만, 그 선택들을 계속 수집하한 결과인 최종적(전역적)인 해답은 최적이라는 보장이 없음</p>\n</li>\n</ul>\n<h4 id=\"그리디-알고리즘-문제를-해결하는-방법\">그리디 알고리즘 문제를 해결하는 방법</h4>\n<p><strong>1. 선택 절차 : 현재 상태에서의 최적의 해답을 선택한다.</strong>\n<strong>2. 적절성 검사 : 선택된 해가 문제의 조건을 만족하는지 검사한다.</strong>\n<strong>3. 해답 검사 : 원래의 문제가 해결되었는지 검사하고, 해결되지 않았다면 선택 절차로 돌아가 위 과정 반복</strong></p>\n<h4 id=\"❗️탐욕-알고리즘을-일상-예시-1--매트로이드\">❗️탐욕 알고리즘을 일상 예시 1 – 매트로이드</h4>\n<ul>\n<li>물견 가격은 4040원 이고, 손님이 5,000원을 주며 거스름돈의 동전의 개수를 최소한으로 하여 거슬러 달라고 한다.</li>\n</ul>\n<h4 id=\"탐욕-알고리즘의-문제-해결-과정을-적용\">탐욕 알고리즘의 문제 해결 과정을 적용</h4>\n<ol>\n<li><p>선택 절차\n거스름돈의 동전 개수를 줄이기 위해 현재 가장 가치가 높은 동전을 우선 선택한다.</p>\n</li>\n<li><p>적절성 검사\n1번 과정을 통해 선택된 동전들의 합이 거슬러 줄 금액을 초과하는지 검사한다.\n초과하면 가장 마지막에 선택한 동전을 삭제하고, 1번으로 돌아가 한 단계 작은 동전을 선택한다.</p>\n</li>\n<li><p>해답 검사\n선택된 동전들의 합이 거슬러 줄 금액과 일치하는지 검사한다.\n액수가 부족하면 1번 과정부터 다시 반복한다.</p>\n</li>\n</ol>\n<h4 id=\"탐욕-알고리즘-문제-풀이-with-백준\">탐욕 알고리즘 문제 풀이 with 백준</h4>\n<p><a href=\"https://www.acmicpc.net/problem/1931\">백준 1931번: 회의실 배정</a></p>\n<p><img src=\"https://velog.velcdn.com/images/gawgjiug/post/26a38497-2a12-4a6a-a7fe-e475552e97b5/image.png\" alt=\"\"></p>\n<pre><code class=\"language-java\">\nimport java.util.Arrays;\nimport java.util.Comparator;\nimport java.util.Scanner;\n\npublic class Main {\n    public static void main(String[] args) {\n\n\n        //백줕 1931번\n\n        Scanner sc = new Scanner(System.in);\n\n        int N = sc.nextInt();\n\n        /*time[][0] 은 시작 지점을 의미\n        * time[][1] 은 종료 시점을 의미*/\n\n        int [][] time = new int[N][2];\n\n        for(int i = 0 ; i&lt;N; i++){\n            time[i][0] = sc.nextInt(); //시작\n            time[i][1] = sc.nextInt(); //종료\n        }\n\n        Arrays.sort(time, new Comparator&lt;int[]&gt;() {\n            @Override\n            public int compare(int[] o1, int[] o2) {\n                if(o1[1] == o2[1]){\n                    return o1[0] - o2[0]; //종료 시간이 같을 경우 시작 시간이 빠른 순으로 정렬\n                }\n                return o1[1] - o2[1];\n            }\n        });\n\n        int count =0;\n        int prev_end_time = 0;\n\n        for(int i = 0; i&lt;N; i++){\n            if (prev_end_time &lt;= time[i][0]){ //직전 종료시간이 다음 회의 시작 시간보다 작거나 같으면 갱신\n                prev_end_time = time[i][1];\n                count++;\n            }\n        }\n\n        System.out.println(count);\n\n\n    }\n}</code></pre>\n<ul>\n<li><p>회의의 시작시간과 종료시간 각각을 2차원 배열로 저장한다</p>\n</li>\n<li><p>Array.sort를 사용하여 회의 배열을 정렬, 정렬 기준은 종료시간 만약 종료 시간이 같은 회의가 있을 경우, 시작 시간이 빠른 순서로 정렬</p>\n</li>\n<li><p>직전 종료시간(5)이 다음 회의시작 시간(6or5) 보다 작거나 같으면 갱신한다.</p>\n</li>\n</ul>\n",
    "pubDate": "Mon, 05 Aug 2024 07:20:03 GMT",
    "thumbnail": null
  },
  {
    "title": "배열 Vs 연결리스트",
    "link": "https://velog.io/@gawgjiug/%EB%B0%B0%EC%97%B4-Vs-%EC%97%B0%EA%B2%B0%EB%A6%AC%EC%8A%A4%ED%8A%B8",
    "description": "<h3 id=\"array-vs-linkedlist\">Array VS LinkedList</h3>\n<hr>\n<p>Array 와 LinkedList의 비교이다.</p>\n<h4 id=\"array배열\">Array(배열)</h4>\n<p><img src=\"https://github.com/user-attachments/assets/2f9b35a2-f258-4bcd-8c22-2e3c47ba26dc\" alt=\"image\"></p>\n<ul>\n<li><p><code>구조</code> : 배열은 메모리 상에서 <code>연속적</code>으로 저장된다. 각 원소는 고정된 <code>크기</code>를 가지며, 논리적 저장 순서와 물리적 저장 순서가 일치한다.</p>\n</li>\n<li><p><code>메모리 할당</code> : 배열의 크기는 고정되고, 선언 시 컴파일 타임에 메모리 공간이 할당된다. 이로 인해 메모리의 동적 크기 조정이 불가능하다는 특징을 갖는다.</p>\n</li>\n<li><p><code>장점</code> : 메모리 접근이 간단하고 빠르다. 연속된 메모리 블록을 사용하므로 <a href=\"https://github.com/gawgjiug/Eureka_CS_Study/blob/main/OS/os_cache.md\">캐시</a> 효율성이 높다.</p>\n</li>\n<li><p><code>단점</code> : 크기를 미리 정해야 하며, 크기 조정이 불가능 하여 필요한 만큼의 공간을 정확히 예측해야 하고, 삽입 및 삭제 작업이 비효율적일 수 있다.</p>\n</li>\n</ul>\n<h4 id=\"linkedlist-연결리스트\">LinkedList (연결리스트)</h4>\n<p><img src=\"https://github.com/user-attachments/assets/9522a89a-7f0d-425c-9b77-3aa068b96f55\" alt=\"image\"></p>\n<ul>\n<li><p><code>구조</code> : 연결 리스트는 메모리 상에서 비연속적으로 저장된다. 각 노드는 데이터와 다음 노드에 대한 포인터를 포함하기 때문에, 논리적 저장 순서와 물리적 저장 순서가 다르다.</p>\n</li>\n<li><p><code>메모리 할당</code> : 각 노드는 데이터가 삽입 될 때 마다 동적으로 메모리 공간을 할당 받는다. 이로 인해 배열과 달리 크기 조정이 유연하다는 장점이 있다.</p>\n</li>\n<li><p><code>장점</code> : 삽입 및 삭제가 효율적이고, 메모리 공간을 동적으로 관리할 수 있다.</p>\n</li>\n<li><p><code>단점</code> : 메모리 접근이 비효율적일 수 있다. 배열 처럼 연속적인 메모리 주소를 할당 받지 않았기 때문에 <code>index</code> 를 이용하여 임의로 접근하는 것이 불가능하다.\n 말을 즉슨 <strong>데이터를 탐색할 때 순차적으로 접근해야 한다는 것이다</strong></p>\n</li>\n</ul>\n<h3 id=\"데이터-접근-속도\">데이터 접근 속도</h3>\n<h4 id=\"array-\">Array :</h4>\n<ul>\n<li><p><code>시간복잡도</code> : 배열은 접근과 탐색이 용이하다고 했는데, <code>index</code>를 가지고 있기 때문에 탐색은 $O(1)$ 의 시간복잡도를 가진다. <strong>삽입의 경우는 맨 뒤에 삽입 할 경우는 $O(1)$ 이고,\n나머지 상황에서는 $O(n)$ 이다.</strong></p>\n</li>\n<li><p><code>특징</code> : 랜덤 액세스가 가능하여 임의의 위치에 존재하는 원소를 즉시 조회할 수 있다.</p>\n</li>\n</ul>\n<h4 id=\"linkedlist-\">LinkedList :</h4>\n<ul>\n<li><p><code>시간복잡도</code> : $O(n)$. 특정 노드를 찾기 위해 처음부터 순차적으로 탐색해야 하므로 접근속도가 느린편이다.</p>\n</li>\n<li><p><code>특징</code> : 인덱스가 없기 때문에 원소 접근 시 전체 리스트를 순회해야한다.</p>\n</li>\n</ul>\n<hr>\n<h3 id=\"메모리-효율성\">메모리 효율성</h3>\n<ul>\n<li><p>Array :</p>\n</li>\n<li><p><code>메모리 사용</code> : 연속된 메모리 블록을 사용하기 때문에 메모리 오버헤드가 적다. 하지만 크기를 변경할 수 없기 때문에 메모리 낭비가 발생할 수 있음</p>\n</li>\n<li><p><code>장점</code> : 장점은 역시 <code>캐시 효율성</code>이다 . 데이터의 빠른 접근이 가능하다.</p>\n</li>\n</ul>\n<ul>\n<li><p>LinkedList :</p>\n</li>\n<li><p><code>메모리 사용</code> : 각 노드는 데이터와 추가적인 포인터를 저장해야 하므로 메모리 오버헤드가 큰편이다. 각 노드의 포인터가 추가로 필요</p>\n</li>\n<li><p><code>장점</code> : 동적으로 크기를 조정할 수 있어 메모리 효율적 사용이 가능하다. 마찬가지로 삽입과 삭제 시 메모리 재배치가 필요하지 않다.</p>\n</li>\n</ul>\n<hr>\n<h3 id=\"활용사례\">활용사례</h3>\n<ul>\n<li><p><code>데이터 접근 패턴</code> : 데이터에 빠르게 접근해야 하는 경우에는 배열이 적합하다. Ex_ 웹 페이지 랜더링</p>\n</li>\n<li><p><strong>웹 브라우저는 DOM을 관리할 때 배열을 사용한다. HTML 요소들을 배열로 저장하여 빠르게 검색하고 수정하여 빠른 페이지 렌더링이 이루어진다.</strong></p>\n</li>\n<li><p><code>삽입과 삭제 빈도</code> : 빈번한 삽입과 삭제가 필요한 경우에는 연결리스트가 더 적합하다.</p>\n</li>\n<li><p><code>메모리 사용</code> : 메모리 사용의 효율성을 고려하여 배열 또는 연결리스트를 선택한다. 배열은 메모리 오버헤드가 적지만 크기 조정이 불가능하므로 연결 리스트를 더 선호함</p>\n</li>\n<li><p><code>알고리즘의 복잡도</code> : 빠른 랜덤 액세스가 필요하다면, 배열을 동적 크기 조정과 빠른 삽입/삭제가 필요한 서비스라면 연결리스트를 사용</p>\n</li>\n</ul>\n",
    "pubDate": "Wed, 31 Jul 2024 05:34:35 GMT",
    "thumbnail": null
  }
]