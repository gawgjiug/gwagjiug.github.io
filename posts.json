[
  {
    "title": "JS 배열",
    "link": "https://velog.io/@gawgjiug/JS-%EB%B0%B0%EC%97%B4",
    "description": "<h3 id=\"구조-분해-할당\">구조 분해 할당</h3>\n<ul>\n<li><p>구조 분해 할당 문법은 <strong>배열이나 객체의 속성을 해체</strong> 하여 그 값을 개별 변수에 담을 수 있게 하는 자바스크립트 표현식을 말한다.</p>\n</li>\n<li><p>일반 - 배열 항목을 개별 변수에 담을 때</p>\n</li>\n</ul>\n<pre><code class=\"language-js\">const fruits = [&#39;사과&#39;, &#39;바나나&#39;, &#39;딸기&#39;];\nconst apple = fruits[0];\nconst banana = fruits[1];\nconst strawberry = fruits[2];</code></pre>\n<ul>\n<li>구조 분해 할당 - 배열 항목을 개별 변수에 담을 때</li>\n</ul>\n<pre><code class=\"language-js\">const fruits = [&#39;사과&#39;, &#39;바나나&#39;, &#39;딸기&#39;, &#39;수박&#39;];\nconst [apple, ...others]  = fruits;\nconsole.log(apple);  // 사과\nconsole.log(others); // [&#39;바나나&#39;, &#39;딸기&#39;, &#39;수박&#39;]</code></pre>\n<h3 id=\"spread-syntax-전개구문\">Spread syntax (전개구문)</h3>\n<ul>\n<li>Spread는 펼치다라는 뜻으로, <code>Spread syntax</code>는 배열을 할당할 때 참조 값을 할당 하는게 아닌 배열안의 항목을 펼치는 방식으로 할당할 수 있다.</li>\n</ul>\n<pre><code class=\"language-js\">let arr = [1, &#39;two&#39;, 3, &#39;four&#39;];\nlet numberArr = [...arr, 5, &#39;six&#39;];\nconsole.log(&#39;numberArr: &#39;, numberArr);\n// [출력]\n// numberArr:  (6) [1, &#39;two&#39;, 3, &#39;four&#39;, 5, &#39;six&#39;]</code></pre>\n<h3 id=\"rest-parameters\">Rest parameters</h3>\n<ul>\n<li>나머지 매개변수 구문(Rest parameters)를 사용하면 함수가 무한한 수의 파라미터를 배열로 받을 수 있다.</li>\n</ul>\n<pre><code class=\"language-js\">function printFruits(...fruits) {\n    console.log(&#39;fruits: &#39;, fruits);\n}\nfunction printTitleAndFruits(title, ...fruits) {\n    console.log(&#39;title:&#39; , title);\n    console.log(&#39;fruits: &#39;, fruits);\n}\nprintFruits(&#39;사과&#39;, &#39;바나나&#39;, &#39;딸기&#39;);\nprintFruits(&#39;사과&#39;, &#39;바나나&#39;, &#39;딸기&#39;, &#39;포도&#39;);\nprintTitleAndFruits(&#39;과일출력&#39;, &#39;사과&#39;, &#39;바나나&#39;, &#39;딸기&#39;, &#39;포도&#39;);</code></pre>\n<h3 id=\"배열-복사하기\">배열 복사하기</h3>\n<ul>\n<li>배열은 객체이기 때문에 당연히 참조 값을 가지고 있고 <code>얇은 복사</code> 를 할 경우에는 하나의 배열을 변경하면 다른 배열도 같은 메모리 참조 값을 가지고 있기 때문에 결국에는 함께 변경이 된다</li>\n</ul>\n<pre><code class=\"language-js\">const fruits = [&#39;오렌지&#39;, &#39;포도&#39;, &#39;사과&#39;, &#39;바나나&#39;, &#39;딸기&#39;];\nconst copy = fruits;\ncopy.pop();                        // 끝에 항목 제거\nconsole.log(&#39;fruits: &#39;, fruits);   // [&#39;오렌지&#39;, &#39;포도&#39;, &#39;사과&#39;, &#39;바나나&#39;]\nconsole.log(&#39;copyFruits: &#39;, copy); // [&#39;오렌지&#39;, &#39;포도&#39;, &#39;사과&#39;, &#39;바나나&#39;]</code></pre>\n<ul>\n<li>전개 구문을 사용해서 <code>deep copy</code> 문법을 사용하면 해당 원본에 값만 가져오기 때문에 하나의 배열을 변경해도 별개로서 존재한다.</li>\n</ul>\n<pre><code class=\"language-js\">const fruits = [&#39;오렌지&#39;, &#39;포도&#39;, &#39;사과&#39;, &#39;바나나&#39;, &#39;딸기&#39;];\nconst copy = [...fruits];\ncopy.pop();                        // 끝에 항목 제거\nconsole.log(&#39;fruits: &#39;, fruits);   // [&#39;오렌지&#39;, &#39;포도&#39;, &#39;사과&#39;, &#39;바나나&#39;, &#39;딸기&#39;]\nconsole.log(&#39;copyFruits: &#39;, copy); // [&#39;오렌지&#39;, &#39;포도&#39;, &#39;사과&#39;, &#39;바나나&#39;]</code></pre>\n<ul>\n<li>혹은 Array.from () 메서드를 이용해도 된다.</li>\n</ul>\n<pre><code class=\"language-js\">const fruits = [&#39;오렌지&#39;, &#39;포도&#39;, &#39;사과&#39;, &#39;바나나&#39;, &#39;딸기&#39;];\nconst copy = Array.from(fruits);\ncopy.pop();                        // 끝에 항목 제거\nconsole.log(&#39;fruits: &#39;, fruits);   // [&#39;오렌지&#39;, &#39;포도&#39;, &#39;사과&#39;, &#39;바나나&#39;, &#39;딸기&#39;]\nconsole.log(&#39;copyFruits: &#39;, copy); // [&#39;오렌지&#39;, &#39;포도&#39;, &#39;사과&#39;, &#39;바나나&#39;]</code></pre>\n",
    "pubDate": "Fri, 09 Aug 2024 05:26:32 GMT",
    "thumbnail": null
  },
  {
    "title": "Reset.css VS Nomalize.css",
    "link": "https://velog.io/@gawgjiug/Reset.css-VS-Nomalize.css",
    "description": "<h3 id=\"resetcss-vs-nomalizecss\">Reset.css VS Nomalize.css</h3>\n<hr>\n<ul>\n<li><p><code>reset.css</code> 는 브라우저의 기본 스타일을 완전히 제거하여 모든 브라우저 환경에서 동일한 스타일을 제공할 수 있도록 설계된 CSS 파일을 말한다.</p>\n</li>\n<li><p>이 파일은 다양한 HTML 요소의 기본 스타일을 리셋하여, 스타일링을 새로 시작할 수 있는 깨끗한 상태를 제공한다.</p>\n</li>\n<li><p>쉽게 생각해보자. chrome,safari,ie 등 각 브라우저마다 HTML 요소의 기본 스타일을 가지고 있기 때문에, CSS 로 스타일링을 적용할 때 이러한 특징이</p>\n</li>\n<li><p>동일한 스타일 적용을 방해할 수 있다. 때문에 이를 해결하기 위해서 기본 스타일을 <code>백지</code>로 만들기 위한 초기화 기법이라고 생각하면 된다.</p>\n</li>\n</ul>\n<hr>\n<h4 id=\"resetcss\">Reset.css</h4>\n<ul>\n<li><code>Eric Meyer CSS Reset</code> : 말 그대로 Eric Meyer가 만든 CSS Reset 파일이다.</li>\n</ul>\n<blockquote>\n<p>기본 HTML 페이지 (Reset 전)</p>\n</blockquote>\n<pre><code class=\"language-html\">&lt;!DOCTYPE html&gt;\n&lt;html lang=&quot;en&quot;&gt;\n&lt;head&gt;\n    &lt;meta charset=&quot;UTF-8&quot;&gt;\n    &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;\n    &lt;title&gt;Before CSS Reset&lt;/title&gt;\n    &lt;style&gt;\n        /* 기본 스타일 */\n        body {\n            font-family: Arial, sans-serif;\n            background-color: #f4f4f4;\n            color: #333;\n            margin: 20px;\n        }\n\n        h1 {\n            font-size: 2em;\n            margin-bottom: 0.5em;\n        }\n\n        p {\n            line-height: 1.6;\n            margin: 0 0 1em;\n        }\n\n        ul {\n            padding: 0;\n            list-style-type: disc;\n        }\n    &lt;/style&gt;\n&lt;/head&gt;\n&lt;body&gt;\n    &lt;h1&gt;제목&lt;/h1&gt;\n    &lt;p&gt;내용&lt;/p&gt;\n    &lt;ul&gt;\n        &lt;li&gt;List item 1&lt;/li&gt;\n        &lt;li&gt;List item 2&lt;/li&gt;\n    &lt;/ul&gt;\n&lt;/body&gt;\n&lt;/html&gt;</code></pre>\n<p><img src=\"https://github.com/user-attachments/assets/b7b8bebd-e023-4aa6-8f94-917615ad81d5\" alt=\"image\"></p>\n<blockquote>\n<p>Eric Meyer&#39;s CSS Reset 적용 후</p>\n</blockquote>\n<pre><code class=\"language-css\">/* Eric Meyer’s CSS Reset */\nhtml, body, div, span, applet, object, iframe,\nh1, h2, h3, h4, h5, h6, p, blockquote, pre,\na, abbr, acronym, address, big, cite, code,\ndel, dfn, em, font, img, ins, kbd, q, s, samp,\nsmall, strike, strong, sub, sup, tt, var,\nb, u, i, center,\ndl, dt, dd,\nol, ul, li,\nfieldset, form, label, legend,\ntable, caption, tbody, tfoot, thead, tr, th, td {\n  margin: 0;\n  padding: 0;\n  border: 0;\n  font-size: 100%;\n  font: inherit;\n  vertical-align: baseline;\n}\n\narticle, aside, details, figcaption, figure,\nfooter, header, hgroup, main, mark, nav, section,\nsummary {\n  display: block;\n}\n\nbody {\n  line-height: 1;\n}</code></pre>\n<p><img src=\"https://github.com/user-attachments/assets/274f4607-bcf3-4068-9712-e7d61c47228a\" alt=\"image\"></p>\n<ul>\n<li>속성이 초기화 되어 body에 기본으로 설정된 8px의 여백이 사라지고 Heading 태그는 모두 동일한 크기로 나오게 된다.</li>\n</ul>\n<hr>\n<h4 id=\"css-normalize\">CSS Normalize</h4>\n<ul>\n<li><p>다음은 <code>CSS Normalize</code> 이다 CSS Reset 과의 차이점은 CSS Reset은 모든 속성 값을 0으로 초기화하는 방식이라면, CSS Normalize는 모든 값을 0으로 초기화 하는 것이 아니라</p>\n</li>\n<li><p>필요한 부분은 유지하면서, 서로 다른 브라우저 간의 스타일 차이를 최소화 하는 CSS 파일을 말한다. 기본적인 브라우저 스타일을 유지하면서도 일관된 스타일을 보장하려고 한다.</p>\n<pre><code class=\"language-html\">&lt;!DOCTYPE html&gt;\n&lt;html lang=&quot;en&quot;&gt;\n&lt;head&gt;\n  &lt;meta charset=&quot;UTF-8&quot;&gt;\n  &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;\n  &lt;title&gt;Before CSS Reset&lt;/title&gt;\n  &lt;link rel=&quot;stylesheet&quot; href=&quot;normalize.css&quot;&gt;\n  &lt;style&gt;\n/* Normalize.css*/\nhtml {\n  line-height: 1.15; /* 1 */\n  -webkit-text-size-adjust: 100%; /* 2 */\n}\nbody {\n  margin: 0;\n}\nmain {\n  display: block;\n}\nh1 {\n  font-size: 2em;\n  margin: 0.67em 0;\n}\nhr {\n  box-sizing: content-box; /* 1 */\n  height: 0; /* 1 */\n  overflow: visible; /* 2 */\n}\npre {\n  font-family: monospace, monospace; /* 1 */\n  font-size: 1em; /* 2 */\n}\n\na {\n  background-color: transparent;\n}\n  &lt;/style&gt;\n&lt;/head&gt;\n&lt;body&gt;\n  &lt;div class=&quot;App&quot;&gt;\n      &lt;div class=&quot;Box&quot;&gt;&lt;/div&gt;\n      &lt;h1&gt;이건 Heading 1&lt;/h1&gt;\n      &lt;h2&gt;이건 Heading 2&lt;/h2&gt;\n      &lt;h3&gt;이건 Heading 3&lt;/h3&gt;\n      &lt;p&gt;요건 P&lt;/p&gt;\n  &lt;/div&gt;\n&lt;/body&gt;\n&lt;/html&gt;</code></pre>\n</li>\n</ul>\n<pre><code class=\"language-css\">.Box {\n    background-color: #4285F4;\n    height: 100px;\n    width: 100px;\n    border: 3px solid;\n  }</code></pre>\n<p><img src=\"https://github.com/user-attachments/assets/775cfd48-2295-46d4-ae2d-4120010bf135\" alt=\"image\"></p>\n<ul>\n<li>CSS Reset과 같이 여백은 사라졌지만 Heading 태그는 살아있는 모습을 볼 수 있다.</li>\n</ul>\n<p><a href=\"https://github.com/necolas/normalize.css\">Normalize.css 원본 링크</a></p>\n<hr>\n<h3 id=\"css-reset\">CSS Reset</h3>\n<ul>\n<li><p>CSS Reset은 웹 개발자가 완전히 사용자 정의 스타일을 적용하고 싶을 때 유용하게 쓸 수 있으며, 모든 브라우저에서 동일한 출발점을 제공한다.</p>\n</li>\n<li><p>즉, 기본 스타일을 제거하고 새로 스타일을 정의해야 하는 경우 CSS Reset이 유용한 것.</p>\n</li>\n<li><p>모든 브라우저에서 스타일이 동일하게 보장되므로,  디자인의 일관성을 유지할 수 있다는 단점이 있지만, 작업량이 많아진다.. </p>\n</li>\n</ul>\n<h3 id=\"nomalizecss\">Nomalize.css</h3>\n<ul>\n<li><p>Nomalize.css 는 브라우저 간 기본 스타일 차이를 최소화하고, 일관된 스타일을 제공하고자 할 때 유용하다. 기본 스타일이 그대로 유지되므로, 특정 디자인 요구 사항을 충족 시키기 어려울 수 있음</p>\n</li>\n<li><p>즉, 특정 디자인 가이드라인이 존재하는 팀 혹은 프로젝트 요구 사항이 있을 경우 CSS Reset을 선택할 수 있지만,</p>\n</li>\n<li><p>대부분 <code>Normalize.css</code> 를 선호한다. 기본 스타일을 일부 유지하면서도 브라우저 간 일관성을 유지할 수 있기 때문이다.</p>\n</li>\n</ul>\n<h3 id=\"한줄요약\">한줄요약</h3>\n<ul>\n<li><p><code>reset CSS</code> 는 CSS의 style을 초기화 시키는 것이라면,</p>\n</li>\n<li><p><code>normalize CSS</code> 는 브라우저의 사용하기 좋은 기본값은 유지하면서 브라우저간의 차이점을 수정하는 코드이다.</p>\n</li>\n</ul>\n",
    "pubDate": "Tue, 06 Aug 2024 06:41:13 GMT",
    "thumbnail": null
  },
  {
    "title": "그리디 알고리즘 with 백준",
    "link": "https://velog.io/@gawgjiug/%EA%B7%B8%EB%A6%AC%EB%94%94-%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98-with-%EB%B0%B1%EC%A4%80",
    "description": "<h3 id=\"그리디-알고리즘greedy-alhorithm\">그리디 알고리즘(Greedy Alhorithm)</h3>\n<ul>\n<li><p>그리디 알고리즘이란?</p>\n</li>\n<li><p>최적의 값을 구해야 하는 상황에서 사용되는 근시안적인 방법론으로 &#39;각 단계에서 최적이라고 생각되는 것을 선택&#39; 해 나가는 방식으로 진행하여 최종적인 해답에 도달하는 알고리즘이다</p>\n</li>\n<li><p>이때, 항상 최적의 값을 보장하는 것이 아니라 사실은 최적의 값의 &#39;근사한 값&#39; 을 목표로 하고 있는 것</p>\n</li>\n<li><p>순간마다 하는 선택은 그 순간 기점으로 지역적으로 최적의 선택이지만, 그 선택들을 계속 수집하한 결과인 최종적(전역적)인 해답은 최적이라는 보장이 없음</p>\n</li>\n</ul>\n<h4 id=\"그리디-알고리즘-문제를-해결하는-방법\">그리디 알고리즘 문제를 해결하는 방법</h4>\n<p><strong>1. 선택 절차 : 현재 상태에서의 최적의 해답을 선택한다.</strong>\n<strong>2. 적절성 검사 : 선택된 해가 문제의 조건을 만족하는지 검사한다.</strong>\n<strong>3. 해답 검사 : 원래의 문제가 해결되었는지 검사하고, 해결되지 않았다면 선택 절차로 돌아가 위 과정 반복</strong></p>\n<h4 id=\"❗️탐욕-알고리즘을-일상-예시-1--매트로이드\">❗️탐욕 알고리즘을 일상 예시 1 – 매트로이드</h4>\n<ul>\n<li>물견 가격은 4040원 이고, 손님이 5,000원을 주며 거스름돈의 동전의 개수를 최소한으로 하여 거슬러 달라고 한다.</li>\n</ul>\n<h4 id=\"탐욕-알고리즘의-문제-해결-과정을-적용\">탐욕 알고리즘의 문제 해결 과정을 적용</h4>\n<ol>\n<li><p>선택 절차\n거스름돈의 동전 개수를 줄이기 위해 현재 가장 가치가 높은 동전을 우선 선택한다.</p>\n</li>\n<li><p>적절성 검사\n1번 과정을 통해 선택된 동전들의 합이 거슬러 줄 금액을 초과하는지 검사한다.\n초과하면 가장 마지막에 선택한 동전을 삭제하고, 1번으로 돌아가 한 단계 작은 동전을 선택한다.</p>\n</li>\n<li><p>해답 검사\n선택된 동전들의 합이 거슬러 줄 금액과 일치하는지 검사한다.\n액수가 부족하면 1번 과정부터 다시 반복한다.</p>\n</li>\n</ol>\n<h4 id=\"탐욕-알고리즘-문제-풀이-with-백준\">탐욕 알고리즘 문제 풀이 with 백준</h4>\n<p><a href=\"https://www.acmicpc.net/problem/1931\">백준 1931번: 회의실 배정</a></p>\n<p><img src=\"https://velog.velcdn.com/images/gawgjiug/post/26a38497-2a12-4a6a-a7fe-e475552e97b5/image.png\" alt=\"\"></p>\n<pre><code class=\"language-java\">\nimport java.util.Arrays;\nimport java.util.Comparator;\nimport java.util.Scanner;\n\npublic class Main {\n    public static void main(String[] args) {\n\n\n        //백줕 1931번\n\n        Scanner sc = new Scanner(System.in);\n\n        int N = sc.nextInt();\n\n        /*time[][0] 은 시작 지점을 의미\n        * time[][1] 은 종료 시점을 의미*/\n\n        int [][] time = new int[N][2];\n\n        for(int i = 0 ; i&lt;N; i++){\n            time[i][0] = sc.nextInt(); //시작\n            time[i][1] = sc.nextInt(); //종료\n        }\n\n        Arrays.sort(time, new Comparator&lt;int[]&gt;() {\n            @Override\n            public int compare(int[] o1, int[] o2) {\n                if(o1[1] == o2[1]){\n                    return o1[0] - o2[0]; //종료 시간이 같을 경우 시작 시간이 빠른 순으로 정렬\n                }\n                return o1[1] - o2[1];\n            }\n        });\n\n        int count =0;\n        int prev_end_time = 0;\n\n        for(int i = 0; i&lt;N; i++){\n            if (prev_end_time &lt;= time[i][0]){ //직전 종료시간이 다음 회의 시작 시간보다 작거나 같으면 갱신\n                prev_end_time = time[i][1];\n                count++;\n            }\n        }\n\n        System.out.println(count);\n\n\n    }\n}</code></pre>\n<ul>\n<li><p>회의의 시작시간과 종료시간 각각을 2차원 배열로 저장한다</p>\n</li>\n<li><p>Array.sort를 사용하여 회의 배열을 정렬, 정렬 기준은 종료시간 만약 종료 시간이 같은 회의가 있을 경우, 시작 시간이 빠른 순서로 정렬</p>\n</li>\n<li><p>직전 종료시간(5)이 다음 회의시작 시간(6or5) 보다 작거나 같으면 갱신한다.</p>\n</li>\n</ul>\n",
    "pubDate": "Mon, 05 Aug 2024 07:20:03 GMT",
    "thumbnail": null
  },
  {
    "title": "배열 Vs 연결리스트",
    "link": "https://velog.io/@gawgjiug/%EB%B0%B0%EC%97%B4-Vs-%EC%97%B0%EA%B2%B0%EB%A6%AC%EC%8A%A4%ED%8A%B8",
    "description": "<h3 id=\"array-vs-linkedlist\">Array VS LinkedList</h3>\n<hr>\n<p>Array 와 LinkedList의 비교이다.</p>\n<h4 id=\"array배열\">Array(배열)</h4>\n<p><img src=\"https://github.com/user-attachments/assets/2f9b35a2-f258-4bcd-8c22-2e3c47ba26dc\" alt=\"image\"></p>\n<ul>\n<li><p><code>구조</code> : 배열은 메모리 상에서 <code>연속적</code>으로 저장된다. 각 원소는 고정된 <code>크기</code>를 가지며, 논리적 저장 순서와 물리적 저장 순서가 일치한다.</p>\n</li>\n<li><p><code>메모리 할당</code> : 배열의 크기는 고정되고, 선언 시 컴파일 타임에 메모리 공간이 할당된다. 이로 인해 메모리의 동적 크기 조정이 불가능하다는 특징을 갖는다.</p>\n</li>\n<li><p><code>장점</code> : 메모리 접근이 간단하고 빠르다. 연속된 메모리 블록을 사용하므로 <a href=\"https://github.com/gawgjiug/Eureka_CS_Study/blob/main/OS/os_cache.md\">캐시</a> 효율성이 높다.</p>\n</li>\n<li><p><code>단점</code> : 크기를 미리 정해야 하며, 크기 조정이 불가능 하여 필요한 만큼의 공간을 정확히 예측해야 하고, 삽입 및 삭제 작업이 비효율적일 수 있다.</p>\n</li>\n</ul>\n<h4 id=\"linkedlist-연결리스트\">LinkedList (연결리스트)</h4>\n<p><img src=\"https://github.com/user-attachments/assets/9522a89a-7f0d-425c-9b77-3aa068b96f55\" alt=\"image\"></p>\n<ul>\n<li><p><code>구조</code> : 연결 리스트는 메모리 상에서 비연속적으로 저장된다. 각 노드는 데이터와 다음 노드에 대한 포인터를 포함하기 때문에, 논리적 저장 순서와 물리적 저장 순서가 다르다.</p>\n</li>\n<li><p><code>메모리 할당</code> : 각 노드는 데이터가 삽입 될 때 마다 동적으로 메모리 공간을 할당 받는다. 이로 인해 배열과 달리 크기 조정이 유연하다는 장점이 있다.</p>\n</li>\n<li><p><code>장점</code> : 삽입 및 삭제가 효율적이고, 메모리 공간을 동적으로 관리할 수 있다.</p>\n</li>\n<li><p><code>단점</code> : 메모리 접근이 비효율적일 수 있다. 배열 처럼 연속적인 메모리 주소를 할당 받지 않았기 때문에 <code>index</code> 를 이용하여 임의로 접근하는 것이 불가능하다.\n 말을 즉슨 <strong>데이터를 탐색할 때 순차적으로 접근해야 한다는 것이다</strong></p>\n</li>\n</ul>\n<h3 id=\"데이터-접근-속도\">데이터 접근 속도</h3>\n<h4 id=\"array-\">Array :</h4>\n<ul>\n<li><p><code>시간복잡도</code> : 배열은 접근과 탐색이 용이하다고 했는데, <code>index</code>를 가지고 있기 때문에 탐색은 $O(1)$ 의 시간복잡도를 가진다. <strong>삽입의 경우는 맨 뒤에 삽입 할 경우는 $O(1)$ 이고,\n나머지 상황에서는 $O(n)$ 이다.</strong></p>\n</li>\n<li><p><code>특징</code> : 랜덤 액세스가 가능하여 임의의 위치에 존재하는 원소를 즉시 조회할 수 있다.</p>\n</li>\n</ul>\n<h4 id=\"linkedlist-\">LinkedList :</h4>\n<ul>\n<li><p><code>시간복잡도</code> : $O(n)$. 특정 노드를 찾기 위해 처음부터 순차적으로 탐색해야 하므로 접근속도가 느린편이다.</p>\n</li>\n<li><p><code>특징</code> : 인덱스가 없기 때문에 원소 접근 시 전체 리스트를 순회해야한다.</p>\n</li>\n</ul>\n<hr>\n<h3 id=\"메모리-효율성\">메모리 효율성</h3>\n<ul>\n<li><p>Array :</p>\n</li>\n<li><p><code>메모리 사용</code> : 연속된 메모리 블록을 사용하기 때문에 메모리 오버헤드가 적다. 하지만 크기를 변경할 수 없기 때문에 메모리 낭비가 발생할 수 있음</p>\n</li>\n<li><p><code>장점</code> : 장점은 역시 <code>캐시 효율성</code>이다 . 데이터의 빠른 접근이 가능하다.</p>\n</li>\n</ul>\n<ul>\n<li><p>LinkedList :</p>\n</li>\n<li><p><code>메모리 사용</code> : 각 노드는 데이터와 추가적인 포인터를 저장해야 하므로 메모리 오버헤드가 큰편이다. 각 노드의 포인터가 추가로 필요</p>\n</li>\n<li><p><code>장점</code> : 동적으로 크기를 조정할 수 있어 메모리 효율적 사용이 가능하다. 마찬가지로 삽입과 삭제 시 메모리 재배치가 필요하지 않다.</p>\n</li>\n</ul>\n<hr>\n<h3 id=\"활용사례\">활용사례</h3>\n<ul>\n<li><p><code>데이터 접근 패턴</code> : 데이터에 빠르게 접근해야 하는 경우에는 배열이 적합하다. Ex_ 웹 페이지 랜더링</p>\n</li>\n<li><p><strong>웹 브라우저는 DOM을 관리할 때 배열을 사용한다. HTML 요소들을 배열로 저장하여 빠르게 검색하고 수정하여 빠른 페이지 렌더링이 이루어진다.</strong></p>\n</li>\n<li><p><code>삽입과 삭제 빈도</code> : 빈번한 삽입과 삭제가 필요한 경우에는 연결리스트가 더 적합하다.</p>\n</li>\n<li><p><code>메모리 사용</code> : 메모리 사용의 효율성을 고려하여 배열 또는 연결리스트를 선택한다. 배열은 메모리 오버헤드가 적지만 크기 조정이 불가능하므로 연결 리스트를 더 선호함</p>\n</li>\n<li><p><code>알고리즘의 복잡도</code> : 빠른 랜덤 액세스가 필요하다면, 배열을 동적 크기 조정과 빠른 삽입/삭제가 필요한 서비스라면 연결리스트를 사용</p>\n</li>\n</ul>\n",
    "pubDate": "Wed, 31 Jul 2024 05:34:35 GMT",
    "thumbnail": null
  },
  {
    "title": "웹 소켓이란?",
    "link": "https://velog.io/@gawgjiug/%EC%9B%B9-%EC%86%8C%EC%BC%93%EC%9D%B4%EB%9E%80",
    "description": "<h3 id=\"웹-소켓이란\">웹 소켓이란?</h3>\n<p> <img src=\"https://github.com/user-attachments/assets/45f6c660-1c64-41cc-866c-f75a2ca2c222\" alt=\"웹소켓\"></p>\n<ul>\n<li><p>웹 소켓은 <code>실시간 통신</code>이 필요할 때 적극적으로 사용되는 기술이다.</p>\n</li>\n<li><p>초기의 인터넷 통신 방식은 주로 HTTP를 이용한 <strong>클라이언트(요청) -&gt; 서버(응답) 모델</strong> 을 통해 진행되었다. 즉 클라이언트가 서버에 요청(Request)을 보내고,\n서버가 이에 응답(Response) 하는 <code>반이중 통신 방식</code>을 따른다.</p>\n</li>\n<li><p>이러한 방식은 페이지를 요청하는 등의 간단한 작업에는 효과적이지만, 실시간으로 데이터를 주고 받는 서비스를 제공하기에는 한계점이 분명히 있다.</p>\n</li>\n<li><p>클라이언트가 서버에게 요청하지 않는 이상 서버는 클라이언트에게 먼저 데이터를 보낼 수 없기에 <code>실시간 통신</code>과 비슷한 상황을 HTTP 통신으로 이루기 위해선</p>\n</li>\n<li><p>클라이언트는 항상 새로운 데이터가 있는지 확인을 하기 위해 서버에 지속적으로 요청을 보낼 수 밖에 없다.</p>\n</li>\n<li><p>이렇게 되면 트래픽을 필요이상으로 증가 시키고, 이로 인해 서버의 비용이 증가될 뿐더러 요청과 응답 사이의 지연시간이 있기 때문에 <code>실시간 통신</code>의 효율성을 저하시킬 수 있다.</p>\n</li>\n</ul>\n<hr>\n<h3 id=\"웹-소켓-이전의-통신-방식\">웹 소켓 이전의 통신 방식</h3>\n<ul>\n<li>웹 소켓이 등장하기 전 주로 사용되던 HTTP 프로토콜을 기반으로 한 실시간 통신 방식은 어떤 것들이 있을까??</li>\n</ul>\n<h4 id=\"폴링polling\">폴링(Polling)</h4>\n<ul>\n<li><p><img src=\"https://github.com/user-attachments/assets/a8128a61-06ec-4381-bf20-0d3705aeab8b\" alt=\"폴링\"></p>\n</li>\n<li><p>폴링은 클라이언트가 주기적으로 서버에 요청을 보내는 방식을 말한다. 기본적으로 <code>일정시간</code>을 정해 놓고 새로운 데이터가 있는지 주기적으로 서버에 요청을 보내서 확인하게 된다.</p>\n</li>\n<li><p>이때, 새로운 데이터가 없더라도 서버는 응답을 보내게 된다.</p>\n</li>\n</ul>\n<pre><code class=\"language-javascript\">// 클라이언트\nsetInterval(function(){\n    fetch(&#39;/server&#39;).then(function(response){\n        console.log(response);\n    });\n}, 5000); // 5초마다 서버에 요청\n\n// 서버 (Node.js)\napp.get(&#39;/server&#39;, function(req, res){\n    res.send(&#39;새로운 데이터&#39;);\n});</code></pre>\n<ul>\n<li><p>간단한 메커니즘으로 구현이 매우 쉽다는 장점이 있지만, <code>불필요한 요청</code> 의 수가 증가할 수 있고 이는 서버 비용의 증가로 이어진다.</p>\n</li>\n<li><p>그리고 요청과 응답사이의 <code>지연 시간</code>이 발생하기 때문에 실시간통신이 제한될 수 밖에 없다.</p>\n</li>\n</ul>\n<h4 id=\"롱-폴링long-polling\">롱 폴링(Long Polling)</h4>\n<ul>\n<li><p><img src=\"https://github.com/user-attachments/assets/5c7182e9-aa3a-429a-a121-d550bfdab886\" alt=\"롱폴링\"></p>\n</li>\n<li><p>롱 폴링은 <code>폴링</code>을 조금 개선한 방식을 말하는데,</p>\n</li>\n<li><p>먼저 클라이언트가 서버에게 요청을 보내면, 서버는 새로운 데이터가 있는지 확인하게 되고, 일정 시간 동안 새로운 데이터가 없다면 <code>Time Out</code>을 발생시키고 응답을 보낸다.</p>\n</li>\n<li><p>반면에 새로운 데이터가 있다면 즉시 새로운 데이터에 대한 응답(Response)을 보낸다.</p>\n</li>\n</ul>\n<pre><code class=\"language-javascript\">// 클라이언트\nfunction longPoll(){\n    fetch(&#39;/server&#39;).then(function(response){\n        console.log(response);\n        longPoll();\n    });\n}\nlongPoll();\n\n// 서버 (Node.js)\napp.get(&#39;/server&#39;, function(req, res){\n    setTimeout(function(){\n        res.send(&#39;새로운 데이터&#39;);\n    }, 10000); // 10초 후에 응답\n});</code></pre>\n<ul>\n<li><p>새로운 데이터가 있거나, 설정한 10초의 시간이 지나면 응답을 보내는 것.</p>\n</li>\n<li><p>이러한 방식을 사용하면 <code>폴링</code>보다는 데이터 업데이트에 반응하는 속도는 빨라지지만, 서버의 부담이 커진다.</p>\n</li>\n<li><p>서버가 클라이언트로부터 요청을 받을 때 부터 응답을 보내기 까지 클라이언트와의 연결이 지속되는데, 동시에 여러 클라이언트가 서비스를 사용하면 그만큼의 연결을 유지해야 하므로 부하가 발생한다.</p>\n</li>\n</ul>\n<h4 id=\"웹-소켓\">웹 소켓</h4>\n<ul>\n<li><p>웹 소켓 통신은 다음과 같은 방식으로 이루어진다.</p>\n</li>\n<li><p><img src=\"https://github.com/user-attachments/assets/620b7732-7f45-487a-8e75-b5a874e6e288\" alt=\"웹소켓\"></p>\n</li>\n</ul>\n<ul>\n<li><p>클라이언트가 서버에게 Websocket 을 연결하자는 요청을 HTTP 를 통해 전송한다. 그것이 가능한 경우에 서버가 이를 수락하는 응답을 HTTP로 보내게 된다.</p>\n</li>\n<li><p>이러한 handshake 과정을 거치고 나면 연결이 이루어지고, 그 때부터 클라이언트와 서버는 HTTP가 아닌 WebSocket 프로토콜을 사용하여 소통한다.</p>\n</li>\n<li><p>HTTP의 <code>편지</code>방식이 아니라, <code>전화통화</code>가 이루어지는 것. 여기서 클라이언트와 서버는 자유롭게 서로에게 메시지를 보낼 수 있게된다.</p>\n</li>\n<li><p><code>WebSocket</code> 에서의 통신은 헤더의 크기가 작고, 오버헤드가 적기 때문에 HTTP 보다 효율적인 통신이 가능하다.</p>\n<blockquote>\n<p>헤더는 우편물에 붙은 송장 과 비슷한것.</p>\n</blockquote>\n</li>\n</ul>\n<pre><code class=\"language-js\">GET /socket\nHost: yong-nyong-tistory.com\nOrigin: https://gwagjiug.com\nConnection: Upgrade\nUpgrade: websocket\nSec-WebSocket-Key: Ivyio/9s+lYongNyongczP8Q==\nSec-WebSocket-Version: 13</code></pre>\n<ul>\n<li>이러한 연결은 클라이언트와 서버 둘 중 한쪽이 연결을 종료하자는 메시지를 보낼 때 까지 지속된다. 한쪽이 <code>close</code> 프레임을 보내면, 다른쪽이 이를 확인하고 <code>close</code> 프레임을 응답으로 보냄으로써 연결이 종료되는 것.</li>\n</ul>\n<blockquote>\n<p>만약에 클라이언트의 폰 혹은 PC가 <code>close</code>를 보내지 못하고 꺼지게 된다면?</p>\n</blockquote>\n<ul>\n<li><p>비정상적인 종료를 감지하는 방법들이 있다.</p>\n</li>\n<li><p>지정된 시간 동안 메시지가 없을 시 확인 패킷을 보내는 방법, 주기족으로 ping,pong 프레임을 주고 받아서 서로의 접속 여부를 확인하는 방법도있다.</p>\n</li>\n<li><p>WebSocket은 하나의 연결을 끝까지 유지하고, 그 과정에서도 적은 자원만 소모하기 때문에 Long Polling 만큼 서버에 부담을 주지 않을 수 있는 것</p>\n</li>\n</ul>\n<hr>\n<h4 id=\"웹소켓의-한계점\">웹소켓의 한계점</h4>\n<ul>\n<li><p>웹 소켓은 서버의 설계에 따라 구현이 복잡해질 수 있다. 특히 <a href=\"https://github.com/gawgjiug/Eureka_CS_Study/blob/main/Network/network_load_balancing.md\">로드밸런싱</a> 이 적용된 서버에서는 고려하고 설정할 부분이 많아지는데,</p>\n</li>\n<li><p>로드밸런싱은 기본적으로 서러 여러 대가 클라이언트 요청을 나눠서 받는 방식인데, 웹 소켓은 특정 서버와의 지속적인 연결 안에서만 이루어지기 때문에 한 서버와 웹 소켓 통신을 시작하면 이후로도 계속 그 서버로만 데이터가 전송되도록 설정해야한다.</p>\n</li>\n<li><p>NGINX,AWS ELB 등 WebSocket을 처리할 수 있는 로드 밸런서를 선택하여 구성하는 등 방법을 찾아 해결해야 한다.</p>\n</li>\n<li><p>WebSocket의 기본 프로토콜인 WS 는 통신이 암호화 되어있지 않기 때문에 SSL/TLS3 인증서를 발급 받은 뒤 이를 사용하여 WSS를 설정해야 한다.</p>\n</li>\n<li><p>그리고 알아둬야 할 것이 기존의 <code>Polling</code> 등의 방식 보다는 훨씬 덜하지만 WebSocket도 서버에 부담을 주는 것은 마찬가지이기 때문에 구현하고자 하는 서비스에 가장 적절한 선택을 하는 것이 중요하다.</p>\n</li>\n</ul>\n",
    "pubDate": "Wed, 31 Jul 2024 05:33:50 GMT",
    "thumbnail": null
  },
  {
    "title": "로드 밸런싱",
    "link": "https://velog.io/@gawgjiug/%EB%A1%9C%EB%93%9C-%EB%B0%B8%EB%9F%B0%EC%8B%B1",
    "description": "<h3 id=\"로드-밸런싱\">로드 밸런싱</h3>\n<h4 id=\"load-balancer\">Load Balancer</h4>\n<ul>\n<li><p>로드 밸런서란 일반적으로 서버의 부하를 분산 해주는 장치 또는 기술을 뜻한다.</p>\n</li>\n<li><p>보통은 서버 상단 네트워크에 위치하고 있으며, 서버 한대에 트래픽이 집중되지 않도록 트래픽을 관리하여 각 서버가 최적의 효율을 발휘할 수 있게 해주는 역할을 수행한다.</p>\n</li>\n</ul>\n<p><img src=\"https://github.com/user-attachments/assets/cc2ad198-adb0-4173-bccb-dc5e16c97e6e\" alt=\"image\"></p>\n<ul>\n<li><p>Client가 Sever에게 어떠한 <code>요청</code>을 하게되면 loadBalancer에서 해당 요청을 받아들여서 비교적 한가한 서버에게 트래픽을 분산하여 과부화를 방지하는 역할이다.</p>\n</li>\n<li><p>서버에 부하를 분산하는 것 뿐만 아니라 트래픽 자체도 분산하기 위해 사용되지만 요즘은 SLB(Server Load Balancing)이 주를 이루고 있다.</p>\n</li>\n</ul>\n<h4 id=\"load-balancer-기본기능\">Load Balancer 기본기능</h4>\n<h5 id=\"health-check\">Health Check</h5>\n<ul>\n<li>서버가 정상적으로 작동하는지 주기적으로 확인하는 기능을 말한다. 비정상적인 서버를 트래픽 분배 대상에서 제외시킴으로써 서비스의 가용성과 안정성을 높인다.</li>\n</ul>\n<p><strong>1-1 ICMP</strong></p>\n<ul>\n<li><p>VIP에 연결된 리얼 서버에 대해 ICMP(ping)로 헬스 체크를 수행하는 방법입니다. 단순히 서버가 살아 있는지 여부만 체크할 수 있으므로 자주 사용하지는 않는다.</p>\n</li>\n<li><p>서버의 생존 여부는 확인할 수 있지만, 애플리케이션 레벨의 상태는 알 수 없다.</p>\n</li>\n<li><p>애플리케이션 레벨에서 Health Check를 하기 위해선 데이터베이스 쿼리를 통해 데이터베이스 상태를 확인하거나, 애플리케이션 내부의 특정 모듈이 정상적으로 작동하는지\n확인하는 API End Point를 호출하는 방법이 있다.</p>\n</li>\n</ul>\n<p>이러한 방법을 사용하면 애플리케이션의 구체적인 상태를 점검할 수 있으며, 문제가 발생한 지점을 보다 정확히 파악할 수 있다.</p>\n<p><strong>1-2 TCP HandShake</strong></p>\n<ul>\n<li><p>가장 기본적인 헬스 체크 방법은 로드 밸런서에 설정된 서버의 서비스 포트를 확인하는 것이다.</p>\n</li>\n<li><p>데이터 베이스 서버나 특정 포트에서 서비스 중인 애플리케이션 서버의 가용성을 확인하는 데 사용되고, 포트가 열려 있는지, 서버가 수신 대기 상태인지를 빠르게 확인 할 수 있음</p>\n</li>\n</ul>\n<h5 id=\"health-check의-구성요소\">Health Check의 구성요소</h5>\n<ul>\n<li><p>주기 (Interval) : 헬스 체크를 수행하는 주기이다. 주기가 짧은 수록 서버 상태를 빨리 감지할 수 있지만, 서버에 대한 Overhead 증가할 수 있다.</p>\n</li>\n<li><p>타임아웃(Timeout) : 헬스 체크 요청에 대한 응답을 기다리는 최대 시간을 말한다. 타임아웃을 초과하면 해당 헬스 체크는 실패로 간주 된다.</p>\n</li>\n<li><p>재시도 횟수(Retry Attempts) : 서버가 일시적으로 응답하지 않을 경우를 대비하여, 헬스 체크를 재시도하는 횟수이다. 일반적으로는 여러 번 실패한 후에 서버를 비정상으로 간주한다.</p>\n</li>\n<li><p>임계값(Thresholds) : 서버를 비정상 또는 정상으로 간주하기 위한 헬스 체크 성공 및 실패 횟수 기준을 말한다. 예를 들어 3번 연속 실패시 server is 비정상...</p>\n</li>\n</ul>\n<h5 id=\"health-check의-중요성\">Health Check의 중요성</h5>\n<ul>\n<li><p>서버가 정상적으로 작동하는지 확인하기 때문에 안정적인 서비스를 제공하는 것에 기여할 수 있고,  서버의 장애를 신속하게 감지하고 문제를 해결할 수 있도록 도움을 준다.</p>\n</li>\n<li><p>HeathCheck 를 통해 자동화된 장애 복구 프로세스를 트리거하여 서버가 정상 상태로 돌아오면 자동으로 트래픽을 다시 분배한다.</p>\n</li>\n</ul>\n<h5 id=\"load-balancing-algorithm\">Load Balancing Algorithm</h5>\n<p><strong>1. Least Connection 알고리즘</strong></p>\n<ul>\n<li><p>한글로 풀어쓰면 <code>최소 연결</code> 알고리즘이다. 말 그대로 가장 적게 연결 되어 있는 서버에 세션을 할당해주는 방식을 말한다</p>\n</li>\n<li><p>서버에 분배된 세션들이 일정하지 않은 경우에 적합하며, 부하를 줄이는 측면에서 많이 사용된다.</p>\n</li>\n</ul>\n<p><strong>2.Round Robin 알고리즘</strong></p>\n<ul>\n<li><p>순차적으로 돌아가며 세션을 할당해주는 방식을 말한다. 요청이 오면 단순히 그 요청을 순서대로 서버에 분배해주는데, 첫 번째 요청은 미리 등록된 첫 번째 서버\n두번째 요청은 두 번째 서버에 할당해준다.</p>\n</li>\n<li><p>로드밸런싱 대상 서버의 스펙이 동일하고, 처리시간 혹은 세션지속시간이 짧은 애플리케이션의 경우 이러한 방식이 적합하다.</p>\n</li>\n</ul>\n<p><strong>3.Hash 알고리즘</strong></p>\n<ul>\n<li><p>특정 사용자는 특성 서버로만 할당시키는 방식을 말한다. 이외에도 특정한 기준을 잡아 특정 서버에 매핑하여 고정적으로 트래픽을 분산해주는 방식을 말한다.</p>\n</li>\n<li><p>일반적으로는 출발지 (Client)의 IP가 그 기준이 되고, 특정 IP주소나 포트를 갖는 사용자들은 특정 서버로만 세션을 맺도록 하여 특정 IP주소나 포트에서 접속량이 특히 많을 때 관리가 편한 방식이다.</p>\n</li>\n</ul>\n",
    "pubDate": "Tue, 30 Jul 2024 06:05:49 GMT",
    "thumbnail": null
  }
]