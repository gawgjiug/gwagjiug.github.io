[
  {
    "title": "가비지 컬렉션",
    "link": "https://velog.io/@gawgjiug/%EA%B0%80%EB%B9%84%EC%A7%80-%EC%BB%AC%EB%A0%89%EC%85%98",
    "description": "<h1 id=\"가비지-컬렉션\">가비지 컬렉션</h1>\n<p>자바스크립트에서 가비지 컬렉션은 사용하지 않는 메모리를 자동으로 회수하여 메모리 누수를 방지하는 기능을 말한다.</p>\n<p>자바스크립트는 개발자가 명시적으로 메모리를 할당하거나 해제하지 않는다. 필요하지 않게 된 객체를 자동으로 정리하는 방식으로 동작한다.</p>\n<p>이 과정을 가비지 컬렉터(Garbage Collector)가 수행한다.</p>\n<p>즉, 우리가 생성한 원시값, 객체, 함수 등 메모리를 차지 하는 모든 것들을 <code>쓸모가 없어지면</code> 찾아내 삭제하는 과정을 말한다.</p>\n<p>그러면 왜?? 굳이 삭제할까??</p>\n<blockquote>\n<p>가비지 컬렉터는 한정된 메모리 자원을 효율적으로 관리하기 위해 설계된 장치이다. 컴퓨터의 메모리는 유한하기 때문에 프로그램이 실행되면서 더 이상 필요하지 않은 데이터를 자동으로 정리하여 새로운 데이터의 공간을 확보하기 위함임</p>\n</blockquote>\n<p>그렇다면 그 <code>쓸모가 없어짐</code> 이라는 기준은 어떻게 생길까??</p>\n<h1 id=\"가비지-컬렉션-기준\">가비지 컬렉션 기준</h1>\n<p>자바스크립트는 도달 가능성(reachability) 이라는 개념을 사용해 메모리 관리를 수행한다. </p>\n<p>여기서 <code>도달 가능한</code> 값은 쉽게 말해 어떻게든 접근하거나 사용할 수 있는 값을 의미한다.\n그렇게 <code>도달 가능하다</code> 라고 판단 된 값은 메모리에서 삭제되지 않는다.</p>\n<ol>\n<li>아래의 소개되는 값들은 그 태생부터 <code>도달 가능</code> 하기 때문에 명백한 이유 없이는 삭제 되지 않는다.</li>\n</ol>\n<ul>\n<li>현재 함수의 지역 변수와 매개변수</li>\n</ul>\n<pre><code class=\"language-javascript\">function exampleFunction(param) {\n    // param은 매개변수\n    let localVar = &quot;지역 변수입니다.&quot;; // localVar는 지역 변수\n\n    console.log(param);  // 매개변수 참조 가능\n    console.log(localVar);  // 지역 변수 참조 가능\n}\n\nexampleFunction(&quot;매개변수 값&quot;);</code></pre>\n<blockquote>\n<p>즉 <strong>현재 실행 중인 함수의 지역 변수와 매개변수</strong> 는 함수가 실행되는 동안에는\n메모리에 남아 있고, 함수가 종료되면 더 이상 사용되지 않는 것으로 간주되어 가비지 컬렉터가 이를 처리할 수 있다. 그러나 함수가 실행 중인 동안에는 이 값들은 메모리에서 &quot;도달 가능&quot; 한 상태로 유지되어 삭제되지 않는다.</p>\n</blockquote>\n<hr>\n<ul>\n<li>중첩 함수의 체인에 있는 함수에서 사용되는 변수와 매개변수</li>\n</ul>\n<pre><code class=\"language-javascript\">function outerFunction(outerParam) {\n    let outerVar = &quot;외부 함수 변수&quot;;\n\n    function innerFunction(innerParam) {\n        let innerVar = &quot;내부 함수 변수&quot;;\n\n        // 외부 함수의 변수와 매개변수에 접근 가능\n        console.log(outerVar);  // &quot;외부 함수 변수&quot;\n        console.log(outerParam);  // 외부 함수의 매개변수 값 출력\n        console.log(innerVar);  // &quot;내부 함수 변수&quot;\n        console.log(innerParam);  // 내부 함수의 매개변수 값 출력\n    }\n\n    return innerFunction;\n}\n\nconst myFunction = outerFunction(&quot;외부 매개변수 값&quot;);\nmyFunction(&quot;내부 매개변수 값&quot;);</code></pre>\n<blockquote>\n<p>중첩 함수의 체인에 있는 함수에서 사용되는 변수와 매개변수 라는 문징은 <strong>중첩 함수</strong> 구조에서 내부 함수가 외부 함수의 변수와 매개변수에 접근 가능하다는 것을 의미한다.</p>\n</blockquote>\n<blockquote>\n<p>자바스크립트에서 함수는 렉시컬 스코프 규칙을 따르기 때문에, 내부 함수는 자신을 포함하는 외부 함수의 변수나 매개변수를 기억하고 사용할 수 있다.</p>\n</blockquote>\n<ul>\n<li><p>전역 변수</p>\n</li>\n<li><p>기타 루트(root) 값</p>\n</li>\n</ul>\n<ol start=\"2\">\n<li>루트가 참조하는 값이나 체이닝으로 루트에서 참조할 수 있는 값은 도달 가능한 값이 된다.</li>\n</ol>\n<p>전역 변수에 객체가 저장되어 있다고 가정해보자. 이 객체의 프로퍼티가 또 다른 객체를 참조하고 있다면, 프로퍼티가 참조하는 객체는 <code>도달 가능한 값</code> 이 된다. </p>\n<h3 id=\"예제\">예제</h3>\n<pre><code class=\"language-javascript\">let user ={\n    name : &#39;John&quot;\n}</code></pre>\n<p>이 코드에서 전역 변수 &quot;user&quot;는 <code>{name : John}</code> 이라는 객체를 참조한다. 이러한 상태를 <code>도달 가능한 상태</code> 라고한다.</p>\n<pre><code class=\"language-javascript\">user = null;</code></pre>\n<p>이제 <code>user</code> 더 이상 객체를 참조하지 않게 되고 결과적으로는 <code>{name : John}</code> 객체는 도달할 수 없는 상태가 되면서 가비지 컬렉터가 이를 인식하고 메모리에서 삭제 시킨다.</p>\n<hr>\n<h3 id=\"참조-두개-예제\">참조 두개 예제</h3>\n<p>그렇다면 한 객체를 여러 변수에서 참조하는 경우를 보자</p>\n<pre><code class=\"language-javascript\">let user = {\n    name: &quot;John&quot;\n};\n\nlet admin = user;  // user를 admin으로 복사</code></pre>\n<p>이제 user와 admin 두 변수가 같은 객체를 참조하고 있다. <code>user</code> 를 <code>null</code>로 설정해도, <code>admin</code> 이 여전히 <code>{name : John}</code> 객체를 참조하므로, 객체는 <code>도달 가능한 상태</code> 로 인식된다.</p>\n<p>이런 경우에는 두 전역변수의 참조를 모두 삭제해야 <code>{name : John}</code> 객체를 <code>도달 불가능</code> 상태로 만들 수 있다.</p>\n<pre><code class=\"language-javascript\">user = null;  // user의 참조를 삭제\nadmin = null; // admin의 참조를 삭제</code></pre>\n<h3 id=\"연결된-객체\">연결된 객체</h3>\n<p>더 복잡한 구조에서 객체들이 서로를 참조하는 경우를 보자 예를 들어 두 객체가 서로를 참조하는 관계를 생각해보자.</p>\n<pre><code class=\"language-javascript\">function marry(man, woman) {\n    woman.husband = man;\n    man.wife = woman;\n    return {\n        father: man,\n        mother: woman\n    };\n}\n\nlet family = marry({\n    name: &quot;John&quot;\n}, {\n    name: &quot;Ann&quot;\n});\n</code></pre>\n<p>이 예제 코드에서 <code>family</code> 객체는 <code>man</code> 과 <code>woman</code> 객체를 참조하고 있다. 그리고 또 <code>man</code>은 <code>woman</code> 을 <code>woman</code> 은 <code>man</code> 을 참조한다. </p>\n<p>즉 현재 모든 객체는 <code>도달 가능한</code> 상태이다.</p>\n<p><img src=\"https://velog.velcdn.com/images/gawgjiug/post/38060711-c411-4aa2-8443-21ba81def1ee/image.png\" alt=\"\"></p>\n<pre><code class=\"language-javascript\">delete family.father;\ndelete family.mother.husband;</code></pre>\n<p><img src=\"https://velog.velcdn.com/images/gawgjiug/post/e0dd5fe1-ed23-4ae4-b0bd-d5e99eb21998/image.png\" alt=\"\"></p>\n<p>삭제한 두 개의 참조 중 하나만 지웠다면, 모든 객체는 여전히 <code>도달 가능한</code> 상태였겠지만, 참조 두개를 지우게 되면 John 으로 들어갈 수 있는 참조는 모두 사라져 John은 <code>도달 가능한</code> 상태에서 벗어나게 된다.</p>\n<p>왜냐하면 외부로 나가는 참조 <code>wife</code>는 <code>도달 가능성</code> 에 영향을 주지 못하기 때문이다. 모든 객체는 외부에서 자신에게 들어오는 참조만이 <code>도달 가능성</code> 에 영향을 준다.</p>\n<p>위 사진의 결과로 John은 이제 도달 가능한 상태가 아니기 때문에 메모리에서 제거된다.</p>\n<p><strong>가비지 컬렉션 후 메모리 구조</strong></p>\n<p><img src=\"https://velog.velcdn.com/images/gawgjiug/post/9f84a5c1-2b35-4b34-b6e7-399aee4691a0/image.png\" alt=\"\"></p>\n<blockquote>\n<p>루트 객체는 자바스크립트 엔진에서 기본적으로 접근할 수 있는 최상위 참조 가능한 객체를 말한다 브라우저 환경에서는 <code>window</code> Node.js 환경에서는 <code>global</code> 객체를 말한다.</p>\n</blockquote>\n<blockquote>\n<p>전역 변수는 <strong>스크립트 전체에서 접근할 수 있는 변수</strong> 를 말한다. 즉, 전역 스코프에서 선언된 변수로 어디서든지 접근할 수 있는 것을 말한다.</p>\n</blockquote>\n<h3 id=\"도달할-수-없는-섬\">도달할 수 없는 섬</h3>\n<p>위 사진들 처럼 객체들은 연결되어 마치 하나의 독립 된 섬 같은 구조를 만든다. 그리고 이 섬에 도달할 방법이 없는 경우, <code>들어오는 참조가 없는 경우</code> 섬을 구성하는 객체 전부가 메모리에서 삭제되는 것이다.</p>\n<p>위 객체에서 <code>루트 객체</code> <code>family</code> 객체이다 정확하게 얘기하면 <strong>루트 객체의 속성에 해당하는 전역 변수로 선언된 것</strong> 즉, <code>family</code>는 <strong>전역 변수</strong>로 선언되어 있기 때문에 <code>window</code> 객체의 속성으로 간주된다.</p>\n<pre><code class=\"language-javascript\">family = null;</code></pre>\n<p>이렇게 루트 객체인 <code>family</code> 가 아무것도 참조하지 않도록 하였다. </p>\n<p><img src=\"https://velog.velcdn.com/images/gawgjiug/post/3ba6e34a-769e-4085-b07c-d7051a99f52f/image.png\" alt=\"\"></p>\n<p>그렇다면 메모리 구조는 다음과 같을 것이다.</p>\n<p>이 사진을 보면 가비지 컬렉션에서 <code>도달할 수 없는 섬</code> 예제는 <code>도달 가능성</code> 이라는 개념이 얼마나 중요한지 보여준다.</p>\n<p>John 과 Ann은 여전히 서로를 참조하고 있고, 두 객체 모두 외부에서 들어오는 참조를 갖고 있지만.</p>\n<p>앞서 말했 던 가비지 컬렉션의 기준인 <code>기타 루트(root) 값</code> 과 <code>루트가 참조하는 값이나 체이닝으로 루트에서 참조할 수 있는 값</code> 이라는 기준에 미치지 못하기 때문에 섬(객체) 전체가 도달할 수 없는 사태가 되고, 섬을 구성하는 객체 전부가 메모리에서 제거 되는 것이다.</p>\n<hr>\n<h2 id=\"요약\">요약</h2>\n<ul>\n<li><p><code>도달 가능한 객체</code> 는 메모리에서 삭제되지 않으며, 프로그램이 실행되는 동안 참조가 유지된다.</p>\n</li>\n<li><p><code>참조 삭제</code> 는 객체가 더 이상 도달할 수 없는 상태가 되도록 만든다.</p>\n</li>\n<li><p><code>객체 간의 참조</code> 는 복잡한 구조를 만들 수 있고, 이들 객체가 외부에서 참조되지 않으면 메모리에서 제거된다.</p>\n</li>\n</ul>\n<p><a href=\"https://ko.javascript.info/garbage-collection#ref-712\">출처: 모던 javascript 튜토리얼</a></p>\n",
    "pubDate": "Wed, 11 Sep 2024 06:22:36 GMT",
    "thumbnail": null
  },
  {
    "title": "JS What is Prototype?",
    "link": "https://velog.io/@gawgjiug/JS-What-is-Prototype",
    "description": "<h3 id=\"프로토타입-객체\">프로토타입 객체</h3>\n<p>Java C++ 과 같은 클래스 기반 객체지향 프로그래밍 언어와 달리 자바스크립트는 프로토타입 기반 객체지향 프로그래밍 언어이다. 따라서 자바스크립트의 동작 원리를 이해하기 위해서는 프로토타입의 개념을 잘 이해하고 있어야 한다.</p>\n<p>클래스 기반 객체지향 프로그래밍 언어는 객체 생성 이전에 클래스를 정의하고 이를 통해 객체를 생성한다.</p>\n<p>하지만 프로토타입 기반 객체지향 프로그래밍 언어는 클래스 없이(Class-less)도 객체를 생성할 수 있다.</p>\n<p><strong>그래서 프로토타입이란?</strong> 자바스크립트에서 프로토타입이란 객체 지향 프로그래밍에서 상속 기능을 구현하는 방식 중 하나이다. 쉽게 말해, 객체의 부모 역할을 하는 다른 객체를 가리키는 링크라고 생각할 수 있다.</p>\n<p>이 프로토타입을 통해 객체들은 다른 객체로부터 속성이나 메서드를 상속받아 사용할 수 있다.</p>\n<p>객체를 생성할 때 자바스크립트는 해당 객체의 프로토타입을 자동으로 설정한다.</p>\n<pre><code class=\"language-javascript\">function parents() {\n  this.a = &#39;A&#39;;\n  this.b = &#39;B&#39;;\n}\n\nconsole.log(parents.prototype);\nconsole.log(parents);</code></pre>\n<p><img src=\"https://velog.velcdn.com/images/gawgjiug/post/8f7c6812-67c9-4212-9a8d-03db260e703e/image.png\" alt=\"\"></p>\n<p>위 사진을 보면 코드상에서 <code>parents</code> 객체에 prototype 이라는 속성을 선언한 적도 없는데 자동으로 prototype 이라는 객체를 가지고 있는 것을 볼 수 있다.</p>\n<p>이를 통해 자바스크립트의 모든 객체는 자신의 부모 역할을 하는 담당 객체인 <code>Prototype</code> 객체와 연결되어있고, </p>\n<p>객체를 선언함과 동시에 <code>Parents.prototype</code> 이라는 빈 Object 가 어딘가에 존재하고, Parents 함수로부터 생성 된 모든 자식 객체들은 언제든지 어딘가에 존재하는 <code>Parents.prototype</code> 에 들어있는 값들 모두 가져다 사용할 수 있다.</p>\n<p>예를 들어, 자바스크립트의 모든 배열은 Array.prototype 이라는 기본 프로토타입을 가지며, 이 프로토타입에는 배열 객체가 사용할 수 있는 다양한 메서드 <code>sort, push, pop</code> 가 정의되어 있다.</p>\n<pre><code class=\"language-javascript\">const arr = new Array(4, 2, 1, 10);\n//Array 객체의 자식인 arr 생성한 것과 마찬가지\n\narr.sort(); \n//arr.sort 메서드를 정의한적도 없는데 사용할 수 있는 이유?\n//부모 객체인 Array의 유전자인 prototype 객체에 정의되어 있기 때문에 자식인 arr도 사용할 수 있는 것.\n</code></pre>\n<p><img src=\"https://velog.velcdn.com/images/gawgjiug/post/d64ff1cc-bb5b-4b41-b832-ad21d71888e0/image.png\" alt=\"\"></p>\n<h3 id=\"프로토타입-체인\">프로토타입 체인</h3>\n<p>프로토타입 체인이란 자바스크립트에서 객체가 속성이나 메서드를 찾을 때 사용하는 검색 메커니즘이다. 객체에 해당 속성이나 메서드가 없으면 자바스크립트는 자동으로 프로토타입 체인을 따라가며, 부모 객체의 프로토타입을 검색한다. 이 체인을 따라 올라가면서 속성이나 메서드를 찾게되면 그 값을 반환하고, 최종적으로 찾지 못하면 <code>undefined</code> 를 반환한다.</p>\n<pre><code class=\"language-javascript\">function parents() {\n  this.a = &#39;A&#39;;\n  this.b = &#39;B&#39;;\n}\n\nparents.prototype.name = &#39;gwag&#39;;\n\nconst child = new parents();\n\nconsole.log(child.name);</code></pre>\n<p><img src=\"https://velog.velcdn.com/images/gawgjiug/post/915a456b-cc27-43d1-a9ee-0209362dd980/image.png\" alt=\"\"></p>\n<p>위 사진을 보면 코드상으로 child 객체에 사용자는 name 이라는 속성을 정의한 적이 없는데, name을 사용할 수 있는 것을 볼 수 있다.</p>\n<p>이 경우가 프로토타입 체인과 연관되어있는 것인데. JS는 내부적으로 해당 코드를 우선적으로 child 객체가 name이라는 데이터를 가지고 있는지 확인하고, 없다면 childe의 부모의 <code>유전자(prototype)</code> 을 검색하고 없다면 계속해서 부모의 부모를 찾는 방식으로 데이터를 검색하게 된다.</p>\n<p>이런식으로 Object의 속성이나 메서드를 찾을 때 사용하는 <code>메커니즘</code> 자체를 우리는 <code>Prototype Chain</code> 이라고 한다.</p>\n<p>이러한 개념을 이해하면 이어질 <code>프로토타입을 이용한 상속</code> 에 관련 된 개념도 쉽게 이해할 수 있다.</p>\n<h3 id=\"그렇다면-이러한-메커니즘을-가능하게-해주는-것은-무엇일까\">그렇다면 이러한 메커니즘을 가능하게 해주는 것은 무엇일까?</h3>\n<p><img src=\"https://velog.velcdn.com/images/gawgjiug/post/11d6266f-e793-4375-bbd9-bc6de5051668/image.png\" alt=\"\"></p>\n<p>위 사진을 보게되면 우리가 함수를 정의하면, 함수만 생성되는 것이 아니라 자동으로 Prototype Object도 같이 생성이 된다고 앞서서 얘기했었는데, </p>\n<p>이렇게 생성 된 함수는 prototype 이라는 속성을 통해 Prototype Object 에 접근할 수 있게 된다. </p>\n<p>그리고 이러한 Prototype Object 는 앞서 말한 <code>프로토타입 체인</code> 메커니즘을 가능하게 만드는 <code>__proto__</code> 라는 속성을 기본으로 가지게 된다.</p>\n<p>여기서 <code>__proto__</code>  은 Prototype Link 라고도 불리는데, <code>__proto__</code>  속성은 모든 객체가 빠짐없이 가지고 있는 속성을 얘기하고, <code>__proto__</code>  는 객체가 생성될 때 조상이었던 함수의 Prototype Object를 가리키게 된다.</p>\n<p>그래서 우리가 위의 예제들 처럼 자식 객체들이 부모객체가 가지고 있는 유전자 즉, Prototype Object 안에 정의되어있는 모든 속성과 함수들을 사용할 수 있는 것이다.</p>\n<p><img src=\"https://velog.velcdn.com/images/gawgjiug/post/e0fdef04-bccd-4814-903d-b031f30a05dd/image.png\" alt=\"\"></p>\n<pre><code class=\"language-javascript\">function parents() {\n  this.a = &#39;A&#39;;\n  this.b = &#39;B&#39;;\n}\n\nconst child = new parents();\n\nconsole.log(child.__proto__);</code></pre>\n<p><img src=\"https://velog.velcdn.com/images/gawgjiug/post/8ef8044a-2157-4c1d-b473-dfa42b1bdc29/image.png\" alt=\"\"></p>\n<p>그리고 추가적으로 <code>__proto__</code> 와 <code>prototype</code> 의 차이점에 대해 헷갈려하는 분들이 많은데, <code>prototype</code>은 생성자 함수의 속성이고 <code>__proto__</code> 는 객체 인스턴스의 속성이라는 점을 알고 있으면 프로토타입을 이해하는 데에 있어서 혼동을 겪지 않을 것이다.</p>\n<pre><code class=\"language-javascript\">\nfunction Person() {\n  this.name = &#39;John&#39;;\n}\n\nPerson.prototype.greet = function() {\n  console.log(&#39;Hello, &#39; + this.name);\n};\n\nconst person1 = new Person();\n\nconsole.log(person1.__proto__ === Person.prototype); // true</code></pre>\n<p>위 예제에서 person1 객체는 Person 함수로 생성된 것이며, person1.<strong>proto</strong>는 Person.prototype을 가리킵니다. 따라서 person1은 Person.prototype에 정의된 greet 메서드를 사용할 수 있습니다</p>\n<h3 id=\"요약\">요약</h3>\n<ul>\n<li>함수는 Prototype Object를 자동으로 생성합니다.</li>\n<li>이 Prototype Object는 <strong>prototype</strong>이라는 속성으로 함수와 연결되어 있습니다.</li>\n<li>객체 인스턴스는 생성자 함수의 <strong>prototype</strong>을 <strong>proto</strong> 속성을 통해 참조합니다.</li>\n</ul>\n<p>이 메커니즘을 통해 자바스크립트의 객체는 상속과 메서드 공유를 가능하게 합니다. prototype은 생성자 함수와 연결된 속성이고, <strong>proto</strong>는 생성된 객체가 부모 객체를 참조하는 링크 역할을 한다</p>\n",
    "pubDate": "Tue, 03 Sep 2024 05:39:02 GMT",
    "thumbnail": null
  },
  {
    "title": "JavaScript 비동기 프로그래밍 pt2 (async ,await, Promise , try-catch ,fetch",
    "link": "https://velog.io/@gawgjiug/JavaScript-%EB%B9%84%EB%8F%99%EA%B8%B0-%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8D-pt2-async-await-Promise-try-catch",
    "description": "<p>앞서 비동기 프로그래밍 pt 1에서 다뤘듯이 JS는 기본적으로 싱글 스레드 언어로, 한 번에 한 가지 작업만 처리할 수 있다.</p>\n<p><a href=\"https://velog.io/@gawgjiug/JS-%EB%B9%84%EB%8F%99%EA%B8%B0-%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB\">비동기 프로그래밍 pt1</a></p>\n<ul>\n<li>하지만 본문에서 다룰 네트워크 요청 같은 경우는 작업 시간이 오래 걸릴 수 있기 때문에 작업을 처리할 때 비동기 프로그래밍이 필요하다</li>\n</ul>\n<h3 id=\"1-promise\">1. Promise</h3>\n<p><code>Promise</code> 는 자바스크립트에서 비동기 작업의 결과를 나타내는 객체이다 <code>Promise</code> 는 네 가지 상태를 가질 수 있는데, </p>\n<ul>\n<li><p>Pending (대기 중) : 초기 상태, 아직 작업이 완료되지 않음.</p>\n</li>\n<li><p>Fulfilled(이행 됨) : 작업이 성공적으로 완료 됨.</p>\n</li>\n<li><p>Rejected(거부됨) : 작업이 실패함.</p>\n</li>\n<li><p>Settled(해결됨) : 작업이 완료된 상태 (성공 또는 실패)</p>\n</li>\n</ul>\n<p>이렇듯 Promise 는 주로 비동기 작업의 성공 또는 실패 결과를 처리할 때 사용된다.</p>\n<pre><code class=\"language-javascript\">\nconst fetchData = () =&gt; {\n  return new Promise((resolve, reject) =&gt; {\n    setTimeout(() =&gt; {\n      const success = true; // 성공했다고 가정\n      if (success) {\n        resolve(&quot;데이터를 성공적으로 가져왔습니다.&quot;);\n      } else {\n        reject(&quot;데이터를 가져오는 데 실패했습니다.&quot;);\n      }\n    }, 2000);\n  });\n};\n\nfetchData()\n  .then((result) =&gt; {\n    console.log(result); // 데이터 성공 메시지\n  })\n  .catch((error) =&gt; {\n    console.error(error); // 에러 메시지\n  });</code></pre>\n<ul>\n<li><p>위의 예제에서 <code>fetchData</code> 함수는 2초 후에 데이터를 성공적으로 가져왔음을 알리는 <code>resolve</code> 를 호출한다 <code>then</code> 블록에서 성공 메시지를 받고 <code>catch</code>  오류를 처리한다.</p>\n</li>\n<li><p>이처럼 then과 catch를 연달아 사용하는 것을 promise 체이닝이라고 표현함 Promise를 사용하지 않았다면 콜백지옥을 맛봤을 것</p>\n</li>\n</ul>\n<h3 id=\"2-async-와-await\">2. async 와 await</h3>\n<ul>\n<li><p><code>async</code> 와 <code>await</code> 는 JS에서 비동기 작업을 좀 더 간편하게 작성할 수 있게 해주는 문법을 말한다.</p>\n</li>\n<li><p><code>async</code> 키워는 함수 앞에 붙여서 그 함수가 항상 <code>Promise</code> 를 반환하도록 만든다. 함수 내부에서 명시적으로 <code>Promise</code>를 반환하지 않더라도 <code>async</code> 가 붙은 함수는 자동으로 Promise로 래핑된다.</p>\n</li>\n</ul>\n<pre><code class=\"language-javascript\">const fetchDataAsync = async () =&gt; {\n  try {\n    const response = await fetchData(); // fetchData()가 완료될 때까지 대기\n    console.log(response); // 성공 메시지\n  } catch (error) {\n    console.error(error); // 에러 메시지\n  }\n};\n\nfetchDataAsync();</code></pre>\n<ul>\n<li><p>await은 <code>async</code> 함수 내에서만 사용할 수 있는 키워드이다. <code>await</code> 키워드는 <code>Promise</code> 가 이행되거나 거부될 때 까지 함수를 일시 정지 시키고, 결과를 반환할 때 가지 기다린다.</p>\n</li>\n<li><p>await은 비동기 작업이 완료될 때까지 기다린 후 결과를 사용할 수 있게 해주어서 코드가 마치 동기적으로 실행되는 것처럼 보이게 하고 비동기 함수에 안정성을 높여준다.</p>\n</li>\n</ul>\n<pre><code class=\"language-javascript\">async function fetchData() {\n  const result = await fetch(&#39;https://api.example.com/data&#39;);\n  return result.json();\n}\n</code></pre>\n<ul>\n<li><p>여기서 <code>fetch</code> 는 웹 API 중 하나로 네트워크를 통해 리소스를 가져오거나 서버와의 HTTP 요청을 보내는 데 사용되는 JS 함수이다. 주로 AJAX 요청을 대체하거나 비동기적으로 데이터를 가져오기 위해 사용된다.</p>\n</li>\n<li><p>기본적으로 fetch 함수를 사용하면 Promise 객체가 반환되며, 이 객체는 네트워크 요청이 완료될 때 까지 대기한다. fetch 가 반환하는 <code>Promise</code> 는 두 개의 후속 메서드를 가질 수 있다. \n<code>then</code> 과 <code>catch</code> 이다.</p>\n</li>\n<li><p>성공적인 요청은 .then() 블록으로 처리되고, 실패한 요청은 .catch() 블록에서 처리된다.</p>\n</li>\n</ul>\n<pre><code class=\"language-javascript\">fetch(url)\n  .then(response =&gt; {\n    if (!response.ok) {\n      throw new Error(&#39;네트워크 응답이 올바르지 않습니다.&#39;);\n    }\n    return response.json(); // JSON 형식의 응답 데이터를 파싱\n  })\n  .then(data =&gt; {\n    console.log(data); // 파싱된 데이터를 처리\n  })\n  .catch(error =&gt; {\n    console.error(&#39;Fetch 오류:&#39;, error); // 오류 처리\n  });</code></pre>\n<ul>\n<li><p>여기서 Promise는 네트워크 요청이 <code>성공적</code> 으로 완료된 경우에만 resolve 된다. </p>\n</li>\n<li><p>하지만 여기서 <code>성공적</code>이라는 의미는 네트워크 요청이 서버와의 연결이 제대로 이루어졌음을 의미할 뿐 HTTP 상태 코드가 200번대 인지 여부를 보장하지는 않는다.</p>\n</li>\n<li><p>예를 들어, 서버가 404 또는 500 상태코드를 반환해도 <code>fetch</code>는 여전히 Promise를 resolve 한다는 점을 기억하면 좋다.</p>\n</li>\n<li><p>그리고 여기서 .ok 의 의미는 HTTP 상태 코드가 200번대 (200~299) 의 값일 경우 true를 반환 하는 것을 말한다. 이를 통해 응답이 HTTP 레벨에서 실제로 성공적인지 확인할 수 있다.</p>\n</li>\n</ul>\n",
    "pubDate": "Mon, 02 Sep 2024 13:33:30 GMT",
    "thumbnail": null
  },
  {
    "title": "React 날씨 정보 API 호출 ",
    "link": "https://velog.io/@gawgjiug/React-%EB%82%A0%EC%94%A8-%EC%A0%95%EB%B3%B4-API-%ED%98%B8%EC%B6%9C",
    "description": "<p>첫번째로 사이트에서 <code>APIKEY</code>를 가져와야 한다.</p>\n<blockquote>\n<p><a href=\"https://openweathermap.org\">https://openweathermap.org</a></p>\n</blockquote>\n<p>위의 링크를 타고 들어가서 회원가입을 한 후에 자기 닉네임 -&gt; my API Keys 에 들어가서 API 키를 가져오면 된다.</p>\n<h3 id=\"1-위치-정보-가져오기\">1. 위치 정보 가져오기</h3>\n<ul>\n<li><p>우선 사용자의 현재 위치를 가져오기 위해<code>navigator.geolacation.getCurrentPosition</code> 메서드를 사용한다. </p>\n</li>\n<li><p>이 메서드는 사용자의 위치 정보를 가져와 lat(위도), lon(경도) 값을 <code>location</code> 상태에 저장한다. 이때 위치 정보 가져오기에 실패할 경우 오류 메시지를 설정한다</p>\n</li>\n</ul>\n<pre><code class=\"language-javascript\">useEffect(() =&gt; {\n  const getLocation = () =&gt; {\n    if (!navigator.geolocation) {\n      setError(&#39;Geolocation is not supported by your browser&#39;);\n      return;\n    }\n\n    navigator.geolocation.getCurrentPosition(\n      (position) =&gt; {\n        setLocation({\n          lat: position.coords.latitude,\n          lon: position.coords.longitude,\n        });\n      },\n      () =&gt; {\n        setError(&#39;Unable to retrieve your location&#39;);\n      }\n    );\n  };\n\n  getLocation();\n}, []);</code></pre>\n<h4 id=\"2-날씨-및-공기질-데이터-가져오기\">2. 날씨 및 공기질 데이터 가져오기</h4>\n<ul>\n<li><p>위치 정보가 설정되면, OpenWeatherMap API 호출하여 현재 날씨, 공기질, 3일간의 에보 데이터를 가져온다. </p>\n</li>\n<li><p>데이터를 가져오기 위해 <code>fetch</code> API를 사용하며, 비동기적으로 모든 API 호출이 완료될 때 까지 기다리기 위해 <code>Promise.all</code>을 사용한다.</p>\n</li>\n</ul>\n<pre><code class=\"language-javascript\">useEffect(() =&gt; {\n  const fetchData = async () =&gt; {\n    if (!location) return;\n\n    try {\n      const { lat, lon } = location;\n      const weatherUrl = `https://api.openweathermap.org/data/2.5/weather?lat=${lat}&amp;lon=${lon}&amp;appid=${apiKey}&amp;units=metric`;\n      const airQualityUrl = `https://api.openweathermap.org/data/2.5/air_pollution?lat=${lat}&amp;lon=${lon}&amp;appid=${apiKey}`;\n      const forecastUrl = `https://api.openweathermap.org/data/2.5/forecast?lat=${lat}&amp;lon=${lon}&amp;appid=${apiKey}&amp;units=metric`;\n\n      const [weatherResponse, airQualityResponse, forecastResponse] =\n        await Promise.all([\n          fetch(weatherUrl),\n          fetch(airQualityUrl),\n          fetch(forecastUrl),\n        ]);\n\n      if (\n        !weatherResponse.ok ||\n        !airQualityResponse.ok ||\n        !forecastResponse.ok\n      ) {\n        throw new Error(&#39;Failed to fetch weather or air quality data&#39;);\n      }\n\n      const weatherData = await weatherResponse.json();\n      const airQualityData = await airQualityResponse.json();\n      const forecastData = await forecastResponse.json();\n\n      setWeatherData(weatherData);\n      setAirQualityData(airQualityData);\n      setForecastData(forecastData);\n      setLoading(false);\n    } catch (err) {\n      setError(err.message);\n      setLoading(false);\n    }\n  };\n\n  fetchData();\n}, [location, apiKey]);\n</code></pre>\n<ul>\n<li><p>이 useEffect 훅은 location과 apikey가 변경될 때 마다 실행되며, fetch 함수를 이용해서 네트워크 요청을 만들어서 데이터를 가져오는 데 사용된다.</p>\n</li>\n<li><p>주로 RESTful API 서버와 통신하여 데이터를 가져오거나 전송하는 데 사용된다.</p>\n</li>\n<li><p>async 는 함수 앞에 붙여서 해당 함수가 비동기 작업을 수행함을 나타낸다. </p>\n</li>\n<li><p><code>async</code> 함수는 항상 Promise를 반환하며 비동기 작업이 완료되면 resolve 상태의 Promise를 반환하며 오류가 발생하면 rejected 상태의 Promise를 반환한다.</p>\n</li>\n<li><p>Promise.all 을 사용해서 세 가지 데이터를 병렬로 가져온다. 병렬로 요청을 보내기 때문에, 순차적으로 요청하는 것보다 더 빠르게 데이터를 가져올 수 있다.</p>\n</li>\n</ul>\n<h3 id=\"3-json-데이터-파싱\">3. Json 데이터 파싱</h3>\n<pre><code class=\"language-javascript\">\nconst weatherData = await weatherResponse.json();\nconst airQualityData = await airQualityResponse.json();\nconst forecastData = await forecastResponse.json();\n</code></pre>\n<ul>\n<li><code>fetch</code> 요청으로부터 받은 응답은 JSON 으로 파싱한다. 이 과정도 비동기이기 때문에 await 키워드를 사용하여 처리한다.</li>\n</ul>\n<p><img src=\"https://velog.velcdn.com/images/gawgjiug/post/5b6a0abc-2333-4760-b031-706486ef990b/image.png\" alt=\"\"></p>\n",
    "pubDate": "Mon, 02 Sep 2024 12:18:46 GMT",
    "thumbnail": null
  },
  {
    "title": "useReducer",
    "link": "https://velog.io/@gawgjiug/useReducer",
    "description": "<ul>\n<li><p>useReducer()는 useState()와 같은 상태 관리, 상태 업데이트 훅이다.</p>\n</li>\n<li><p>변경할 값이 많을 때, 즉 상태 관리할 데이터가 많아질 때 주로 많이 사용한다.</p>\n</li>\n<li><p>좀 더 구조화된 방식으로 상태를 관리하고 싶을 때 사용할 수 있다.</p>\n</li>\n<li><p>const [state,dispatch] = useReducer(reducer,initialState);</p>\n</li>\n<li><p>state : 상태이름</p>\n</li>\n<li><p>dispatch : 상태를 변경할 때 필요한 정보를 전달하는 &#39;함수&#39;(주문서)</p>\n</li>\n<li><p>reducer : dispatch를 확인해서 state를 변경해주는 &#39;함수&#39;</p>\n</li>\n<li><p>initialState : state에 전달할 초기 값</p>\n</li>\n</ul>\n<h4 id=\"서론\">서론</h4>\n<ul>\n<li>리액트에서 상태 관리(업데이트)를 다루는 훅은 2가지 종류가 있다.</li>\n</ul>\n<p>1.useState()</p>\n<p>2.useReducer()</p>\n<ul>\n<li>useReducer는 클래스 컴포넌트에서 setState와 메서드와 유사한 역할을 하지만 좀 더 구조화된 방식으로 상태를 관리할 수 있도록 도와준다.</li>\n</ul>\n<h4 id=\"선언\">선언</h4>\n<pre><code class=\"language-javascript\">const [todos, dispatch] = useReducer(reducer, mockData);\n</code></pre>\n<ul>\n<li>todos state의 useReducer를 선언하였다. 초기 값으로 mockData를 넣어주었다.</li>\n</ul>\n<hr>\n<pre><code class=\"language-javascript\">function reducer(state, action) {\n  switch (action.type) {\n    case &#39;CREATE&#39;:\n      return [action.data, ...state];\n    case &#39;UPDATE&#39;:\n      return state.map((item) =&gt;\n        item.id === action.targetId ? { ...item, isDone: !item.isDone } : item\n      );\n    case &#39;DELETE&#39;:\n      return state.filter((item) =&gt; item.id !== action.targetId);\n    default:\n      return state;\n  }\n}</code></pre>\n<ul>\n<li><p>위는 내가 작성한 Todo App의 reducer 함수 정의 부분이다</p>\n</li>\n<li><p>reducer 함수는 두 개의 인수를 받는다. <code>state</code> (현재 상태) 와 <code>action</code> 액션 객체</p>\n</li>\n<li><p><code>action.type</code> 에 따라 다른 상태 변경 로직을 실행한다.</p>\n</li>\n<li><p>예를 들면 CREATE 는 새 할일을 상태(state)에 추가하는 부분인데. action.type 이 CREATE로 들어오게 되면, 새로운 할 일을 기존의 state 배열 앞에 추가하고 새로운 배열을 반환한다.</p>\n</li>\n</ul>\n<hr>\n<p>그리고 onCreate 함수는 이렇게 작성하였다.</p>\n<pre><code class=\"language-javascript\">const onCreate = (content) =&gt; {\n  dispatch({\n    type: &#39;CREATE&#39;,\n    data: {\n      id: idRef.current++,\n      isDone: false,\n      content: content,\n      date: new Date().getTime(),\n    },\n  });\n};</code></pre>\n<p>새 할 일을 나타내는 객체를 생성하고 <code>CREATE</code> 액션과 함께 dispatch를 호출한다. dispatch 함수에 이렇게 타입과 data를 객체 형태로 선언할 수 있다.</p>\n<ul>\n<li>이때 dispatch에 전달되는 객체는 액션 객체로, type 속성과 데이터(data)를 포함하고 있습니다.</li>\n</ul>\n<hr>\n<h4 id=\"usereducer를-사용하는-이유\">useReducer를 사용하는 이유</h4>\n<ol>\n<li><strong>useReducer를 사용한 코드 예시</strong></li>\n</ol>\n<pre><code class=\"language-javascript\">import { useReducer } from &#39;react&#39;;\n\nconst mockData = [\n  { id: 0, isDone: false, content: &#39;React 공부하기&#39;, date: new Date().getTime() },\n  { id: 1, isDone: false, content: &#39;빨래&#39;, date: new Date().getTime() },\n  { id: 2, isDone: false, content: &#39;운동&#39;, date: new Date().getTime() },\n];\n\nfunction reducer(state, action) {\n  switch (action.type) {\n    case &#39;CREATE&#39;:\n      return [action.data, ...state];\n    case &#39;UPDATE&#39;:\n      return state.map((item) =&gt;\n        item.id === action.targetId ? { ...item, isDone: !item.isDone } : item\n      );\n    case &#39;DELETE&#39;:\n      return state.filter((item) =&gt; item.id !== action.targetId);\n    default:\n      return state;\n  }\n}\n\nfunction App() {\n  const [todos, dispatch] = useReducer(reducer, mockData);\n\n  const onCreate = (content) =&gt; {\n    dispatch({\n      type: &#39;CREATE&#39;,\n      data: {\n        id: Date.now(),\n        isDone: false,\n        content: content,\n        date: new Date().getTime(),\n      },\n    });\n  };\n\n  const onUpdate = (targetId) =&gt; {\n    dispatch({ type: &#39;UPDATE&#39;, targetId });\n  };\n\n  const onDelete = (targetId) =&gt; {\n    dispatch({ type: &#39;DELETE&#39;, targetId });\n  };\n\n  return (\n    &lt;div&gt;\n      {/* UI Components here */}\n    &lt;/div&gt;\n  );\n}</code></pre>\n<ul>\n<li>위 코드에서 <code>useReducer</code>를 사용함으로써 상태 관리 로직이 <code>reducer</code> 함수 하나에 집약되어 있으며, 상태 업데이트가 모두 dispatch 함수를 통해 일관되게 이루어진다는 것을 알 수 있다.</li>\n</ul>\n<p><strong>2. useReducer를 사용하지 않고 useState만 사용한다면?</strong></p>\n<pre><code class=\"language-javascript\">import { useState, useRef } from &#39;react&#39;;\n\nconst mockData = [\n  { id: 0, isDone: false, content: &#39;React 공부하기&#39;, date: new Date().getTime() },\n  { id: 1, isDone: false, content: &#39;빨래&#39;, date: new Date().getTime() },\n  { id: 2, isDone: false, content: &#39;운동&#39;, date: new Date().getTime() },\n];\n\nfunction App() {\n  const [todos, setTodos] = useState(mockData);\n  const idRef = useRef(3);\n\n  const onCreate = (content) =&gt; {\n    const newTodo = {\n      id: idRef.current++,\n      isDone: false,\n      content: content,\n      date: new Date().getTime(),\n    };\n    setTodos([newTodo, ...todos]);\n  };\n\n  const onUpdate = (targetId) =&gt; {\n    setTodos(\n      todos.map((item) =&gt;\n        item.id === targetId ? { ...item, isDone: !item.isDone } : item\n      )\n    );\n  };\n\n  const onDelete = (targetId) =&gt; {\n    setTodos(todos.filter((item) =&gt; item.id !== targetId));\n  };\n\n  return (\n    &lt;div&gt;\n      {/* UI Components here */}\n    &lt;/div&gt;\n  );\n}</code></pre>\n<h4 id=\"usereducer와-usestate-비교\">useReducer와 useState 비교</h4>\n<ul>\n<li><p>코드 분리와 가독성 측면</p>\n</li>\n<li><p>useReducer : <code>redecer</code> 함수에 모든 상태 변경 로직이 정의되어 있다, 이로 인해 상태 관리 로직이 한 곳에 집중되어 있으며, 상태가 어떻게 변경되는지를 쉽게 파악할 수 있다. 또한 상태 업데이트가 모두 <code>dispatch</code> 를 통해 일관되게 이루어지므로 코드 가독성과 유지보수성이 높아진다.</p>\n</li>\n<li><p>useState: 상태 변경 로직이 onCreate, onUpdate, onDelete 함수 내부에 직접 구현되어 있다. 상태 변경 로직이 분산되어 있어, 시간이 지남에 따라 코드의 복잡성이 증가하고 유지보수가 어려워질 수 있다.</p>\n</li>\n<li><p>상태 업데이트 방식</p>\n</li>\n<li><p>useReducer: dispatch를 사용하여 상태 업데이트 요청을 보냅니다. 이 방식은 상태 변경을 명확하고 예측 가능하게 만들어 줍니다. 또한, action 객체를 사용하여 상태 변경에 필요한 추가적인 정보를 전달할 수 있습니다.</p>\n</li>\n<li><p>useState: 상태를 직접 변경하기 위해 setTodos를 호출합니다. 이 방식은 간단한 상태 변경에는 적합하지만, 복잡한 상태 변경 로직이 필요한 경우 코드가 지저분해질 수 있습니다.</p>\n</li>\n</ul>\n",
    "pubDate": "Mon, 02 Sep 2024 07:08:18 GMT",
    "thumbnail": null
  },
  {
    "title": "useEffect",
    "link": "https://velog.io/@gawgjiug/useEffect",
    "description": "<h2 id=\"useeffect\">useEffect</h2>\n<ul>\n<li><p>useEffect() 함수는 리액트 컴포넌트가 렌더링 될 때마다 특정 작업(Side Effect)을 실행할 수 있도록 하는 리액트 Hook 이다.</p>\n</li>\n<li><p>여기서 SideEffect 는 컴포넌트가 렌더링 된 이후에 비동기로 처리되어야 하는 부수적인 효과들을 뜻한다.</p>\n</li>\n<li><p>useEffect는 component가 mount 됐을 때, unmout 됐을 때, update 됐을 때, <strong>특정 작업을 처리할 수 있다</strong> </p>\n</li>\n</ul>\n<blockquote>\n<p>즉, 클래스형 컴포넌트에서 사용할 수 있었던 생명주기 매소드를 함수형 컴포넌트에서도 사용할 수 있게 된 것을 말한다.</p>\n</blockquote>\n<h4 id=\"useeffect-사용방법\">useEffect 사용방법</h4>\n<blockquote>\n<p>useEffect(function,deps)</p>\n</blockquote>\n<ul>\n<li><p>function : 수행하고자 하는 작업 (리액트가 기억 했다가 DOM 업데이트 후 불러내는 함수)</p>\n</li>\n<li><p>deps : 배열 형태이며 , 배열 안에는 검사하고자 하는 특정 값 or 빈배열\ndeps에 특정 값을 넣게 되면 컴포넌트가 mount 될 때와 지정한 값이 업데이트 될 때 useEffect를 실행한다.</p>\n</li>\n</ul>\n<ol>\n<li>componentDidMount</li>\n</ol>\n<ul>\n<li>Component가 mount 됐을 때 (처음 나타났을 때 실행)</li>\n</ul>\n<pre><code class=\"language-javascript\">useEffect(() = &gt;{\n\nconsole.log(&#39;mount&#39;);\n},[])</code></pre>\n<ul>\n<li>컴포넌트가 화면에 가장 처음 렌더링 될 때 한 번만 실행하고 싶다면 deps 위치에 빈 배열을 넣어준다.</li>\n</ul>\n<pre><code class=\"language-javascript\">useEffect(() = &gt;{\n\nconsole.log(&#39;렌더링 될 때 마다&#39;);\n})</code></pre>\n<ul>\n<li>만약 배열을 생략하면 리렌더링 될 때마다 실행된다.</li>\n</ul>\n<ol start=\"2\">\n<li>componentDidUpdate</li>\n</ol>\n<ul>\n<li>Component가 update 될 때 (특정 props, state가 바뀔 때 실행)</li>\n</ul>\n<pre><code class=\"language-javascript\">useEffect(() = &gt;{\n\nconsole.log(&#39;update&#39;);\n},[name])</code></pre>\n<ul>\n<li><p>특정 값이 업데이트 될 때 실행하고 싶다면, deps 위치의 배열 안에 검사하고 싶은 값을 넣어줍니다.</p>\n</li>\n<li><p>하지만 업데이트 될 때만 실행되는 것이 아니라 마운트 될 때도 실행된다. 만약 업데이트 될 때만 실행시키고 싶다면 아래와 같은 방법을 사용한다</p>\n</li>\n</ul>\n<pre><code class=\"language-javascript\">const mounted = useRef(false)\n\nuseEffect(() =&gt;{\nif(!mounted.current){\n\nmounted.current = true;\n}else{\nconsole.log(name);\n}\n\n},[name])</code></pre>\n<ul>\n<li><p>mounted는 useRef(false)로 초기화됩니다. 즉, mounted.current의 초기값은 false입니다.\nuseEffect 훅이 실행됩니다. 이 훅은 name이 변경될 때마다 실행되도록 되어있지만, 처음 렌더링될 때도 한 번 실행됩니다.</p>\n</li>\n<li><p>!mounted.current 조건이 참(true)이므로 if 블록이 실행됩니다. 따라서 mounted.current = true;가 실행되어 mounted.current의 값이 true로 변경됩니다.</p>\n</li>\n<li><p>이 시점에서 console.log(name);는 실행되지 않습니다.\nname이 변경될 때:</p>\n</li>\n<li><p>name이 변경될 때마다 useEffect가 다시 실행됩니다.</p>\n</li>\n<li><p>이제 mounted.current는 true이기 때문에 !mounted.current 조건이 거짓(false)이 됩니다.</p>\n</li>\n<li><p>따라서 else 블록이 실행되어 console.log(name);가 실행됩니다. 이 시점에서 name의 현재 값이 콘솔에 출력됩니다.\n이후 name이 또 변경될 때마다:</p>\n</li>\n<li><p>mounted.current는 이미 true로 설정되어 있기 때문에 계속해서 else 블록이 실행되며 console.log(name);가 실행됩니다.</p>\n</li>\n</ul>\n<p>** 3.componentDidUnMount**</p>\n<ul>\n<li>component가 unmount 될 때 (사라질 때) &amp; update 되기 직전에 실행</li>\n</ul>\n<pre><code class=\"language-javascript\">const mounted = useRef(false);\n\nuseEffect(() =&gt; {\n  if (!mounted.current) {\n    mounted.current = true;\n  } else {\n    console.log(name);\n  }\n\n  // 정리(cleanup) 함수\n  return () =&gt; {\n    console.log(&#39;컴포넌트가 언마운트되었습니다.&#39;);\n  };\n}, [name]);\n</code></pre>\n<ul>\n<li>cleanup 함수 반환 (return 뒤에 나오는 함수이며, useEffect에 대한 뒷정리 함수라고 한다.)</li>\n</ul>\n<ol>\n<li><p>언마운트 될 때만 cleanup 함수를 실행하고 싶다면, 두 번째 파라미터에 빈 배열을 넣고 return 문과 cleanup 함수를 선언해주면 된다.</p>\n</li>\n<li><p>특정 값이 업데이트 되기 직전에 cleanup 함수를 실행하고 싶다면 deps 배열 안에 검사하고 싶은 값을 넣어준다.</p>\n</li>\n</ol>\n<ul>\n<li><p>정리 함수(clean up) 는 메모리 누수를 방지하고,  이벤트 리스너나 타이머 등의 리소스를 해제하는 데 유영하다.</p>\n</li>\n<li><p>예를 들어 웹 소켓 연결을 닫거나, 구독을 취소하거나, 이벤트 리스너를 제거하는 등의 작업을 수행할 수 있다.</p>\n</li>\n</ul>\n",
    "pubDate": "Mon, 02 Sep 2024 05:13:00 GMT",
    "thumbnail": null
  }
]