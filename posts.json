[
  {
    "title": "[React] React 의 Props && Children",
    "link": "https://velog.io/@gawgjiug/React-React-%EC%9D%98-Props-Children",
    "description": "<ul>\n<li>props와 state는 React 에서 데이터를 다룰 때 사용하는 개념이다.</li>\n</ul>\n<blockquote>\n<p>props : 부모에서 자식 컴포넌트로 데이터를 넘겨줄 때 사용하며 , 직접적으로 수정할 수 없는 값이다.</p>\n</blockquote>\n<blockquote>\n<p>state : Component 내부에서 관리하는 데이터로, 변경이 가능한 값을 말한다.</p>\n</blockquote>\n<h3 id=\"props\">Props</h3>\n<ul>\n<li>React 에서 한 Component 에서 다른 Component로 데이터를 전송할 때 사용하는 특수 객체가 props이다.</li>\n</ul>\n<h4 id=\"단방향-데이터-흐름\">단방향 데이터 흐름</h4>\n<ul>\n<li>그러나 <code>Props는 단방향으로 데이터를 전송한다는 특징</code> 이 있다. 그러므로 자식에서 부모로, 동일한 레벨의 Component로 Props를 전달하는 것은 불가능하다.</li>\n</ul>\n<pre><code class=\"language-jsx\">import &#39;./App.css&#39;;\nimport { useState } from &#39;react&#39;;\nimport Register from &#39;./components/Register&#39;;\nimport HookExam from &#39;./components/HookExam&#39;;\nimport Button from &#39;./components/Button&#39;;\nfunction App() {\n  // const [count, setCount] = useState(0);\n\n  const buttonProps = {\n    text: &#39;메일&#39;,\n    color: &#39;lightcoral&#39;,\n    a: 1,\n    b: 2,\n    c: 3,\n  };\n\n  return (\n    &lt;&gt;\n      &lt;Button {...buttonProps} /&gt;\n      &lt;Button text={&#39;블로그&#39;}&gt;\n        &lt;div&gt;자식요소&lt;/div&gt;\n        &lt;span&gt;다른 자식요소&lt;/span&gt;\n      &lt;/Button&gt;\n    &lt;/&gt;\n  );\n}\n\nexport default App;</code></pre>\n<pre><code class=\"language-jsx\">const Button = ({ text, color = &#39;black&#39;, children }) =&gt; {\n  //이벤트 객체\n  const onClickButton = (e) =&gt; {\n    console.log(e);\n    console.log(text);\n  };\n  // 마우스 엔터 이벤트 핸들러\n  const onMouseEnter = (e) =&gt; {\n    e.target.style.backgroundColor = &#39;lightgreen&#39;;\n  };\n\n  // 마우스가 버튼을 떠날 때 배경색을 원래대로 돌리는 핸들러\n  const onMouseLeave = (e) =&gt; {\n    e.target.style.backgroundColor = &#39;&#39;;\n  };\n\n  console.log(`children = ${children}`);\n  return (\n    &lt;button\n      onClick={onClickButton}\n      onMouseEnter={onMouseEnter}\n      onMouseLeave={onMouseLeave}\n      style={{ color: color }}\n    &gt;\n      {text} - {color.toUpperCase()}\n      {children}\n    &lt;/button&gt;\n  );\n};\n\nexport default Button;</code></pre>\n<p><img src=\"https://velog.velcdn.com/images/gawgjiug/post/1d0adf8e-46ea-4fe2-ae8f-1da66fe3735d/image.png\" alt=\"\"></p>\n<ul>\n<li><p>props로 데이터를 전달하는 방법은 우선 Component에 prop을 정의하고 값을 할당해야 한다.</p>\n</li>\n<li><p>부모 컴포넌트인 App.jsx에서 ButtonProps를 정의하고, Button 컴포넌트를 호출하면서 동시에 props로 값을 넘겨주었다.</p>\n</li>\n<li><p>하나의 컴포넌트에는 spread 연산자로 buttonProps 객체의 값 전체를 넘겨주었고, 다른 하나의 Button 컴포넌트는 직접 text 값을 넘겨주어 표시하였다.</p>\n</li>\n<li><p>여기서 children 개념이 등장하는데, React 공식 문서에서는 Children의 소개글을</p>\n</li>\n</ul>\n<blockquote>\n<p>여는 태그와 닫는 태그를 모두 포함하는 JSX 표현식에서 해당 태그 사이의\n내용은 특수 소품으로 전달됩니다 props.children. 여는 태그와 닫는 태그 사이에 문자열을 넣으면  props.children 해당 문자열이 됩니다.</p>\n</blockquote>\n<ul>\n<li><p>라고 번역되어 있다. 한 마디로 풀어서 말하면, &quot;태그와 태그 사이의 모든 애용을 표시하기 위해 사용되는 특수한 props&quot; 라고 할 수 있다.</p>\n</li>\n<li><p>즉,  컴포넌트가 렌더링될 때, 컴포넌트의 태그 사이에 포함된 내용을 자동으로 자식요소로 전달하는 특수한 prop 이라고 할 수 있다.</p>\n</li>\n<li><p>위 코드에서 첫 번째 <code>Button</code> 컴포넌트는 <code>text</code>와 <code>color</code> props를 전달받지 않으므로 기본값이 적용된다.</p>\n</li>\n<li><p>두 번째 <code>Button</code> 컴포넌트는 <code>text</code>와 <code>color</code> 를 전달 받으며, <code>div</code> 와 <code>span</code> 요소를 <code>children</code> 으로 전달한다.</p>\n</li>\n<li><p>children은 Button 컴포넌트의 시작 태그와 종료 태그 사이에 포함된 내용이 됩니다. 예를 들어, 두 번째 Button 컴포넌트에서 {children}은 <div>자식요소</div>와 <span>다른 자식요소</span>를 포함한다.</p>\n</li>\n</ul>\n<hr>\n<h3 id=\"요약\">요약</h3>\n<ul>\n<li><code>children</code> : React에서 컴포넌트의 시작 태그와 종료 태그 사이에 포함된 모든 내용을 의미한다. 이 내용은 자식 컴포넌트의 <code>children</code> prop 으로 전달되어 컴포넌트 내부에서 사용된다.</li>\n</ul>\n",
    "pubDate": "Wed, 28 Aug 2024 05:32:43 GMT",
    "thumbnail": null
  },
  {
    "title": "JS (비동기 프로그래밍 , 이벤트 루프 & 테스크 큐)",
    "link": "https://velog.io/@gawgjiug/JS-%EB%B9%84%EB%8F%99%EA%B8%B0-%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8D-%EC%9D%B4%EB%B2%A4%ED%8A%B8-%EB%A3%A8%ED%94%84-%ED%85%8C%EC%8A%A4%ED%81%AC-%ED%81%90",
    "description": "<h3 id=\"비동기-프로그래밍\">비동기 프로그래밍</h3>\n<ul>\n<li><p>Javascript는 기본적으로 <code>싱글 스레드 언어</code> 이다. &#39;싱글&#39; 스레드라 한 번에 하나의 작업만 수행이 가능하다.</p>\n</li>\n<li><p>멀티 스레드를 지원하여 원하는 코드 로직을 동시에 수행 시키는 멀티 작업이 가능한 <code>Java</code> 나 <code>Python</code> 과는 다른 것</p>\n</li>\n<li><p>하지만 당연히 웹 애플리케이션에서는 네트워크 요청이나 이벤트 처리, 타이머와 같은 작업은 멀티 (병렬) 처리되어야 한다. 만일 싱글 스레드로 브라우저 동작이 한번에 하나씩 수행하게 되면, 우리가 파일을 다운로드 받을 동안 브라우저는 파일을 다 받을 때 까지 정지하게 됨..</p>\n</li>\n<li><p>따라서 파일 다운, 네트워크 요청, 타이머, 애니메이션 이러한 시간이 소요되고 반복적인 작업들은 JS 엔진이 아니라 <strong>브라우저 내부의 멀티 스레드인 Web APIs</strong> 에서 비동기적으로 처리된다. </p>\n</li>\n</ul>\n<p><img src=\"https://velog.velcdn.com/images/gawgjiug/post/3430120e-27c4-42c7-b762-4323b826b8d4/image.png\" alt=\"\"></p>\n<ul>\n<li>즉, 비동기로 동작하는 핵심요소는 JS 언어가 아니라 브라우저라는 소프트웨어가 가지고 있다고 보면된다. </li>\n</ul>\n<hr>\n<h3 id=\"이벤트-루프-event-loop\">이벤트 루프 (Event Loop)</h3>\n<ul>\n<li>이벤트 루프는 비동기 작업이 처리되는 어떠한 메커니즘을 의미한다. 싱글 스레드 환경에서 이벤트 루프는 자바스크립트와 같은 비동기 프로그래밍 언어에서 매우 중요하게 작용한다.</li>\n</ul>\n<p><img src=\"https://velog.velcdn.com/images/gawgjiug/post/175fef60-0fd0-40f8-8c9d-e162d20a440a/image.png\" alt=\"\"></p>\n<ul>\n<li>자바스크립트의 작업을 멀티 스레드로 돌려 작업을 동시에 처리시키게 한다던가, 또는 여러 작업 중 어떤 작업을 우선으로 동작시킬 것인지 결정하는 컨트롤을 하기 위해 존재하는 것이 이벤트 루프인 것이다.</li>\n</ul>\n<p><img src=\"https://velog.velcdn.com/images/gawgjiug/post/d79b62fb-e59a-43da-b95f-8cbaa1ecf0b1/image.png\" alt=\"\"></p>\n<p><img src=\"https://velog.velcdn.com/images/gawgjiug/post/b01c7430-b135-48d8-8a5a-b65c8151671f/image.png\" alt=\"\"></p>\n<p><img src=\"https://velog.velcdn.com/images/gawgjiug/post/f73dc984-fb2f-4cc5-b917-f4a9a489d580/image.png\" alt=\"\"></p>\n<ul>\n<li><p>위 그림을 참고하여 이벤트 루프와 <code>테스크 큐</code> 에 개념에 대해서 설명할 수 있다.</p>\n</li>\n<li><p>이벤트 루프는 브라우저 내부의 <code>Call Stack</code>, <code>Task Queue</code> , <code>Web APIs</code> 등의 요소들을 모니터링 하면서 비동기적으로 실행되는 작업들을 관리하고 이를 순서대로 처리하여 프로그램의 실행 흐름을 제어하는 녀석이다. </p>\n</li>\n<li><p>간단하게 말하면 <code>브라우저의 동작 타이밍을 제어하는 관리자</code> 라고 보면된다.</p>\n</li>\n<li><p>여기서 <code>콜 스택(Call Stack)</code> 이란 함수가 호출될 때 그 함수가 실행되는 환경(컨텍스트)이 스택에 추가되는 공간을 말한다.</p>\n</li>\n<li><p><code>테스크 큐(Task Queue)</code> 는 비동기 작업의 콜백 함수들이 대기하는 큐 공간을 말한다. WebAPIs에서 진행되는 비동기 작업이 완료되면 해당 작업의 콜백이 테스크 큐에 추가된다.</p>\n</li>\n<li><p><code>이벤트 루프</code> 는 콜 스택이 비어있을 때 테스크 큐에 있는 작업을 콜 스택으로 이동시켜 실행한다. 이러한 과정을 통해 비동기 작업이 실행되는 것.</p>\n</li>\n</ul>\n",
    "pubDate": "Tue, 20 Aug 2024 13:54:14 GMT",
    "thumbnail": null
  },
  {
    "title": "JS (변수 & 호이스팅)",
    "link": "https://velog.io/@gawgjiug/JS-%EB%B3%80%EC%88%98-%ED%98%B8%EC%9D%B4%EC%8A%A4%ED%8C%85",
    "description": "<h2 id=\"1-호이스팅-hoisting\">1. 호이스팅 (Hoisting)</h2>\n<h3 id=\"개요\">개요</h3>\n<ul>\n<li><p>호이스팅은 자바스크립트에서 변수와 함수 선언이 코드 실행 전에 메모리 상단으로 끌어올려지는 현상이다. </p>\n</li>\n<li><p>이로 인해 변수와 함수는 실제 코드 실행 전에 선언될 수 있다.</p>\n</li>\n</ul>\n<h3 id=\"변수-호이스팅\">변수 호이스팅</h3>\n<ul>\n<li><p><strong>예시 코드</strong>:</p>\n<pre><code class=\"language-javascript\">console.log(x); // undefined\nvar x = 5;\nconsole.log(x); // 5</code></pre>\n<ul>\n<li>위 코드는 호이스팅에 의해 다음과 같이 변환된다.</li>\n</ul>\n</li>\n</ul>\n<pre><code class=\"language-javascript\">  var x;\n  console.log(x); // undefined\n  x = 5;\n  console.log(x); // 5</code></pre>\n<ul>\n<li><p>여기서 변수 &#39;x&#39;는 선언만 끌어올려지고, 초기화는 원래 위치에서 이루어진다.</p>\n</li>\n<li><p><code>var</code>는 선언과 동시에 초기화가 이루어진다. 즉, 선언과 동시에 undefiend가 할당되는 것.</p>\n</li>\n<li><p>그러나 <code>let</code> 과 <code>const</code>는 다르다. 선언만 될 뿐 초기화가 이루어지지 않는 <code>TDZ</code> 에 들어가게 된다.</p>\n</li>\n<li><p><code>TDZ</code>란? Temporal Dead Zone 으로 자바스크립의 변수 생성 단계 중 첫 번째 단계인 <strong>선언</strong> 단계에서 변수 객체가 생성되고 초기화 되지 않은 상태에 이른 것을 말한다.</p>\n</li>\n<li><p>모든 선언(function, var, let, const, 및 class)는 Javascript에서 호이스팅 되며, var 선언은 undefined로 초기화 되지만, let 및 const 선언은 초기화 되지 않은 상태로 유지된다.</p>\n</li>\n</ul>\n<pre><code class=\"language-java\">console.log(hoist); // Output: undefined\nvar hoist = &#39;The variable has been hoisted.&#39;;</code></pre>\n<pre><code class=\"language-javascript\">console.log(hoist); // Output: ReferenceError: hoist is not defined ...\nlet hoist = &#39;The variable has been hoisted.&#39;;</code></pre>\n<h3 id=\"함수-호이스팅\">함수 호이스팅</h3>\n<ul>\n<li>함수는 선언 자체가 호이스팅 되어 호출하기 전에 정의된 함수를 사용할 수 있다.</li>\n</ul>\n<pre><code class=\"language-javascript\">foo(); // &quot;Hello&quot;\n\nfunction foo() {\n    console.log(&quot;Hello&quot;);\n}</code></pre>\n<h3 id=\"결론\">결론</h3>\n<ul>\n<li><p>호이스팅은 함수를 어디에 선언 하였든지, 신경 스지 않고 필요한 곳에서 자유롭게 사용하기 위해 만들어진 기능이다.</p>\n</li>\n<li><p>그러나 이 기능이 때로는 의도치 않은 버그를 생성할 여지가 있고, 따라서 호이스팅을 의도적으로 사용하는 경우가 아니라면 호이스팅이 되지 않거나,</p>\n</li>\n<li><p>TDZ 으로 초기화 되는 <code>let</code>,<code>const</code> 함수 표현식을 사용하는 것을 권장</p>\n</li>\n</ul>\n<hr>\n<h2 id=\"2-var-키워드의-문제점\">2. &#39;var&#39; 키워드의 문제점</h2>\n<h3 id=\"스코프-문제\">스코프 문제</h3>\n<ul>\n<li><p><code>var</code> 로 선언된 변수는 함수 전체에서 유효하다. 블록 내에서 선언을 해도 블록 외부에서 접근 가능한 것이 특징이고</p>\n</li>\n<li><p><code>let</code> 으로 선언된 변수는 블록 내에서만 유효하다. 블록 외부에서 접근하려고하면 <code>ReferenceError</code> 가 발생</p>\n</li>\n</ul>\n<pre><code class=\"language-javascript\">function example() {\n    if (true) {\n        var x = 10;\n    }\n    console.log(x); // 10\n}\n\nexample();</code></pre>\n<h3 id=\"재선언-문제\">재선언 문제</h3>\n<ul>\n<li>같은 스코프 내에서 같은 이름의 변수를 여러 번 선언할 수 있다. 이러한 점은 코드의 예측 가능성을 낮출 수 있음</li>\n</ul>\n<pre><code class=\"language-javascript\">var z = 30;\nvar z = 40; // 재선언 가능\nconsole.log(z); // 40</code></pre>\n",
    "pubDate": "Tue, 13 Aug 2024 08:36:22 GMT",
    "thumbnail": null
  },
  {
    "title": "JS 'this' ",
    "link": "https://velog.io/@gawgjiug/JS-this",
    "description": "<h3 id=\"this는-무엇인가\">this는 무엇인가?</h3>\n<hr>\n<ul>\n<li><p>대부분의 경우 <code>tihs</code>의 값은 함수를 호출한 방법에 의해 결정된다.</p>\n</li>\n<li><p><code>this</code> 는 호출한 놈을 말한다.</p>\n</li>\n<li><p>기본적으로는 <code>this</code> 는 window 객체를 말한다.</p>\n</li>\n<li><p>예외의 경우 </p>\n</li>\n</ul>\n<ol>\n<li><p>화살표 함수에서 <code>this</code> 가 조금 달라진다.</p>\n</li>\n<li><p>Strict Mode에서는 <code>this</code> 가 조금 달라진다.</p>\n</li>\n</ol>\n<h4 id=\"this\">this</h4>\n<hr>\n<ul>\n<li>대부분의 경우 <code>this</code> 의 값은 함수를 호출한 방법 즉,  호출한 놈에 의해 결정된다.</li>\n</ul>\n<pre><code class=\"language-js\">function printThis() {\n  console.log(this);\n}\nprintThis(); // window 객체\n\nlet person1 = {\n  name: &#39;김길동&#39;,\n  whoIsThis: printThis,\n};\n\nlet person2 = {\n  name: &#39;홍길동&#39;,\n  whoIsThis: printThis,\n};\n\nlet person3 = {\n  name: &#39;짐길동&#39;,\n  whoIsThis: printThis,\n};\n\nperson1.whoIsThis(); // person1 객체\nperson2.whoIsThis(); // person2 객체\nperson3.whoIsThis(); // person3 객체</code></pre>\n<h4 id=\"bind-함수\">bind 함수</h4>\n<ul>\n<li><code>bind</code> 함수로 <code>this</code>를 설정할 수 있다.</li>\n</ul>\n<pre><code class=\"language-js\">function print() {\n  console.log(&#39;this: &#39;, this);\n  console.log(&#39;this.fullname: &#39;, this.fullname);\n}\n\nlet person1 = {\n  fullname: &#39;홍길동&#39;,\n};\nlet person2 = {\n  fullname: &#39;김길동&#39;,\n};\nlet bindPrint = print.bind(person1); // person1 객체로 바인딩\nbindPrint(); // person1\nlet bindPrint2 = bindPrint.bind(person2);\nbindPrint2(); // person1! bind는 단 한번만 할 수 있다.</code></pre>\n<h4 id=\"arrow-function-this\">Arrow Function this</h4>\n<hr>\n<ul>\n<li><p>화살표 함수가 나오기 전 까지는 함수는 어떻게 호출되는지에 따라 자신의 <code>this</code> 값을 정의했다.</p>\n</li>\n<li><p>하지만 화살표 함수는 자신을 포함하고 있는 외부 Scope에서 this를 계승받는다.</p>\n</li>\n</ul>\n<pre><code class=\"language-js\">let person = {\n  name: &#39;곽지욱&#39;,\n  printThis: function () {\n    console.log(this) //person 객체\n    setTimeout(() =&gt; {\n      console.log(this); // person 객체\n    });\n  },\n};</code></pre>\n<ul>\n<li>화살표 함수를 사용할 경우 나를 감싸고 있는 상위 스코프의 this를 계승받기 때문에 person 객체를 받는 것</li>\n</ul>\n<pre><code class=\"language-js\">let person = {\n    name: &#39;곽지욱&#39;,\n    printThis: () =&gt; {\n        console.log(this); // window 객체 출력\n    }\n};</code></pre>\n<ul>\n<li>그렇기에 위 경우에서는 상위 스코프가 전역 스코프이기 때문에 window 객체를 출력하는 것</li>\n</ul>\n<h4 id=\"strict-mode\">Strict Mode</h4>\n<hr>\n<ul>\n<li>엄격 모드에서는 호출한 놈이 없을 경우 기본값을 <code>window</code>로 하지 않고 <code>undefined</code>로 한다.</li>\n</ul>\n<pre><code class=\"language-js\">&#39;use strict&#39;;\nfunction printThis() {\n    console.log(this);\n}\nprintThis(); // undefined</code></pre>\n",
    "pubDate": "Mon, 12 Aug 2024 08:41:56 GMT",
    "thumbnail": null
  },
  {
    "title": "JS Object (객체)",
    "link": "https://velog.io/@gawgjiug/JS-Object-%EA%B0%9D%EC%B2%B4",
    "description": "<h3 id=\"object\">Object</h3>\n<hr>\n<ul>\n<li>객체는 연관된 데이터를 담는 그릇이다. 프리미티브 타입(Primitive Type)은 단 하나의 값만 나타낼 수 있고 불변이지만, 이와 달리 객체는 여러가지 값이나 복잡한 값을 나타낼 수 있으며 , 값(내용물)이 변할 수도 있음</li>\n</ul>\n<h4 id=\"객체구성\">객체구성</h4>\n<hr>\n<ul>\n<li>JS에서 객체는 키(key)와 값(value)으로 구성되어있다.</li>\n</ul>\n<pre><code class=\"language-js\">const person = {\n    name: &#39;곽지욱&#39;,\n    age: 24\n};\n// name이 키(key)이며, \n// &#39;곽지욱&#39;이 값(value)이다.</code></pre>\n<ul>\n<li>객체는 여러가지 값을 가질 수 있고, 객체가 가지고 있는 값을 <code>프로퍼티(Property)</code>라고 하며, 객체가 가지고 있는 함수를 <code>메서드</code> 라고함</li>\n</ul>\n<pre><code class=\"language-js\">const obj = {\n    name: &#39;곽지욱&#39;,    // name 프로퍼티\n    age: 20,         // age 프로퍼티\n    sayHello: function() {   // sayHello 메서드\n        console.log(&#39;Hello!&#39;);\n    },\n    sayHi() {  // 이렇게도 선언할 수 있다.\n        console.log(&#39;Hi!&#39;);\n    }\n};</code></pre>\n<h4 id=\"객체-프로퍼티-접근\">객체 프로퍼티 접근</h4>\n<hr>\n<ul>\n<li><p>객체 안에 있는 프로퍼티나 함수에 접근하기 위해서는 크게 두 가지 방법이있다.</p>\n</li>\n<li><p><code>점표기법</code> - <code>예) 객체.key</code></p>\n</li>\n</ul>\n<pre><code class=\"language-js\">person.name\nperson.age\nperson.gender\nperson.hello()\nperson.bobby.name\nperson.bobby.alert()</code></pre>\n<ul>\n<li>괄포 표기법 - <code>예) 객체[&#39;key&#39;]</code><pre><code class=\"language-js\">person[&#39;name&#39;]\nperson[&#39;age&#39;]\nperson[&#39;gender&#39;]\nperson[&#39;hello&#39;]()\nperson[&#39;hobby&#39;][&#39;name&#39;]\nperson[&#39;hobby&#39;][&#39;alert&#39;]()</code></pre>\n</li>\n</ul>\n<h4 id=\"함수-파라미터로-객체-전달하기\">함수 파라미터로 객체 전달하기</h4>\n<hr>\n<ul>\n<li>함수 파라미터로 객체를 전달하면 코드를 클린하게 만들 수 있다.</li>\n</ul>\n<p><code>Before</code></p>\n<pre><code class=\"language-js\">function printPerson(name, age, hobby) {\n  console.log(`제 이름은 ${name}이며, 나이는 ${age}살 입니다.그리고 취미는 ${hobby} 입니다.`);\n}\nprintPerson(&#39;곽지욱&#39;, 10, &#39;헬스&#39;);</code></pre>\n<p><code>After</code></p>\n<pre><code class=\"language-js\">function printPerson(person) {\n  console.log(`제 이름은 ${person.name}이며, 나이는 ${person.age}살 입니다.그리고 취미는 ${person.hobby} 입니다.`);\n}\n\nconst person = {\n  name: &#39;곽지욱&#39;,\n  age: 10,\n  hobby: &#39;헬스&#39;\n};\nprintPerson(person);</code></pre>\n<h4 id=\"구조-분해-할당\">구조 분해 할당</h4>\n<ul>\n<li>객체 속성을 개별 변수에 담을 때 변수의 순서가 아니라 key가 동일하는지가 중요하다.</li>\n</ul>\n<pre><code class=\"language-js\">const person = {\n  name: &#39;곽지욱&#39;,\n  age: 10,\n  hobby: &#39;헬스&#39;\n};\nconst { name, age, hobby } = person;</code></pre>\n<h4 id=\"팩토리-함수\">팩토리 함수</h4>\n<hr>\n<ul>\n<li>JS 로 같은 유형의 객체를 여러번 생성해야 할 때 사용하는 함수 생성 기법이다.<pre><code class=\"language-js\">const person1 = {\nname: &#39;곽지욱&#39;,\nage: 10,\nhobby: &#39;헬스&#39;\n};\nconst person2 = {\nname: &#39;홍길동&#39;,\nage: 20,\nhobby: &#39;축지법&#39;\n};\nconst person3 = {\nname: &#39;도깨비&#39;,\nage: 30,\nhobby: &#39;도술&#39;\n};\n...\nconst person10 = {\n...\n};</code></pre>\n</li>\n<li>이렇게 객체 리터럴로 반복적으로 생성하다 보면 코드의 반복도 많아지고 가독성도 그만큼 떨어짐 <code>팩토리 함수</code>를 사용해야함</li>\n</ul>\n<pre><code class=\"language-js\">function createPerson(name, age, hobby) {\n    return {\n        name: name,\n        age: age,\n        hobby: hobby\n    };\n};\n\nconst person1 = createPerson(&#39;곽지욱&#39;, 10, &#39;헬스&#39;);\nconst person2 = createPerson(&#39;홍길동&#39;, 20, &#39;헬스&#39;);\nconst person3 = createPerson(&#39;김길동&#39;, 30, &#39;헬스&#39;);\nconst person4 = createPerson(&#39;고길동&#39;, 40, &#39;헬스&#39;);\nconst person5 = createPerson(&#39;한길동&#39;, 50, &#39;헬스&#39;);\nconst person6 = createPerson(&#39;최길동&#39;, 60, &#39;헬스&#39;);</code></pre>\n<ul>\n<li>사실 여기서 정의 된 name,age,hobby 모두 key와 value가 동일하기 때문에 단축 속성명을 사용 할 수 있다. 단축 속성명은 key와 value를 각각 표기하지 않고 한번만 표기하는 것을 말함</li>\n</ul>\n<ul>\n<li>뿐만 아니라 클래스를 사용해서 객체를 생성할 수도 있다.</li>\n</ul>\n<pre><code class=\"language-js\">class Person {\n  constructor(name, age, hobby) {\n    this.name = name;\n        this.age = age;\n        this.hobby = hobby;\n  }\n}\nconst person = new Person(&#39;곽지욱&#39;, 20, &#39;헬스&#39;);\nconsole.log(person)</code></pre>\n<h4 id=\"참조타입-reference-type\">참조타입 (Reference type)</h4>\n<hr>\n<ul>\n<li><p>프리미티브 타입이 아닌 것들은 객체타입 또는 참조타입이라고 한다.</p>\n</li>\n<li><p>프리미티브 타입 값을 다른 변수에 할당하면 값 자체를 넘겨주는 것이기 때문에 값의 원형이 변경되진 않는다.</p>\n</li>\n</ul>\n<pre><code class=\"language-js\">let str1 = &#39;hello&#39;;\nlet str2 = str1;\nstr2 = &#39;world&#39;;\nconsole.log(&#39;str1: &#39;, str1);  // str1:  hello\nconsole.log(&#39;str2: &#39;, str2);  // str2:  world</code></pre>\n<ul>\n<li>하지만 객체 타입을 다른 변수에 할당하면 참조값이 할당 되기 때문에 할당 받은 변수에서 속성을 변경하면 값의 원형이 변경된다.</li>\n</ul>\n<pre><code class=\"language-js\">let obj1 = { name: &#39;곽지욱&#39;, age: 20 };\nlet obj2 = obj1;\nobj2.age = 30;\nobj2.hobby = &#39;헬스&#39;;\nconsole.log(&#39;obj1: &#39;, obj1);  // obj1:  {name: &#39;곽지욱&#39;, age: 30, hobby: &#39;헬스&#39;}\nconsole.log(&#39;obj2: &#39;, obj2);  // obj2:  {name: &#39;곽지욱&#39;, age: 30, hobby: &#39;헬스&#39;}</code></pre>\n<h4 id=\"call-by-value-vs-call-by-reference\">Call By Value vs Call By Reference</h4>\n<hr>\n<ul>\n<li>함수 호출시에 파라미터로 프리미티브 타입을 넘기는 것과 객체 타입을 넘기는 것은 차이가 있다.</li>\n</ul>\n<pre><code class=\"language-js\">function changeName(username) {\n    username = &#39;홍길동&#39;;\n}\nconst name = &#39;GYMCODING&#39;;\nchangeName(name);\nconsole.log(&#39;name: &#39;, name); // name:  GYMCODING</code></pre>\n<p><code>Call by Value</code> 는 값 자체를 username에 할당하기 때문에 username 값을 변경해도 함수밖의 name은 변경되지 않는다. 즉 값이 복사된 것.</p>\n<ul>\n<li>Call By Reference (참조에 의한 호출)</li>\n</ul>\n<pre><code class=\"language-js\">function changeName(people) {\n    people.name = &#39;홍길동&#39;;\n}\nconst person = { name: &#39;GYMCODING&#39; };\nchangeName(person);\nconsole.log(&#39;name: &#39;, person.name);  // name:  홍길동</code></pre>\n<ul>\n<li>Call By Reference 는 값 자체가 아니라 값을 가리키는 참조 값을 people에 할당 했기 때문에 people과 person이 가리키고 있는 값은 같다.</li>\n</ul>\n<h4 id=\"spread-operator-전개-구문\">Spread operator (전개 구문)</h4>\n<ul>\n<li>Spread는 펼치다 라는 뜻 <code>...</code> 표기법을 사용하여 사용할 수 있다.</li>\n</ul>\n<pre><code class=\"language-js\">let obj = {\n    name: &#39;곽지욱&#39;,\n    age: 20\n};\nlet person = {\n    ...obj,\n    hobby: &#39;헬스&#39;\n};\nconsole.log(&#39;person: &#39;, person);\n// [출력]\n// person:  {name: &#39;곽지욱&#39;, age: 20, hobby: &#39;헬스&#39;}</code></pre>\n<h4 id=\"forin\">for...in</h4>\n<hr>\n<ul>\n<li>객체에 있는 키 항목들을 반복적으로 반환한다.</li>\n</ul>\n<pre><code class=\"language-js\">const person = {\n    name: &#39;홍길동&#39;,\n    age: 20,\n    job: &#39;개발자&#39;\n};\nfor (let key in person) {\n    console.log(`key: ${key}, value: ${person[key]}`);\n}\n// [출력]\n// key: name, value: 홍길동\n// key: age, value: 20\n// key: job, value: 개발자\n</code></pre>\n<h4 id=\"키-존재-여부-확인\">키 존재 여부 확인</h4>\n<hr>\n<ul>\n<li>in operator - key in object</li>\n</ul>\n<pre><code class=\"language-js\">const person = {\n  name: &#39;곽지욱&#39;,\n};\nconsole.log(&#39;name&#39; in person)  // true\nconsole.log(&#39;age&#39; in person)   // true\n\nif (&#39;name&#39; in person) {\n  console.log(&#39;이름이 정의되어 있습니다.&#39;);\n}</code></pre>\n",
    "pubDate": "Mon, 12 Aug 2024 06:08:58 GMT",
    "thumbnail": null
  },
  {
    "title": "JS 배열",
    "link": "https://velog.io/@gawgjiug/JS-%EB%B0%B0%EC%97%B4",
    "description": "<h3 id=\"구조-분해-할당\">구조 분해 할당</h3>\n<ul>\n<li><p>구조 분해 할당 문법은 <strong>배열이나 객체의 속성을 해체</strong> 하여 그 값을 개별 변수에 담을 수 있게 하는 자바스크립트 표현식을 말한다.</p>\n</li>\n<li><p>일반 - 배열 항목을 개별 변수에 담을 때</p>\n</li>\n</ul>\n<pre><code class=\"language-js\">const fruits = [&#39;사과&#39;, &#39;바나나&#39;, &#39;딸기&#39;];\nconst apple = fruits[0];\nconst banana = fruits[1];\nconst strawberry = fruits[2];</code></pre>\n<ul>\n<li>구조 분해 할당 - 배열 항목을 개별 변수에 담을 때</li>\n</ul>\n<pre><code class=\"language-js\">const fruits = [&#39;사과&#39;, &#39;바나나&#39;, &#39;딸기&#39;, &#39;수박&#39;];\nconst [apple, ...others]  = fruits;\nconsole.log(apple);  // 사과\nconsole.log(others); // [&#39;바나나&#39;, &#39;딸기&#39;, &#39;수박&#39;]</code></pre>\n<h3 id=\"spread-syntax-전개구문\">Spread syntax (전개구문)</h3>\n<ul>\n<li>Spread는 펼치다라는 뜻으로, <code>Spread syntax</code>는 배열을 할당할 때 참조 값을 할당 하는게 아닌 배열안의 항목을 펼치는 방식으로 할당할 수 있다.</li>\n</ul>\n<pre><code class=\"language-js\">let arr = [1, &#39;two&#39;, 3, &#39;four&#39;];\nlet numberArr = [...arr, 5, &#39;six&#39;];\nconsole.log(&#39;numberArr: &#39;, numberArr);\n// [출력]\n// numberArr:  (6) [1, &#39;two&#39;, 3, &#39;four&#39;, 5, &#39;six&#39;]</code></pre>\n<h3 id=\"rest-parameters\">Rest parameters</h3>\n<ul>\n<li>나머지 매개변수 구문(Rest parameters)를 사용하면 함수가 무한한 수의 파라미터를 배열로 받을 수 있다.</li>\n</ul>\n<pre><code class=\"language-js\">function printFruits(...fruits) {\n    console.log(&#39;fruits: &#39;, fruits);\n}\nfunction printTitleAndFruits(title, ...fruits) {\n    console.log(&#39;title:&#39; , title);\n    console.log(&#39;fruits: &#39;, fruits);\n}\nprintFruits(&#39;사과&#39;, &#39;바나나&#39;, &#39;딸기&#39;);\nprintFruits(&#39;사과&#39;, &#39;바나나&#39;, &#39;딸기&#39;, &#39;포도&#39;);\nprintTitleAndFruits(&#39;과일출력&#39;, &#39;사과&#39;, &#39;바나나&#39;, &#39;딸기&#39;, &#39;포도&#39;);</code></pre>\n<h3 id=\"배열-복사하기\">배열 복사하기</h3>\n<ul>\n<li>배열은 객체이기 때문에 당연히 참조 값을 가지고 있고 <code>얇은 복사</code> 를 할 경우에는 하나의 배열을 변경하면 다른 배열도 같은 메모리 참조 값을 가지고 있기 때문에 결국에는 함께 변경이 된다</li>\n</ul>\n<pre><code class=\"language-js\">const fruits = [&#39;오렌지&#39;, &#39;포도&#39;, &#39;사과&#39;, &#39;바나나&#39;, &#39;딸기&#39;];\nconst copy = fruits;\ncopy.pop();                        // 끝에 항목 제거\nconsole.log(&#39;fruits: &#39;, fruits);   // [&#39;오렌지&#39;, &#39;포도&#39;, &#39;사과&#39;, &#39;바나나&#39;]\nconsole.log(&#39;copyFruits: &#39;, copy); // [&#39;오렌지&#39;, &#39;포도&#39;, &#39;사과&#39;, &#39;바나나&#39;]</code></pre>\n<ul>\n<li>전개 구문을 사용해서 <code>deep copy</code> 문법을 사용하면 해당 원본에 값만 가져오기 때문에 하나의 배열을 변경해도 별개로서 존재한다.</li>\n</ul>\n<pre><code class=\"language-js\">const fruits = [&#39;오렌지&#39;, &#39;포도&#39;, &#39;사과&#39;, &#39;바나나&#39;, &#39;딸기&#39;];\nconst copy = [...fruits];\ncopy.pop();                        // 끝에 항목 제거\nconsole.log(&#39;fruits: &#39;, fruits);   // [&#39;오렌지&#39;, &#39;포도&#39;, &#39;사과&#39;, &#39;바나나&#39;, &#39;딸기&#39;]\nconsole.log(&#39;copyFruits: &#39;, copy); // [&#39;오렌지&#39;, &#39;포도&#39;, &#39;사과&#39;, &#39;바나나&#39;]</code></pre>\n<ul>\n<li>혹은 Array.from () 메서드를 이용해도 된다.</li>\n</ul>\n<pre><code class=\"language-js\">const fruits = [&#39;오렌지&#39;, &#39;포도&#39;, &#39;사과&#39;, &#39;바나나&#39;, &#39;딸기&#39;];\nconst copy = Array.from(fruits);\ncopy.pop();                        // 끝에 항목 제거\nconsole.log(&#39;fruits: &#39;, fruits);   // [&#39;오렌지&#39;, &#39;포도&#39;, &#39;사과&#39;, &#39;바나나&#39;, &#39;딸기&#39;]\nconsole.log(&#39;copyFruits: &#39;, copy); // [&#39;오렌지&#39;, &#39;포도&#39;, &#39;사과&#39;, &#39;바나나&#39;]</code></pre>\n",
    "pubDate": "Fri, 09 Aug 2024 05:26:32 GMT",
    "thumbnail": null
  }
]