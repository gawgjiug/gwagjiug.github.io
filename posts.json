[
  {
    "title": "JS (비동기 프로그래밍 , 이벤트 루프 & 테스크 큐)",
    "link": "https://velog.io/@gawgjiug/JS-%EB%B9%84%EB%8F%99%EA%B8%B0-%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8D-%EC%9D%B4%EB%B2%A4%ED%8A%B8-%EB%A3%A8%ED%94%84-%ED%85%8C%EC%8A%A4%ED%81%AC-%ED%81%90",
    "description": "<h3 id=\"비동기-프로그래밍\">비동기 프로그래밍</h3>\n<ul>\n<li><p>Javascript는 기본적으로 <code>싱글 스레드 언어</code> 이다. &#39;싱글&#39; 스레드라 한 번에 하나의 작업만 수행이 가능하다.</p>\n</li>\n<li><p>멀티 스레드를 지원하여 원하는 코드 로직을 동시에 수행 시키는 멀티 작업이 가능한 <code>Java</code> 나 <code>Python</code> 과는 다른 것</p>\n</li>\n<li><p>하지만 당연히 웹 애플리케이션에서는 네트워크 요청이나 이벤트 처리, 타이머와 같은 작업은 멀티 (병렬) 처리되어야 한다. 만일 싱글 스레드로 브라우저 동작이 한번에 하나씩 수행하게 되면, 우리가 파일을 다운로드 받을 동안 브라우저는 파일을 다 받을 때 까지 정지하게 됨..</p>\n</li>\n<li><p>따라서 파일 다운, 네트워크 요청, 타이머, 애니메이션 이러한 시간이 소요되고 반복적인 작업들은 JS 엔진이 아니라 <strong>브라우저 내부의 멀티 스레드인 Web APIs</strong> 에서 비동기적으로 처리된다. </p>\n</li>\n</ul>\n<p><img src=\"https://velog.velcdn.com/images/gawgjiug/post/3430120e-27c4-42c7-b762-4323b826b8d4/image.png\" alt=\"\"></p>\n<ul>\n<li>즉, 비동기로 동작하는 핵심요소는 JS 언어가 아니라 브라우저라는 소프트웨어가 가지고 있다고 보면된다. </li>\n</ul>\n<hr>\n<h3 id=\"이벤트-루프-event-loop\">이벤트 루프 (Event Loop)</h3>\n<ul>\n<li>이벤트 루프는 비동기 작업이 처리되는 어떠한 메커니즘을 의미한다. 싱글 스레드 환경에서 이벤트 루프는 자바스크립트와 같은 비동기 프로그래밍 언어에서 매우 중요하게 작용한다.</li>\n</ul>\n<p><img src=\"https://velog.velcdn.com/images/gawgjiug/post/175fef60-0fd0-40f8-8c9d-e162d20a440a/image.png\" alt=\"\"></p>\n<ul>\n<li>자바스크립트의 작업을 멀티 스레드로 돌려 작업을 동시에 처리시키게 한다던가, 또는 여러 작업 중 어떤 작업을 우선으로 동작시킬 것인지 결정하는 컨트롤을 하기 위해 존재하는 것이 이벤트 루프인 것이다.</li>\n</ul>\n<p><img src=\"https://velog.velcdn.com/images/gawgjiug/post/d79b62fb-e59a-43da-b95f-8cbaa1ecf0b1/image.png\" alt=\"\"></p>\n<p><img src=\"https://velog.velcdn.com/images/gawgjiug/post/b01c7430-b135-48d8-8a5a-b65c8151671f/image.png\" alt=\"\"></p>\n<p><img src=\"https://velog.velcdn.com/images/gawgjiug/post/f73dc984-fb2f-4cc5-b917-f4a9a489d580/image.png\" alt=\"\"></p>\n<ul>\n<li><p>위 그림을 참고하여 이벤트 루프와 <code>테스크 큐</code> 에 개념에 대해서 설명할 수 있다.</p>\n</li>\n<li><p>이벤트 루프는 브라우저 내부의 <code>Call Stack</code>, <code>Task Queue</code> , <code>Web APIs</code> 등의 요소들을 모니터링 하면서 비동기적으로 실행되는 작업들을 관리하고 이를 순서대로 처리하여 프로그램의 실행 흐름을 제어하는 녀석이다. </p>\n</li>\n<li><p>간단하게 말하면 <code>브라우저의 동작 타이밍을 제어하는 관리자</code> 라고 보면된다.</p>\n</li>\n<li><p>여기서 <code>콜 스택(Call Stack)</code> 이란 함수가 호출될 때 그 함수가 실행되는 환경(컨텍스트)이 스택에 추가되는 공간을 말한다.</p>\n</li>\n<li><p><code>테스크 큐(Task Queue)</code> 는 비동기 작업의 콜백 함수들이 대기하는 큐 공간을 말한다. WebAPIs에서 진행되는 비동기 작업이 완료되면 해당 작업의 콜백이 테스크 큐에 추가된다.</p>\n</li>\n<li><p><code>이벤트 루프</code> 는 콜 스택이 비어있을 때 테스크 큐에 있는 작업을 콜 스택으로 이동시켜 실행한다. 이러한 과정을 통해 비동기 작업이 실행되는 것.</p>\n</li>\n</ul>\n",
    "pubDate": "Tue, 20 Aug 2024 13:54:14 GMT",
    "thumbnail": null
  },
  {
    "title": "JS (변수 & 호이스팅)",
    "link": "https://velog.io/@gawgjiug/JS-%EB%B3%80%EC%88%98-%ED%98%B8%EC%9D%B4%EC%8A%A4%ED%8C%85",
    "description": "<h2 id=\"1-호이스팅-hoisting\">1. 호이스팅 (Hoisting)</h2>\n<h3 id=\"개요\">개요</h3>\n<ul>\n<li><p>호이스팅은 자바스크립트에서 변수와 함수 선언이 코드 실행 전에 메모리 상단으로 끌어올려지는 현상이다. </p>\n</li>\n<li><p>이로 인해 변수와 함수는 실제 코드 실행 전에 선언될 수 있다.</p>\n</li>\n</ul>\n<h3 id=\"변수-호이스팅\">변수 호이스팅</h3>\n<ul>\n<li><p><strong>예시 코드</strong>:</p>\n<pre><code class=\"language-javascript\">console.log(x); // undefined\nvar x = 5;\nconsole.log(x); // 5</code></pre>\n<ul>\n<li>위 코드는 호이스팅에 의해 다음과 같이 변환된다.</li>\n</ul>\n</li>\n</ul>\n<pre><code class=\"language-javascript\">  var x;\n  console.log(x); // undefined\n  x = 5;\n  console.log(x); // 5</code></pre>\n<ul>\n<li><p>여기서 변수 &#39;x&#39;는 선언만 끌어올려지고, 초기화는 원래 위치에서 이루어진다.</p>\n</li>\n<li><p><code>var</code>는 선언과 동시에 초기화가 이루어진다. 즉, 선언과 동시에 undefiend가 할당되는 것.</p>\n</li>\n<li><p>그러나 <code>let</code> 과 <code>const</code>는 다르다. 선언만 될 뿐 초기화가 이루어지지 않는 <code>TDZ</code> 에 들어가게 된다.</p>\n</li>\n<li><p><code>TDZ</code>란? Temporal Dead Zone 으로 자바스크립의 변수 생성 단계 중 첫 번째 단계인 <strong>선언</strong> 단계에서 변수 객체가 생성되고 초기화 되지 않은 상태에 이른 것을 말한다.</p>\n</li>\n<li><p>모든 선언(function, var, let, const, 및 class)는 Javascript에서 호이스팅 되며, var 선언은 undefined로 초기화 되지만, let 및 const 선언은 초기화 되지 않은 상태로 유지된다.</p>\n</li>\n</ul>\n<pre><code class=\"language-java\">console.log(hoist); // Output: undefined\nvar hoist = &#39;The variable has been hoisted.&#39;;</code></pre>\n<pre><code class=\"language-javascript\">console.log(hoist); // Output: ReferenceError: hoist is not defined ...\nlet hoist = &#39;The variable has been hoisted.&#39;;</code></pre>\n<h3 id=\"함수-호이스팅\">함수 호이스팅</h3>\n<ul>\n<li>함수는 선언 자체가 호이스팅 되어 호출하기 전에 정의된 함수를 사용할 수 있다.</li>\n</ul>\n<pre><code class=\"language-javascript\">foo(); // &quot;Hello&quot;\n\nfunction foo() {\n    console.log(&quot;Hello&quot;);\n}</code></pre>\n<h3 id=\"결론\">결론</h3>\n<ul>\n<li><p>호이스팅은 함수를 어디에 선언 하였든지, 신경 스지 않고 필요한 곳에서 자유롭게 사용하기 위해 만들어진 기능이다.</p>\n</li>\n<li><p>그러나 이 기능이 때로는 의도치 않은 버그를 생성할 여지가 있고, 따라서 호이스팅을 의도적으로 사용하는 경우가 아니라면 호이스팅이 되지 않거나,</p>\n</li>\n<li><p>TDZ 으로 초기화 되는 <code>let</code>,<code>const</code> 함수 표현식을 사용하는 것을 권장</p>\n</li>\n</ul>\n<hr>\n<h2 id=\"2-var-키워드의-문제점\">2. &#39;var&#39; 키워드의 문제점</h2>\n<h3 id=\"스코프-문제\">스코프 문제</h3>\n<ul>\n<li><p><code>var</code> 로 선언된 변수는 함수 전체에서 유효하다. 블록 내에서 선언을 해도 블록 외부에서 접근 가능한 것이 특징이고</p>\n</li>\n<li><p><code>let</code> 으로 선언된 변수는 블록 내에서만 유효하다. 블록 외부에서 접근하려고하면 <code>ReferenceError</code> 가 발생</p>\n</li>\n</ul>\n<pre><code class=\"language-javascript\">function example() {\n    if (true) {\n        var x = 10;\n    }\n    console.log(x); // 10\n}\n\nexample();</code></pre>\n<h3 id=\"재선언-문제\">재선언 문제</h3>\n<ul>\n<li>같은 스코프 내에서 같은 이름의 변수를 여러 번 선언할 수 있다. 이러한 점은 코드의 예측 가능성을 낮출 수 있음</li>\n</ul>\n<pre><code class=\"language-javascript\">var z = 30;\nvar z = 40; // 재선언 가능\nconsole.log(z); // 40</code></pre>\n",
    "pubDate": "Tue, 13 Aug 2024 08:36:22 GMT",
    "thumbnail": null
  },
  {
    "title": "JS 'this' ",
    "link": "https://velog.io/@gawgjiug/JS-this",
    "description": "<h3 id=\"this는-무엇인가\">this는 무엇인가?</h3>\n<hr>\n<ul>\n<li><p>대부분의 경우 <code>tihs</code>의 값은 함수를 호출한 방법에 의해 결정된다.</p>\n</li>\n<li><p><code>this</code> 는 호출한 놈을 말한다.</p>\n</li>\n<li><p>기본적으로는 <code>this</code> 는 window 객체를 말한다.</p>\n</li>\n<li><p>예외의 경우 </p>\n</li>\n</ul>\n<ol>\n<li><p>화살표 함수에서 <code>this</code> 가 조금 달라진다.</p>\n</li>\n<li><p>Strict Mode에서는 <code>this</code> 가 조금 달라진다.</p>\n</li>\n</ol>\n<h4 id=\"this\">this</h4>\n<hr>\n<ul>\n<li>대부분의 경우 <code>this</code> 의 값은 함수를 호출한 방법 즉,  호출한 놈에 의해 결정된다.</li>\n</ul>\n<pre><code class=\"language-js\">function printThis() {\n  console.log(this);\n}\nprintThis(); // window 객체\n\nlet person1 = {\n  name: &#39;김길동&#39;,\n  whoIsThis: printThis,\n};\n\nlet person2 = {\n  name: &#39;홍길동&#39;,\n  whoIsThis: printThis,\n};\n\nlet person3 = {\n  name: &#39;짐길동&#39;,\n  whoIsThis: printThis,\n};\n\nperson1.whoIsThis(); // person1 객체\nperson2.whoIsThis(); // person2 객체\nperson3.whoIsThis(); // person3 객체</code></pre>\n<h4 id=\"bind-함수\">bind 함수</h4>\n<ul>\n<li><code>bind</code> 함수로 <code>this</code>를 설정할 수 있다.</li>\n</ul>\n<pre><code class=\"language-js\">function print() {\n  console.log(&#39;this: &#39;, this);\n  console.log(&#39;this.fullname: &#39;, this.fullname);\n}\n\nlet person1 = {\n  fullname: &#39;홍길동&#39;,\n};\nlet person2 = {\n  fullname: &#39;김길동&#39;,\n};\nlet bindPrint = print.bind(person1); // person1 객체로 바인딩\nbindPrint(); // person1\nlet bindPrint2 = bindPrint.bind(person2);\nbindPrint2(); // person1! bind는 단 한번만 할 수 있다.</code></pre>\n<h4 id=\"arrow-function-this\">Arrow Function this</h4>\n<hr>\n<ul>\n<li><p>화살표 함수가 나오기 전 까지는 함수는 어떻게 호출되는지에 따라 자신의 <code>this</code> 값을 정의했다.</p>\n</li>\n<li><p>하지만 화살표 함수는 자신을 포함하고 있는 외부 Scope에서 this를 계승받는다.</p>\n</li>\n</ul>\n<pre><code class=\"language-js\">let person = {\n  name: &#39;곽지욱&#39;,\n  printThis: function () {\n    console.log(this) //person 객체\n    setTimeout(() =&gt; {\n      console.log(this); // person 객체\n    });\n  },\n};</code></pre>\n<ul>\n<li>화살표 함수를 사용할 경우 나를 감싸고 있는 상위 스코프의 this를 계승받기 때문에 person 객체를 받는 것</li>\n</ul>\n<pre><code class=\"language-js\">let person = {\n    name: &#39;곽지욱&#39;,\n    printThis: () =&gt; {\n        console.log(this); // window 객체 출력\n    }\n};</code></pre>\n<ul>\n<li>그렇기에 위 경우에서는 상위 스코프가 전역 스코프이기 때문에 window 객체를 출력하는 것</li>\n</ul>\n<h4 id=\"strict-mode\">Strict Mode</h4>\n<hr>\n<ul>\n<li>엄격 모드에서는 호출한 놈이 없을 경우 기본값을 <code>window</code>로 하지 않고 <code>undefined</code>로 한다.</li>\n</ul>\n<pre><code class=\"language-js\">&#39;use strict&#39;;\nfunction printThis() {\n    console.log(this);\n}\nprintThis(); // undefined</code></pre>\n",
    "pubDate": "Mon, 12 Aug 2024 08:41:56 GMT",
    "thumbnail": null
  },
  {
    "title": "JS Object (객체)",
    "link": "https://velog.io/@gawgjiug/JS-Object-%EA%B0%9D%EC%B2%B4",
    "description": "<h3 id=\"object\">Object</h3>\n<hr>\n<ul>\n<li>객체는 연관된 데이터를 담는 그릇이다. 프리미티브 타입(Primitive Type)은 단 하나의 값만 나타낼 수 있고 불변이지만, 이와 달리 객체는 여러가지 값이나 복잡한 값을 나타낼 수 있으며 , 값(내용물)이 변할 수도 있음</li>\n</ul>\n<h4 id=\"객체구성\">객체구성</h4>\n<hr>\n<ul>\n<li>JS에서 객체는 키(key)와 값(value)으로 구성되어있다.</li>\n</ul>\n<pre><code class=\"language-js\">const person = {\n    name: &#39;곽지욱&#39;,\n    age: 24\n};\n// name이 키(key)이며, \n// &#39;곽지욱&#39;이 값(value)이다.</code></pre>\n<ul>\n<li>객체는 여러가지 값을 가질 수 있고, 객체가 가지고 있는 값을 <code>프로퍼티(Property)</code>라고 하며, 객체가 가지고 있는 함수를 <code>메서드</code> 라고함</li>\n</ul>\n<pre><code class=\"language-js\">const obj = {\n    name: &#39;곽지욱&#39;,    // name 프로퍼티\n    age: 20,         // age 프로퍼티\n    sayHello: function() {   // sayHello 메서드\n        console.log(&#39;Hello!&#39;);\n    },\n    sayHi() {  // 이렇게도 선언할 수 있다.\n        console.log(&#39;Hi!&#39;);\n    }\n};</code></pre>\n<h4 id=\"객체-프로퍼티-접근\">객체 프로퍼티 접근</h4>\n<hr>\n<ul>\n<li><p>객체 안에 있는 프로퍼티나 함수에 접근하기 위해서는 크게 두 가지 방법이있다.</p>\n</li>\n<li><p><code>점표기법</code> - <code>예) 객체.key</code></p>\n</li>\n</ul>\n<pre><code class=\"language-js\">person.name\nperson.age\nperson.gender\nperson.hello()\nperson.bobby.name\nperson.bobby.alert()</code></pre>\n<ul>\n<li>괄포 표기법 - <code>예) 객체[&#39;key&#39;]</code><pre><code class=\"language-js\">person[&#39;name&#39;]\nperson[&#39;age&#39;]\nperson[&#39;gender&#39;]\nperson[&#39;hello&#39;]()\nperson[&#39;hobby&#39;][&#39;name&#39;]\nperson[&#39;hobby&#39;][&#39;alert&#39;]()</code></pre>\n</li>\n</ul>\n<h4 id=\"함수-파라미터로-객체-전달하기\">함수 파라미터로 객체 전달하기</h4>\n<hr>\n<ul>\n<li>함수 파라미터로 객체를 전달하면 코드를 클린하게 만들 수 있다.</li>\n</ul>\n<p><code>Before</code></p>\n<pre><code class=\"language-js\">function printPerson(name, age, hobby) {\n  console.log(`제 이름은 ${name}이며, 나이는 ${age}살 입니다.그리고 취미는 ${hobby} 입니다.`);\n}\nprintPerson(&#39;곽지욱&#39;, 10, &#39;헬스&#39;);</code></pre>\n<p><code>After</code></p>\n<pre><code class=\"language-js\">function printPerson(person) {\n  console.log(`제 이름은 ${person.name}이며, 나이는 ${person.age}살 입니다.그리고 취미는 ${person.hobby} 입니다.`);\n}\n\nconst person = {\n  name: &#39;곽지욱&#39;,\n  age: 10,\n  hobby: &#39;헬스&#39;\n};\nprintPerson(person);</code></pre>\n<h4 id=\"구조-분해-할당\">구조 분해 할당</h4>\n<ul>\n<li>객체 속성을 개별 변수에 담을 때 변수의 순서가 아니라 key가 동일하는지가 중요하다.</li>\n</ul>\n<pre><code class=\"language-js\">const person = {\n  name: &#39;곽지욱&#39;,\n  age: 10,\n  hobby: &#39;헬스&#39;\n};\nconst { name, age, hobby } = person;</code></pre>\n<h4 id=\"팩토리-함수\">팩토리 함수</h4>\n<hr>\n<ul>\n<li>JS 로 같은 유형의 객체를 여러번 생성해야 할 때 사용하는 함수 생성 기법이다.<pre><code class=\"language-js\">const person1 = {\nname: &#39;곽지욱&#39;,\nage: 10,\nhobby: &#39;헬스&#39;\n};\nconst person2 = {\nname: &#39;홍길동&#39;,\nage: 20,\nhobby: &#39;축지법&#39;\n};\nconst person3 = {\nname: &#39;도깨비&#39;,\nage: 30,\nhobby: &#39;도술&#39;\n};\n...\nconst person10 = {\n...\n};</code></pre>\n</li>\n<li>이렇게 객체 리터럴로 반복적으로 생성하다 보면 코드의 반복도 많아지고 가독성도 그만큼 떨어짐 <code>팩토리 함수</code>를 사용해야함</li>\n</ul>\n<pre><code class=\"language-js\">function createPerson(name, age, hobby) {\n    return {\n        name: name,\n        age: age,\n        hobby: hobby\n    };\n};\n\nconst person1 = createPerson(&#39;곽지욱&#39;, 10, &#39;헬스&#39;);\nconst person2 = createPerson(&#39;홍길동&#39;, 20, &#39;헬스&#39;);\nconst person3 = createPerson(&#39;김길동&#39;, 30, &#39;헬스&#39;);\nconst person4 = createPerson(&#39;고길동&#39;, 40, &#39;헬스&#39;);\nconst person5 = createPerson(&#39;한길동&#39;, 50, &#39;헬스&#39;);\nconst person6 = createPerson(&#39;최길동&#39;, 60, &#39;헬스&#39;);</code></pre>\n<ul>\n<li>사실 여기서 정의 된 name,age,hobby 모두 key와 value가 동일하기 때문에 단축 속성명을 사용 할 수 있다. 단축 속성명은 key와 value를 각각 표기하지 않고 한번만 표기하는 것을 말함</li>\n</ul>\n<ul>\n<li>뿐만 아니라 클래스를 사용해서 객체를 생성할 수도 있다.</li>\n</ul>\n<pre><code class=\"language-js\">class Person {\n  constructor(name, age, hobby) {\n    this.name = name;\n        this.age = age;\n        this.hobby = hobby;\n  }\n}\nconst person = new Person(&#39;곽지욱&#39;, 20, &#39;헬스&#39;);\nconsole.log(person)</code></pre>\n<h4 id=\"참조타입-reference-type\">참조타입 (Reference type)</h4>\n<hr>\n<ul>\n<li><p>프리미티브 타입이 아닌 것들은 객체타입 또는 참조타입이라고 한다.</p>\n</li>\n<li><p>프리미티브 타입 값을 다른 변수에 할당하면 값 자체를 넘겨주는 것이기 때문에 값의 원형이 변경되진 않는다.</p>\n</li>\n</ul>\n<pre><code class=\"language-js\">let str1 = &#39;hello&#39;;\nlet str2 = str1;\nstr2 = &#39;world&#39;;\nconsole.log(&#39;str1: &#39;, str1);  // str1:  hello\nconsole.log(&#39;str2: &#39;, str2);  // str2:  world</code></pre>\n<ul>\n<li>하지만 객체 타입을 다른 변수에 할당하면 참조값이 할당 되기 때문에 할당 받은 변수에서 속성을 변경하면 값의 원형이 변경된다.</li>\n</ul>\n<pre><code class=\"language-js\">let obj1 = { name: &#39;곽지욱&#39;, age: 20 };\nlet obj2 = obj1;\nobj2.age = 30;\nobj2.hobby = &#39;헬스&#39;;\nconsole.log(&#39;obj1: &#39;, obj1);  // obj1:  {name: &#39;곽지욱&#39;, age: 30, hobby: &#39;헬스&#39;}\nconsole.log(&#39;obj2: &#39;, obj2);  // obj2:  {name: &#39;곽지욱&#39;, age: 30, hobby: &#39;헬스&#39;}</code></pre>\n<h4 id=\"call-by-value-vs-call-by-reference\">Call By Value vs Call By Reference</h4>\n<hr>\n<ul>\n<li>함수 호출시에 파라미터로 프리미티브 타입을 넘기는 것과 객체 타입을 넘기는 것은 차이가 있다.</li>\n</ul>\n<pre><code class=\"language-js\">function changeName(username) {\n    username = &#39;홍길동&#39;;\n}\nconst name = &#39;GYMCODING&#39;;\nchangeName(name);\nconsole.log(&#39;name: &#39;, name); // name:  GYMCODING</code></pre>\n<p><code>Call by Value</code> 는 값 자체를 username에 할당하기 때문에 username 값을 변경해도 함수밖의 name은 변경되지 않는다. 즉 값이 복사된 것.</p>\n<ul>\n<li>Call By Reference (참조에 의한 호출)</li>\n</ul>\n<pre><code class=\"language-js\">function changeName(people) {\n    people.name = &#39;홍길동&#39;;\n}\nconst person = { name: &#39;GYMCODING&#39; };\nchangeName(person);\nconsole.log(&#39;name: &#39;, person.name);  // name:  홍길동</code></pre>\n<ul>\n<li>Call By Reference 는 값 자체가 아니라 값을 가리키는 참조 값을 people에 할당 했기 때문에 people과 person이 가리키고 있는 값은 같다.</li>\n</ul>\n<h4 id=\"spread-operator-전개-구문\">Spread operator (전개 구문)</h4>\n<ul>\n<li>Spread는 펼치다 라는 뜻 <code>...</code> 표기법을 사용하여 사용할 수 있다.</li>\n</ul>\n<pre><code class=\"language-js\">let obj = {\n    name: &#39;곽지욱&#39;,\n    age: 20\n};\nlet person = {\n    ...obj,\n    hobby: &#39;헬스&#39;\n};\nconsole.log(&#39;person: &#39;, person);\n// [출력]\n// person:  {name: &#39;곽지욱&#39;, age: 20, hobby: &#39;헬스&#39;}</code></pre>\n<h4 id=\"forin\">for...in</h4>\n<hr>\n<ul>\n<li>객체에 있는 키 항목들을 반복적으로 반환한다.</li>\n</ul>\n<pre><code class=\"language-js\">const person = {\n    name: &#39;홍길동&#39;,\n    age: 20,\n    job: &#39;개발자&#39;\n};\nfor (let key in person) {\n    console.log(`key: ${key}, value: ${person[key]}`);\n}\n// [출력]\n// key: name, value: 홍길동\n// key: age, value: 20\n// key: job, value: 개발자\n</code></pre>\n<h4 id=\"키-존재-여부-확인\">키 존재 여부 확인</h4>\n<hr>\n<ul>\n<li>in operator - key in object</li>\n</ul>\n<pre><code class=\"language-js\">const person = {\n  name: &#39;곽지욱&#39;,\n};\nconsole.log(&#39;name&#39; in person)  // true\nconsole.log(&#39;age&#39; in person)   // true\n\nif (&#39;name&#39; in person) {\n  console.log(&#39;이름이 정의되어 있습니다.&#39;);\n}</code></pre>\n",
    "pubDate": "Mon, 12 Aug 2024 06:08:58 GMT",
    "thumbnail": null
  },
  {
    "title": "JS 배열",
    "link": "https://velog.io/@gawgjiug/JS-%EB%B0%B0%EC%97%B4",
    "description": "<h3 id=\"구조-분해-할당\">구조 분해 할당</h3>\n<ul>\n<li><p>구조 분해 할당 문법은 <strong>배열이나 객체의 속성을 해체</strong> 하여 그 값을 개별 변수에 담을 수 있게 하는 자바스크립트 표현식을 말한다.</p>\n</li>\n<li><p>일반 - 배열 항목을 개별 변수에 담을 때</p>\n</li>\n</ul>\n<pre><code class=\"language-js\">const fruits = [&#39;사과&#39;, &#39;바나나&#39;, &#39;딸기&#39;];\nconst apple = fruits[0];\nconst banana = fruits[1];\nconst strawberry = fruits[2];</code></pre>\n<ul>\n<li>구조 분해 할당 - 배열 항목을 개별 변수에 담을 때</li>\n</ul>\n<pre><code class=\"language-js\">const fruits = [&#39;사과&#39;, &#39;바나나&#39;, &#39;딸기&#39;, &#39;수박&#39;];\nconst [apple, ...others]  = fruits;\nconsole.log(apple);  // 사과\nconsole.log(others); // [&#39;바나나&#39;, &#39;딸기&#39;, &#39;수박&#39;]</code></pre>\n<h3 id=\"spread-syntax-전개구문\">Spread syntax (전개구문)</h3>\n<ul>\n<li>Spread는 펼치다라는 뜻으로, <code>Spread syntax</code>는 배열을 할당할 때 참조 값을 할당 하는게 아닌 배열안의 항목을 펼치는 방식으로 할당할 수 있다.</li>\n</ul>\n<pre><code class=\"language-js\">let arr = [1, &#39;two&#39;, 3, &#39;four&#39;];\nlet numberArr = [...arr, 5, &#39;six&#39;];\nconsole.log(&#39;numberArr: &#39;, numberArr);\n// [출력]\n// numberArr:  (6) [1, &#39;two&#39;, 3, &#39;four&#39;, 5, &#39;six&#39;]</code></pre>\n<h3 id=\"rest-parameters\">Rest parameters</h3>\n<ul>\n<li>나머지 매개변수 구문(Rest parameters)를 사용하면 함수가 무한한 수의 파라미터를 배열로 받을 수 있다.</li>\n</ul>\n<pre><code class=\"language-js\">function printFruits(...fruits) {\n    console.log(&#39;fruits: &#39;, fruits);\n}\nfunction printTitleAndFruits(title, ...fruits) {\n    console.log(&#39;title:&#39; , title);\n    console.log(&#39;fruits: &#39;, fruits);\n}\nprintFruits(&#39;사과&#39;, &#39;바나나&#39;, &#39;딸기&#39;);\nprintFruits(&#39;사과&#39;, &#39;바나나&#39;, &#39;딸기&#39;, &#39;포도&#39;);\nprintTitleAndFruits(&#39;과일출력&#39;, &#39;사과&#39;, &#39;바나나&#39;, &#39;딸기&#39;, &#39;포도&#39;);</code></pre>\n<h3 id=\"배열-복사하기\">배열 복사하기</h3>\n<ul>\n<li>배열은 객체이기 때문에 당연히 참조 값을 가지고 있고 <code>얇은 복사</code> 를 할 경우에는 하나의 배열을 변경하면 다른 배열도 같은 메모리 참조 값을 가지고 있기 때문에 결국에는 함께 변경이 된다</li>\n</ul>\n<pre><code class=\"language-js\">const fruits = [&#39;오렌지&#39;, &#39;포도&#39;, &#39;사과&#39;, &#39;바나나&#39;, &#39;딸기&#39;];\nconst copy = fruits;\ncopy.pop();                        // 끝에 항목 제거\nconsole.log(&#39;fruits: &#39;, fruits);   // [&#39;오렌지&#39;, &#39;포도&#39;, &#39;사과&#39;, &#39;바나나&#39;]\nconsole.log(&#39;copyFruits: &#39;, copy); // [&#39;오렌지&#39;, &#39;포도&#39;, &#39;사과&#39;, &#39;바나나&#39;]</code></pre>\n<ul>\n<li>전개 구문을 사용해서 <code>deep copy</code> 문법을 사용하면 해당 원본에 값만 가져오기 때문에 하나의 배열을 변경해도 별개로서 존재한다.</li>\n</ul>\n<pre><code class=\"language-js\">const fruits = [&#39;오렌지&#39;, &#39;포도&#39;, &#39;사과&#39;, &#39;바나나&#39;, &#39;딸기&#39;];\nconst copy = [...fruits];\ncopy.pop();                        // 끝에 항목 제거\nconsole.log(&#39;fruits: &#39;, fruits);   // [&#39;오렌지&#39;, &#39;포도&#39;, &#39;사과&#39;, &#39;바나나&#39;, &#39;딸기&#39;]\nconsole.log(&#39;copyFruits: &#39;, copy); // [&#39;오렌지&#39;, &#39;포도&#39;, &#39;사과&#39;, &#39;바나나&#39;]</code></pre>\n<ul>\n<li>혹은 Array.from () 메서드를 이용해도 된다.</li>\n</ul>\n<pre><code class=\"language-js\">const fruits = [&#39;오렌지&#39;, &#39;포도&#39;, &#39;사과&#39;, &#39;바나나&#39;, &#39;딸기&#39;];\nconst copy = Array.from(fruits);\ncopy.pop();                        // 끝에 항목 제거\nconsole.log(&#39;fruits: &#39;, fruits);   // [&#39;오렌지&#39;, &#39;포도&#39;, &#39;사과&#39;, &#39;바나나&#39;, &#39;딸기&#39;]\nconsole.log(&#39;copyFruits: &#39;, copy); // [&#39;오렌지&#39;, &#39;포도&#39;, &#39;사과&#39;, &#39;바나나&#39;]</code></pre>\n",
    "pubDate": "Fri, 09 Aug 2024 05:26:32 GMT",
    "thumbnail": null
  },
  {
    "title": "Reset.css VS Nomalize.css",
    "link": "https://velog.io/@gawgjiug/Reset.css-VS-Nomalize.css",
    "description": "<h3 id=\"resetcss-vs-nomalizecss\">Reset.css VS Nomalize.css</h3>\n<hr>\n<ul>\n<li><p><code>reset.css</code> 는 브라우저의 기본 스타일을 완전히 제거하여 모든 브라우저 환경에서 동일한 스타일을 제공할 수 있도록 설계된 CSS 파일을 말한다.</p>\n</li>\n<li><p>이 파일은 다양한 HTML 요소의 기본 스타일을 리셋하여, 스타일링을 새로 시작할 수 있는 깨끗한 상태를 제공한다.</p>\n</li>\n<li><p>쉽게 생각해보자. chrome,safari,ie 등 각 브라우저마다 HTML 요소의 기본 스타일을 가지고 있기 때문에, CSS 로 스타일링을 적용할 때 이러한 특징이</p>\n</li>\n<li><p>동일한 스타일 적용을 방해할 수 있다. 때문에 이를 해결하기 위해서 기본 스타일을 <code>백지</code>로 만들기 위한 초기화 기법이라고 생각하면 된다.</p>\n</li>\n</ul>\n<hr>\n<h4 id=\"resetcss\">Reset.css</h4>\n<ul>\n<li><code>Eric Meyer CSS Reset</code> : 말 그대로 Eric Meyer가 만든 CSS Reset 파일이다.</li>\n</ul>\n<blockquote>\n<p>기본 HTML 페이지 (Reset 전)</p>\n</blockquote>\n<pre><code class=\"language-html\">&lt;!DOCTYPE html&gt;\n&lt;html lang=&quot;en&quot;&gt;\n&lt;head&gt;\n    &lt;meta charset=&quot;UTF-8&quot;&gt;\n    &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;\n    &lt;title&gt;Before CSS Reset&lt;/title&gt;\n    &lt;style&gt;\n        /* 기본 스타일 */\n        body {\n            font-family: Arial, sans-serif;\n            background-color: #f4f4f4;\n            color: #333;\n            margin: 20px;\n        }\n\n        h1 {\n            font-size: 2em;\n            margin-bottom: 0.5em;\n        }\n\n        p {\n            line-height: 1.6;\n            margin: 0 0 1em;\n        }\n\n        ul {\n            padding: 0;\n            list-style-type: disc;\n        }\n    &lt;/style&gt;\n&lt;/head&gt;\n&lt;body&gt;\n    &lt;h1&gt;제목&lt;/h1&gt;\n    &lt;p&gt;내용&lt;/p&gt;\n    &lt;ul&gt;\n        &lt;li&gt;List item 1&lt;/li&gt;\n        &lt;li&gt;List item 2&lt;/li&gt;\n    &lt;/ul&gt;\n&lt;/body&gt;\n&lt;/html&gt;</code></pre>\n<p><img src=\"https://github.com/user-attachments/assets/b7b8bebd-e023-4aa6-8f94-917615ad81d5\" alt=\"image\"></p>\n<blockquote>\n<p>Eric Meyer&#39;s CSS Reset 적용 후</p>\n</blockquote>\n<pre><code class=\"language-css\">/* Eric Meyer’s CSS Reset */\nhtml, body, div, span, applet, object, iframe,\nh1, h2, h3, h4, h5, h6, p, blockquote, pre,\na, abbr, acronym, address, big, cite, code,\ndel, dfn, em, font, img, ins, kbd, q, s, samp,\nsmall, strike, strong, sub, sup, tt, var,\nb, u, i, center,\ndl, dt, dd,\nol, ul, li,\nfieldset, form, label, legend,\ntable, caption, tbody, tfoot, thead, tr, th, td {\n  margin: 0;\n  padding: 0;\n  border: 0;\n  font-size: 100%;\n  font: inherit;\n  vertical-align: baseline;\n}\n\narticle, aside, details, figcaption, figure,\nfooter, header, hgroup, main, mark, nav, section,\nsummary {\n  display: block;\n}\n\nbody {\n  line-height: 1;\n}</code></pre>\n<p><img src=\"https://github.com/user-attachments/assets/274f4607-bcf3-4068-9712-e7d61c47228a\" alt=\"image\"></p>\n<ul>\n<li>속성이 초기화 되어 body에 기본으로 설정된 8px의 여백이 사라지고 Heading 태그는 모두 동일한 크기로 나오게 된다.</li>\n</ul>\n<hr>\n<h4 id=\"css-normalize\">CSS Normalize</h4>\n<ul>\n<li><p>다음은 <code>CSS Normalize</code> 이다 CSS Reset 과의 차이점은 CSS Reset은 모든 속성 값을 0으로 초기화하는 방식이라면, CSS Normalize는 모든 값을 0으로 초기화 하는 것이 아니라</p>\n</li>\n<li><p>필요한 부분은 유지하면서, 서로 다른 브라우저 간의 스타일 차이를 최소화 하는 CSS 파일을 말한다. 기본적인 브라우저 스타일을 유지하면서도 일관된 스타일을 보장하려고 한다.</p>\n<pre><code class=\"language-html\">&lt;!DOCTYPE html&gt;\n&lt;html lang=&quot;en&quot;&gt;\n&lt;head&gt;\n  &lt;meta charset=&quot;UTF-8&quot;&gt;\n  &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;\n  &lt;title&gt;Before CSS Reset&lt;/title&gt;\n  &lt;link rel=&quot;stylesheet&quot; href=&quot;normalize.css&quot;&gt;\n  &lt;style&gt;\n/* Normalize.css*/\nhtml {\n  line-height: 1.15; /* 1 */\n  -webkit-text-size-adjust: 100%; /* 2 */\n}\nbody {\n  margin: 0;\n}\nmain {\n  display: block;\n}\nh1 {\n  font-size: 2em;\n  margin: 0.67em 0;\n}\nhr {\n  box-sizing: content-box; /* 1 */\n  height: 0; /* 1 */\n  overflow: visible; /* 2 */\n}\npre {\n  font-family: monospace, monospace; /* 1 */\n  font-size: 1em; /* 2 */\n}\n\na {\n  background-color: transparent;\n}\n  &lt;/style&gt;\n&lt;/head&gt;\n&lt;body&gt;\n  &lt;div class=&quot;App&quot;&gt;\n      &lt;div class=&quot;Box&quot;&gt;&lt;/div&gt;\n      &lt;h1&gt;이건 Heading 1&lt;/h1&gt;\n      &lt;h2&gt;이건 Heading 2&lt;/h2&gt;\n      &lt;h3&gt;이건 Heading 3&lt;/h3&gt;\n      &lt;p&gt;요건 P&lt;/p&gt;\n  &lt;/div&gt;\n&lt;/body&gt;\n&lt;/html&gt;</code></pre>\n</li>\n</ul>\n<pre><code class=\"language-css\">.Box {\n    background-color: #4285F4;\n    height: 100px;\n    width: 100px;\n    border: 3px solid;\n  }</code></pre>\n<p><img src=\"https://github.com/user-attachments/assets/775cfd48-2295-46d4-ae2d-4120010bf135\" alt=\"image\"></p>\n<ul>\n<li>CSS Reset과 같이 여백은 사라졌지만 Heading 태그는 살아있는 모습을 볼 수 있다.</li>\n</ul>\n<p><a href=\"https://github.com/necolas/normalize.css\">Normalize.css 원본 링크</a></p>\n<hr>\n<h3 id=\"css-reset\">CSS Reset</h3>\n<ul>\n<li><p>CSS Reset은 웹 개발자가 완전히 사용자 정의 스타일을 적용하고 싶을 때 유용하게 쓸 수 있으며, 모든 브라우저에서 동일한 출발점을 제공한다.</p>\n</li>\n<li><p>즉, 기본 스타일을 제거하고 새로 스타일을 정의해야 하는 경우 CSS Reset이 유용한 것.</p>\n</li>\n<li><p>모든 브라우저에서 스타일이 동일하게 보장되므로,  디자인의 일관성을 유지할 수 있다는 단점이 있지만, 작업량이 많아진다.. </p>\n</li>\n</ul>\n<h3 id=\"nomalizecss\">Nomalize.css</h3>\n<ul>\n<li><p>Nomalize.css 는 브라우저 간 기본 스타일 차이를 최소화하고, 일관된 스타일을 제공하고자 할 때 유용하다. 기본 스타일이 그대로 유지되므로, 특정 디자인 요구 사항을 충족 시키기 어려울 수 있음</p>\n</li>\n<li><p>즉, 특정 디자인 가이드라인이 존재하는 팀 혹은 프로젝트 요구 사항이 있을 경우 CSS Reset을 선택할 수 있지만,</p>\n</li>\n<li><p>대부분 <code>Normalize.css</code> 를 선호한다. 기본 스타일을 일부 유지하면서도 브라우저 간 일관성을 유지할 수 있기 때문이다.</p>\n</li>\n</ul>\n<h3 id=\"한줄요약\">한줄요약</h3>\n<ul>\n<li><p><code>reset CSS</code> 는 CSS의 style을 초기화 시키는 것이라면,</p>\n</li>\n<li><p><code>normalize CSS</code> 는 브라우저의 사용하기 좋은 기본값은 유지하면서 브라우저간의 차이점을 수정하는 코드이다.</p>\n</li>\n</ul>\n",
    "pubDate": "Tue, 06 Aug 2024 06:41:13 GMT",
    "thumbnail": null
  }
]