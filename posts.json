[
  {
    "title": "JS Object (객체)",
    "link": "https://velog.io/@gawgjiug/JS-Object-%EA%B0%9D%EC%B2%B4",
    "description": "<h3 id=\"object\">Object</h3>\n<hr>\n<ul>\n<li>객체는 연관된 데이터를 담는 그릇이다. 프리미티브 타입(Primitive Type)은 단 하나의 값만 나타낼 수 있고 불변이지만, 이와 달리 객체는 여러가지 값이나 복잡한 값을 나타낼 수 있으며 , 값(내용물)이 변할 수도 있음</li>\n</ul>\n<h4 id=\"객체구성\">객체구성</h4>\n<hr>\n<ul>\n<li>JS에서 객체는 키(key)와 값(value)으로 구성되어있다.</li>\n</ul>\n<pre><code class=\"language-js\">const person = {\n    name: &#39;곽지욱&#39;,\n    age: 24\n};\n// name이 키(key)이며, \n// &#39;곽지욱&#39;이 값(value)이다.</code></pre>\n<ul>\n<li>객체는 여러가지 값을 가질 수 있고, 객체가 가지고 있는 값을 <code>프로퍼티(Property)</code>라고 하며, 객체가 가지고 있는 함수를 <code>메서드</code> 라고함</li>\n</ul>\n<pre><code class=\"language-js\">const obj = {\n    name: &#39;곽지욱&#39;,    // name 프로퍼티\n    age: 20,         // age 프로퍼티\n    sayHello: function() {   // sayHello 메서드\n        console.log(&#39;Hello!&#39;);\n    },\n    sayHi() {  // 이렇게도 선언할 수 있다.\n        console.log(&#39;Hi!&#39;);\n    }\n};</code></pre>\n<h4 id=\"객체-프로퍼티-접근\">객체 프로퍼티 접근</h4>\n<hr>\n<ul>\n<li><p>객체 안에 있는 프로퍼티나 함수에 접근하기 위해서는 크게 두 가지 방법이있다.</p>\n</li>\n<li><p><code>점표기법</code> - <code>예) 객체.key</code></p>\n</li>\n</ul>\n<pre><code class=\"language-js\">person.name\nperson.age\nperson.gender\nperson.hello()\nperson.bobby.name\nperson.bobby.alert()</code></pre>\n<ul>\n<li>괄포 표기법 - <code>예) 객체[&#39;key&#39;]</code><pre><code class=\"language-js\">person[&#39;name&#39;]\nperson[&#39;age&#39;]\nperson[&#39;gender&#39;]\nperson[&#39;hello&#39;]()\nperson[&#39;hobby&#39;][&#39;name&#39;]\nperson[&#39;hobby&#39;][&#39;alert&#39;]()</code></pre>\n</li>\n</ul>\n<h4 id=\"함수-파라미터로-객체-전달하기\">함수 파라미터로 객체 전달하기</h4>\n<hr>\n<ul>\n<li>함수 파라미터로 객체를 전달하면 코드를 클린하게 만들 수 있다.</li>\n</ul>\n<p><code>Before</code></p>\n<pre><code class=\"language-js\">function printPerson(name, age, hobby) {\n  console.log(`제 이름은 ${name}이며, 나이는 ${age}살 입니다.그리고 취미는 ${hobby} 입니다.`);\n}\nprintPerson(&#39;곽지욱&#39;, 10, &#39;헬스&#39;);</code></pre>\n<p><code>After</code></p>\n<pre><code class=\"language-js\">function printPerson(person) {\n  console.log(`제 이름은 ${person.name}이며, 나이는 ${person.age}살 입니다.그리고 취미는 ${person.hobby} 입니다.`);\n}\n\nconst person = {\n  name: &#39;곽지욱&#39;,\n  age: 10,\n  hobby: &#39;헬스&#39;\n};\nprintPerson(person);</code></pre>\n<h4 id=\"구조-분해-할당\">구조 분해 할당</h4>\n<ul>\n<li>객체 속성을 개별 변수에 담을 때 변수의 순서가 아니라 key가 동일하는지가 중요하다.</li>\n</ul>\n<pre><code class=\"language-js\">const person = {\n  name: &#39;곽지욱&#39;,\n  age: 10,\n  hobby: &#39;헬스&#39;\n};\nconst { name, age, hobby } = person;</code></pre>\n<h4 id=\"팩토리-함수\">팩토리 함수</h4>\n<hr>\n<ul>\n<li>JS 로 같은 유형의 객체를 여러번 생성해야 할 때 사용하는 함수 생성 기법이다.<pre><code class=\"language-js\">const person1 = {\nname: &#39;곽지욱&#39;,\nage: 10,\nhobby: &#39;헬스&#39;\n};\nconst person2 = {\nname: &#39;홍길동&#39;,\nage: 20,\nhobby: &#39;축지법&#39;\n};\nconst person3 = {\nname: &#39;도깨비&#39;,\nage: 30,\nhobby: &#39;도술&#39;\n};\n...\nconst person10 = {\n...\n};</code></pre>\n</li>\n<li>이렇게 객체 리터럴로 반복적으로 생성하다 보면 코드의 반복도 많아지고 가독성도 그만큼 떨어짐 <code>팩토리 함수</code>를 사용해야함</li>\n</ul>\n<pre><code class=\"language-js\">function createPerson(name, age, hobby) {\n    return {\n        name: name,\n        age: age,\n        hobby: hobby\n    };\n};\n\nconst person1 = createPerson(&#39;곽지욱&#39;, 10, &#39;헬스&#39;);\nconst person2 = createPerson(&#39;홍길동&#39;, 20, &#39;헬스&#39;);\nconst person3 = createPerson(&#39;김길동&#39;, 30, &#39;헬스&#39;);\nconst person4 = createPerson(&#39;고길동&#39;, 40, &#39;헬스&#39;);\nconst person5 = createPerson(&#39;한길동&#39;, 50, &#39;헬스&#39;);\nconst person6 = createPerson(&#39;최길동&#39;, 60, &#39;헬스&#39;);</code></pre>\n<ul>\n<li>사실 여기서 정의 된 name,age,hobby 모두 key와 value가 동일하기 때문에 단축 속성명을 사용 할 수 있다. 단축 속성명은 key와 value를 각각 표기하지 않고 한번만 표기하는 것을 말함</li>\n</ul>\n<ul>\n<li>뿐만 아니라 클래스를 사용해서 객체를 생성할 수도 있다.</li>\n</ul>\n<pre><code class=\"language-js\">class Person {\n  constructor(name, age, hobby) {\n    this.name = name;\n        this.age = age;\n        this.hobby = hobby;\n  }\n}\nconst person = new Person(&#39;곽지욱&#39;, 20, &#39;헬스&#39;);\nconsole.log(person)</code></pre>\n<h4 id=\"참조타입-reference-type\">참조타입 (Reference type)</h4>\n<hr>\n<ul>\n<li><p>프리미티브 타입이 아닌 것들은 객체타입 또는 참조타입이라고 한다.</p>\n</li>\n<li><p>프리미티브 타입 값을 다른 변수에 할당하면 값 자체를 넘겨주는 것이기 때문에 값의 원형이 변경되진 않는다.</p>\n</li>\n</ul>\n<pre><code class=\"language-js\">let str1 = &#39;hello&#39;;\nlet str2 = str1;\nstr2 = &#39;world&#39;;\nconsole.log(&#39;str1: &#39;, str1);  // str1:  hello\nconsole.log(&#39;str2: &#39;, str2);  // str2:  world</code></pre>\n<ul>\n<li>하지만 객체 타입을 다른 변수에 할당하면 참조값이 할당 되기 때문에 할당 받은 변수에서 속성을 변경하면 값의 원형이 변경된다.</li>\n</ul>\n<pre><code class=\"language-js\">let obj1 = { name: &#39;곽지욱&#39;, age: 20 };\nlet obj2 = obj1;\nobj2.age = 30;\nobj2.hobby = &#39;헬스&#39;;\nconsole.log(&#39;obj1: &#39;, obj1);  // obj1:  {name: &#39;곽지욱&#39;, age: 30, hobby: &#39;헬스&#39;}\nconsole.log(&#39;obj2: &#39;, obj2);  // obj2:  {name: &#39;곽지욱&#39;, age: 30, hobby: &#39;헬스&#39;}</code></pre>\n<h4 id=\"call-by-value-vs-call-by-reference\">Call By Value vs Call By Reference</h4>\n<hr>\n<ul>\n<li>함수 호출시에 파라미터로 프리미티브 타입을 넘기는 것과 객체 타입을 넘기는 것은 차이가 있다.</li>\n</ul>\n<pre><code class=\"language-js\">function changeName(username) {\n    username = &#39;홍길동&#39;;\n}\nconst name = &#39;GYMCODING&#39;;\nchangeName(name);\nconsole.log(&#39;name: &#39;, name); // name:  GYMCODING</code></pre>\n<p><code>Call by Value</code> 는 값 자체를 username에 할당하기 때문에 username 값을 변경해도 함수밖의 name은 변경되지 않는다. 즉 값이 복사된 것.</p>\n<ul>\n<li>Call By Reference (참조에 의한 호출)</li>\n</ul>\n<pre><code class=\"language-js\">function changeName(people) {\n    people.name = &#39;홍길동&#39;;\n}\nconst person = { name: &#39;GYMCODING&#39; };\nchangeName(person);\nconsole.log(&#39;name: &#39;, person.name);  // name:  홍길동</code></pre>\n<ul>\n<li>Call By Reference 는 값 자체가 아니라 값을 가리키는 참조 값을 people에 할당 했기 때문에 people과 person이 가리키고 있는 값은 같다.</li>\n</ul>\n<h4 id=\"spread-operator-전개-구문\">Spread operator (전개 구문)</h4>\n<ul>\n<li>Spread는 펼치다 라는 뜻 <code>...</code> 표기법을 사용하여 사용할 수 있다.</li>\n</ul>\n<pre><code class=\"language-js\">let obj = {\n    name: &#39;곽지욱&#39;,\n    age: 20\n};\nlet person = {\n    ...obj,\n    hobby: &#39;헬스&#39;\n};\nconsole.log(&#39;person: &#39;, person);\n// [출력]\n// person:  {name: &#39;곽지욱&#39;, age: 20, hobby: &#39;헬스&#39;}</code></pre>\n<h4 id=\"forin\">for...in</h4>\n<hr>\n<ul>\n<li>객체에 있는 키 항목들을 반복적으로 반환한다.</li>\n</ul>\n<pre><code class=\"language-js\">const person = {\n    name: &#39;홍길동&#39;,\n    age: 20,\n    job: &#39;개발자&#39;\n};\nfor (let key in person) {\n    console.log(`key: ${key}, value: ${person[key]}`);\n}\n// [출력]\n// key: name, value: 홍길동\n// key: age, value: 20\n// key: job, value: 개발자\n</code></pre>\n<h4 id=\"키-존재-여부-확인\">키 존재 여부 확인</h4>\n<hr>\n<ul>\n<li>in operator - key in object</li>\n</ul>\n<pre><code class=\"language-js\">const person = {\n  name: &#39;곽지욱&#39;,\n};\nconsole.log(&#39;name&#39; in person)  // true\nconsole.log(&#39;age&#39; in person)   // true\n\nif (&#39;name&#39; in person) {\n  console.log(&#39;이름이 정의되어 있습니다.&#39;);\n}</code></pre>\n",
    "pubDate": "Mon, 12 Aug 2024 06:08:58 GMT",
    "thumbnail": null
  },
  {
    "title": "JS 배열",
    "link": "https://velog.io/@gawgjiug/JS-%EB%B0%B0%EC%97%B4",
    "description": "<h3 id=\"구조-분해-할당\">구조 분해 할당</h3>\n<ul>\n<li><p>구조 분해 할당 문법은 <strong>배열이나 객체의 속성을 해체</strong> 하여 그 값을 개별 변수에 담을 수 있게 하는 자바스크립트 표현식을 말한다.</p>\n</li>\n<li><p>일반 - 배열 항목을 개별 변수에 담을 때</p>\n</li>\n</ul>\n<pre><code class=\"language-js\">const fruits = [&#39;사과&#39;, &#39;바나나&#39;, &#39;딸기&#39;];\nconst apple = fruits[0];\nconst banana = fruits[1];\nconst strawberry = fruits[2];</code></pre>\n<ul>\n<li>구조 분해 할당 - 배열 항목을 개별 변수에 담을 때</li>\n</ul>\n<pre><code class=\"language-js\">const fruits = [&#39;사과&#39;, &#39;바나나&#39;, &#39;딸기&#39;, &#39;수박&#39;];\nconst [apple, ...others]  = fruits;\nconsole.log(apple);  // 사과\nconsole.log(others); // [&#39;바나나&#39;, &#39;딸기&#39;, &#39;수박&#39;]</code></pre>\n<h3 id=\"spread-syntax-전개구문\">Spread syntax (전개구문)</h3>\n<ul>\n<li>Spread는 펼치다라는 뜻으로, <code>Spread syntax</code>는 배열을 할당할 때 참조 값을 할당 하는게 아닌 배열안의 항목을 펼치는 방식으로 할당할 수 있다.</li>\n</ul>\n<pre><code class=\"language-js\">let arr = [1, &#39;two&#39;, 3, &#39;four&#39;];\nlet numberArr = [...arr, 5, &#39;six&#39;];\nconsole.log(&#39;numberArr: &#39;, numberArr);\n// [출력]\n// numberArr:  (6) [1, &#39;two&#39;, 3, &#39;four&#39;, 5, &#39;six&#39;]</code></pre>\n<h3 id=\"rest-parameters\">Rest parameters</h3>\n<ul>\n<li>나머지 매개변수 구문(Rest parameters)를 사용하면 함수가 무한한 수의 파라미터를 배열로 받을 수 있다.</li>\n</ul>\n<pre><code class=\"language-js\">function printFruits(...fruits) {\n    console.log(&#39;fruits: &#39;, fruits);\n}\nfunction printTitleAndFruits(title, ...fruits) {\n    console.log(&#39;title:&#39; , title);\n    console.log(&#39;fruits: &#39;, fruits);\n}\nprintFruits(&#39;사과&#39;, &#39;바나나&#39;, &#39;딸기&#39;);\nprintFruits(&#39;사과&#39;, &#39;바나나&#39;, &#39;딸기&#39;, &#39;포도&#39;);\nprintTitleAndFruits(&#39;과일출력&#39;, &#39;사과&#39;, &#39;바나나&#39;, &#39;딸기&#39;, &#39;포도&#39;);</code></pre>\n<h3 id=\"배열-복사하기\">배열 복사하기</h3>\n<ul>\n<li>배열은 객체이기 때문에 당연히 참조 값을 가지고 있고 <code>얇은 복사</code> 를 할 경우에는 하나의 배열을 변경하면 다른 배열도 같은 메모리 참조 값을 가지고 있기 때문에 결국에는 함께 변경이 된다</li>\n</ul>\n<pre><code class=\"language-js\">const fruits = [&#39;오렌지&#39;, &#39;포도&#39;, &#39;사과&#39;, &#39;바나나&#39;, &#39;딸기&#39;];\nconst copy = fruits;\ncopy.pop();                        // 끝에 항목 제거\nconsole.log(&#39;fruits: &#39;, fruits);   // [&#39;오렌지&#39;, &#39;포도&#39;, &#39;사과&#39;, &#39;바나나&#39;]\nconsole.log(&#39;copyFruits: &#39;, copy); // [&#39;오렌지&#39;, &#39;포도&#39;, &#39;사과&#39;, &#39;바나나&#39;]</code></pre>\n<ul>\n<li>전개 구문을 사용해서 <code>deep copy</code> 문법을 사용하면 해당 원본에 값만 가져오기 때문에 하나의 배열을 변경해도 별개로서 존재한다.</li>\n</ul>\n<pre><code class=\"language-js\">const fruits = [&#39;오렌지&#39;, &#39;포도&#39;, &#39;사과&#39;, &#39;바나나&#39;, &#39;딸기&#39;];\nconst copy = [...fruits];\ncopy.pop();                        // 끝에 항목 제거\nconsole.log(&#39;fruits: &#39;, fruits);   // [&#39;오렌지&#39;, &#39;포도&#39;, &#39;사과&#39;, &#39;바나나&#39;, &#39;딸기&#39;]\nconsole.log(&#39;copyFruits: &#39;, copy); // [&#39;오렌지&#39;, &#39;포도&#39;, &#39;사과&#39;, &#39;바나나&#39;]</code></pre>\n<ul>\n<li>혹은 Array.from () 메서드를 이용해도 된다.</li>\n</ul>\n<pre><code class=\"language-js\">const fruits = [&#39;오렌지&#39;, &#39;포도&#39;, &#39;사과&#39;, &#39;바나나&#39;, &#39;딸기&#39;];\nconst copy = Array.from(fruits);\ncopy.pop();                        // 끝에 항목 제거\nconsole.log(&#39;fruits: &#39;, fruits);   // [&#39;오렌지&#39;, &#39;포도&#39;, &#39;사과&#39;, &#39;바나나&#39;, &#39;딸기&#39;]\nconsole.log(&#39;copyFruits: &#39;, copy); // [&#39;오렌지&#39;, &#39;포도&#39;, &#39;사과&#39;, &#39;바나나&#39;]</code></pre>\n",
    "pubDate": "Fri, 09 Aug 2024 05:26:32 GMT",
    "thumbnail": null
  },
  {
    "title": "Reset.css VS Nomalize.css",
    "link": "https://velog.io/@gawgjiug/Reset.css-VS-Nomalize.css",
    "description": "<h3 id=\"resetcss-vs-nomalizecss\">Reset.css VS Nomalize.css</h3>\n<hr>\n<ul>\n<li><p><code>reset.css</code> 는 브라우저의 기본 스타일을 완전히 제거하여 모든 브라우저 환경에서 동일한 스타일을 제공할 수 있도록 설계된 CSS 파일을 말한다.</p>\n</li>\n<li><p>이 파일은 다양한 HTML 요소의 기본 스타일을 리셋하여, 스타일링을 새로 시작할 수 있는 깨끗한 상태를 제공한다.</p>\n</li>\n<li><p>쉽게 생각해보자. chrome,safari,ie 등 각 브라우저마다 HTML 요소의 기본 스타일을 가지고 있기 때문에, CSS 로 스타일링을 적용할 때 이러한 특징이</p>\n</li>\n<li><p>동일한 스타일 적용을 방해할 수 있다. 때문에 이를 해결하기 위해서 기본 스타일을 <code>백지</code>로 만들기 위한 초기화 기법이라고 생각하면 된다.</p>\n</li>\n</ul>\n<hr>\n<h4 id=\"resetcss\">Reset.css</h4>\n<ul>\n<li><code>Eric Meyer CSS Reset</code> : 말 그대로 Eric Meyer가 만든 CSS Reset 파일이다.</li>\n</ul>\n<blockquote>\n<p>기본 HTML 페이지 (Reset 전)</p>\n</blockquote>\n<pre><code class=\"language-html\">&lt;!DOCTYPE html&gt;\n&lt;html lang=&quot;en&quot;&gt;\n&lt;head&gt;\n    &lt;meta charset=&quot;UTF-8&quot;&gt;\n    &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;\n    &lt;title&gt;Before CSS Reset&lt;/title&gt;\n    &lt;style&gt;\n        /* 기본 스타일 */\n        body {\n            font-family: Arial, sans-serif;\n            background-color: #f4f4f4;\n            color: #333;\n            margin: 20px;\n        }\n\n        h1 {\n            font-size: 2em;\n            margin-bottom: 0.5em;\n        }\n\n        p {\n            line-height: 1.6;\n            margin: 0 0 1em;\n        }\n\n        ul {\n            padding: 0;\n            list-style-type: disc;\n        }\n    &lt;/style&gt;\n&lt;/head&gt;\n&lt;body&gt;\n    &lt;h1&gt;제목&lt;/h1&gt;\n    &lt;p&gt;내용&lt;/p&gt;\n    &lt;ul&gt;\n        &lt;li&gt;List item 1&lt;/li&gt;\n        &lt;li&gt;List item 2&lt;/li&gt;\n    &lt;/ul&gt;\n&lt;/body&gt;\n&lt;/html&gt;</code></pre>\n<p><img src=\"https://github.com/user-attachments/assets/b7b8bebd-e023-4aa6-8f94-917615ad81d5\" alt=\"image\"></p>\n<blockquote>\n<p>Eric Meyer&#39;s CSS Reset 적용 후</p>\n</blockquote>\n<pre><code class=\"language-css\">/* Eric Meyer’s CSS Reset */\nhtml, body, div, span, applet, object, iframe,\nh1, h2, h3, h4, h5, h6, p, blockquote, pre,\na, abbr, acronym, address, big, cite, code,\ndel, dfn, em, font, img, ins, kbd, q, s, samp,\nsmall, strike, strong, sub, sup, tt, var,\nb, u, i, center,\ndl, dt, dd,\nol, ul, li,\nfieldset, form, label, legend,\ntable, caption, tbody, tfoot, thead, tr, th, td {\n  margin: 0;\n  padding: 0;\n  border: 0;\n  font-size: 100%;\n  font: inherit;\n  vertical-align: baseline;\n}\n\narticle, aside, details, figcaption, figure,\nfooter, header, hgroup, main, mark, nav, section,\nsummary {\n  display: block;\n}\n\nbody {\n  line-height: 1;\n}</code></pre>\n<p><img src=\"https://github.com/user-attachments/assets/274f4607-bcf3-4068-9712-e7d61c47228a\" alt=\"image\"></p>\n<ul>\n<li>속성이 초기화 되어 body에 기본으로 설정된 8px의 여백이 사라지고 Heading 태그는 모두 동일한 크기로 나오게 된다.</li>\n</ul>\n<hr>\n<h4 id=\"css-normalize\">CSS Normalize</h4>\n<ul>\n<li><p>다음은 <code>CSS Normalize</code> 이다 CSS Reset 과의 차이점은 CSS Reset은 모든 속성 값을 0으로 초기화하는 방식이라면, CSS Normalize는 모든 값을 0으로 초기화 하는 것이 아니라</p>\n</li>\n<li><p>필요한 부분은 유지하면서, 서로 다른 브라우저 간의 스타일 차이를 최소화 하는 CSS 파일을 말한다. 기본적인 브라우저 스타일을 유지하면서도 일관된 스타일을 보장하려고 한다.</p>\n<pre><code class=\"language-html\">&lt;!DOCTYPE html&gt;\n&lt;html lang=&quot;en&quot;&gt;\n&lt;head&gt;\n  &lt;meta charset=&quot;UTF-8&quot;&gt;\n  &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;\n  &lt;title&gt;Before CSS Reset&lt;/title&gt;\n  &lt;link rel=&quot;stylesheet&quot; href=&quot;normalize.css&quot;&gt;\n  &lt;style&gt;\n/* Normalize.css*/\nhtml {\n  line-height: 1.15; /* 1 */\n  -webkit-text-size-adjust: 100%; /* 2 */\n}\nbody {\n  margin: 0;\n}\nmain {\n  display: block;\n}\nh1 {\n  font-size: 2em;\n  margin: 0.67em 0;\n}\nhr {\n  box-sizing: content-box; /* 1 */\n  height: 0; /* 1 */\n  overflow: visible; /* 2 */\n}\npre {\n  font-family: monospace, monospace; /* 1 */\n  font-size: 1em; /* 2 */\n}\n\na {\n  background-color: transparent;\n}\n  &lt;/style&gt;\n&lt;/head&gt;\n&lt;body&gt;\n  &lt;div class=&quot;App&quot;&gt;\n      &lt;div class=&quot;Box&quot;&gt;&lt;/div&gt;\n      &lt;h1&gt;이건 Heading 1&lt;/h1&gt;\n      &lt;h2&gt;이건 Heading 2&lt;/h2&gt;\n      &lt;h3&gt;이건 Heading 3&lt;/h3&gt;\n      &lt;p&gt;요건 P&lt;/p&gt;\n  &lt;/div&gt;\n&lt;/body&gt;\n&lt;/html&gt;</code></pre>\n</li>\n</ul>\n<pre><code class=\"language-css\">.Box {\n    background-color: #4285F4;\n    height: 100px;\n    width: 100px;\n    border: 3px solid;\n  }</code></pre>\n<p><img src=\"https://github.com/user-attachments/assets/775cfd48-2295-46d4-ae2d-4120010bf135\" alt=\"image\"></p>\n<ul>\n<li>CSS Reset과 같이 여백은 사라졌지만 Heading 태그는 살아있는 모습을 볼 수 있다.</li>\n</ul>\n<p><a href=\"https://github.com/necolas/normalize.css\">Normalize.css 원본 링크</a></p>\n<hr>\n<h3 id=\"css-reset\">CSS Reset</h3>\n<ul>\n<li><p>CSS Reset은 웹 개발자가 완전히 사용자 정의 스타일을 적용하고 싶을 때 유용하게 쓸 수 있으며, 모든 브라우저에서 동일한 출발점을 제공한다.</p>\n</li>\n<li><p>즉, 기본 스타일을 제거하고 새로 스타일을 정의해야 하는 경우 CSS Reset이 유용한 것.</p>\n</li>\n<li><p>모든 브라우저에서 스타일이 동일하게 보장되므로,  디자인의 일관성을 유지할 수 있다는 단점이 있지만, 작업량이 많아진다.. </p>\n</li>\n</ul>\n<h3 id=\"nomalizecss\">Nomalize.css</h3>\n<ul>\n<li><p>Nomalize.css 는 브라우저 간 기본 스타일 차이를 최소화하고, 일관된 스타일을 제공하고자 할 때 유용하다. 기본 스타일이 그대로 유지되므로, 특정 디자인 요구 사항을 충족 시키기 어려울 수 있음</p>\n</li>\n<li><p>즉, 특정 디자인 가이드라인이 존재하는 팀 혹은 프로젝트 요구 사항이 있을 경우 CSS Reset을 선택할 수 있지만,</p>\n</li>\n<li><p>대부분 <code>Normalize.css</code> 를 선호한다. 기본 스타일을 일부 유지하면서도 브라우저 간 일관성을 유지할 수 있기 때문이다.</p>\n</li>\n</ul>\n<h3 id=\"한줄요약\">한줄요약</h3>\n<ul>\n<li><p><code>reset CSS</code> 는 CSS의 style을 초기화 시키는 것이라면,</p>\n</li>\n<li><p><code>normalize CSS</code> 는 브라우저의 사용하기 좋은 기본값은 유지하면서 브라우저간의 차이점을 수정하는 코드이다.</p>\n</li>\n</ul>\n",
    "pubDate": "Tue, 06 Aug 2024 06:41:13 GMT",
    "thumbnail": null
  },
  {
    "title": "그리디 알고리즘 with 백준",
    "link": "https://velog.io/@gawgjiug/%EA%B7%B8%EB%A6%AC%EB%94%94-%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98-with-%EB%B0%B1%EC%A4%80",
    "description": "<h3 id=\"그리디-알고리즘greedy-alhorithm\">그리디 알고리즘(Greedy Alhorithm)</h3>\n<ul>\n<li><p>그리디 알고리즘이란?</p>\n</li>\n<li><p>최적의 값을 구해야 하는 상황에서 사용되는 근시안적인 방법론으로 &#39;각 단계에서 최적이라고 생각되는 것을 선택&#39; 해 나가는 방식으로 진행하여 최종적인 해답에 도달하는 알고리즘이다</p>\n</li>\n<li><p>이때, 항상 최적의 값을 보장하는 것이 아니라 사실은 최적의 값의 &#39;근사한 값&#39; 을 목표로 하고 있는 것</p>\n</li>\n<li><p>순간마다 하는 선택은 그 순간 기점으로 지역적으로 최적의 선택이지만, 그 선택들을 계속 수집하한 결과인 최종적(전역적)인 해답은 최적이라는 보장이 없음</p>\n</li>\n</ul>\n<h4 id=\"그리디-알고리즘-문제를-해결하는-방법\">그리디 알고리즘 문제를 해결하는 방법</h4>\n<p><strong>1. 선택 절차 : 현재 상태에서의 최적의 해답을 선택한다.</strong>\n<strong>2. 적절성 검사 : 선택된 해가 문제의 조건을 만족하는지 검사한다.</strong>\n<strong>3. 해답 검사 : 원래의 문제가 해결되었는지 검사하고, 해결되지 않았다면 선택 절차로 돌아가 위 과정 반복</strong></p>\n<h4 id=\"❗️탐욕-알고리즘을-일상-예시-1--매트로이드\">❗️탐욕 알고리즘을 일상 예시 1 – 매트로이드</h4>\n<ul>\n<li>물견 가격은 4040원 이고, 손님이 5,000원을 주며 거스름돈의 동전의 개수를 최소한으로 하여 거슬러 달라고 한다.</li>\n</ul>\n<h4 id=\"탐욕-알고리즘의-문제-해결-과정을-적용\">탐욕 알고리즘의 문제 해결 과정을 적용</h4>\n<ol>\n<li><p>선택 절차\n거스름돈의 동전 개수를 줄이기 위해 현재 가장 가치가 높은 동전을 우선 선택한다.</p>\n</li>\n<li><p>적절성 검사\n1번 과정을 통해 선택된 동전들의 합이 거슬러 줄 금액을 초과하는지 검사한다.\n초과하면 가장 마지막에 선택한 동전을 삭제하고, 1번으로 돌아가 한 단계 작은 동전을 선택한다.</p>\n</li>\n<li><p>해답 검사\n선택된 동전들의 합이 거슬러 줄 금액과 일치하는지 검사한다.\n액수가 부족하면 1번 과정부터 다시 반복한다.</p>\n</li>\n</ol>\n<h4 id=\"탐욕-알고리즘-문제-풀이-with-백준\">탐욕 알고리즘 문제 풀이 with 백준</h4>\n<p><a href=\"https://www.acmicpc.net/problem/1931\">백준 1931번: 회의실 배정</a></p>\n<p><img src=\"https://velog.velcdn.com/images/gawgjiug/post/26a38497-2a12-4a6a-a7fe-e475552e97b5/image.png\" alt=\"\"></p>\n<pre><code class=\"language-java\">\nimport java.util.Arrays;\nimport java.util.Comparator;\nimport java.util.Scanner;\n\npublic class Main {\n    public static void main(String[] args) {\n\n\n        //백줕 1931번\n\n        Scanner sc = new Scanner(System.in);\n\n        int N = sc.nextInt();\n\n        /*time[][0] 은 시작 지점을 의미\n        * time[][1] 은 종료 시점을 의미*/\n\n        int [][] time = new int[N][2];\n\n        for(int i = 0 ; i&lt;N; i++){\n            time[i][0] = sc.nextInt(); //시작\n            time[i][1] = sc.nextInt(); //종료\n        }\n\n        Arrays.sort(time, new Comparator&lt;int[]&gt;() {\n            @Override\n            public int compare(int[] o1, int[] o2) {\n                if(o1[1] == o2[1]){\n                    return o1[0] - o2[0]; //종료 시간이 같을 경우 시작 시간이 빠른 순으로 정렬\n                }\n                return o1[1] - o2[1];\n            }\n        });\n\n        int count =0;\n        int prev_end_time = 0;\n\n        for(int i = 0; i&lt;N; i++){\n            if (prev_end_time &lt;= time[i][0]){ //직전 종료시간이 다음 회의 시작 시간보다 작거나 같으면 갱신\n                prev_end_time = time[i][1];\n                count++;\n            }\n        }\n\n        System.out.println(count);\n\n\n    }\n}</code></pre>\n<ul>\n<li><p>회의의 시작시간과 종료시간 각각을 2차원 배열로 저장한다</p>\n</li>\n<li><p>Array.sort를 사용하여 회의 배열을 정렬, 정렬 기준은 종료시간 만약 종료 시간이 같은 회의가 있을 경우, 시작 시간이 빠른 순서로 정렬</p>\n</li>\n<li><p>직전 종료시간(5)이 다음 회의시작 시간(6or5) 보다 작거나 같으면 갱신한다.</p>\n</li>\n</ul>\n",
    "pubDate": "Mon, 05 Aug 2024 07:20:03 GMT",
    "thumbnail": null
  },
  {
    "title": "배열 Vs 연결리스트",
    "link": "https://velog.io/@gawgjiug/%EB%B0%B0%EC%97%B4-Vs-%EC%97%B0%EA%B2%B0%EB%A6%AC%EC%8A%A4%ED%8A%B8",
    "description": "<h3 id=\"array-vs-linkedlist\">Array VS LinkedList</h3>\n<hr>\n<p>Array 와 LinkedList의 비교이다.</p>\n<h4 id=\"array배열\">Array(배열)</h4>\n<p><img src=\"https://github.com/user-attachments/assets/2f9b35a2-f258-4bcd-8c22-2e3c47ba26dc\" alt=\"image\"></p>\n<ul>\n<li><p><code>구조</code> : 배열은 메모리 상에서 <code>연속적</code>으로 저장된다. 각 원소는 고정된 <code>크기</code>를 가지며, 논리적 저장 순서와 물리적 저장 순서가 일치한다.</p>\n</li>\n<li><p><code>메모리 할당</code> : 배열의 크기는 고정되고, 선언 시 컴파일 타임에 메모리 공간이 할당된다. 이로 인해 메모리의 동적 크기 조정이 불가능하다는 특징을 갖는다.</p>\n</li>\n<li><p><code>장점</code> : 메모리 접근이 간단하고 빠르다. 연속된 메모리 블록을 사용하므로 <a href=\"https://github.com/gawgjiug/Eureka_CS_Study/blob/main/OS/os_cache.md\">캐시</a> 효율성이 높다.</p>\n</li>\n<li><p><code>단점</code> : 크기를 미리 정해야 하며, 크기 조정이 불가능 하여 필요한 만큼의 공간을 정확히 예측해야 하고, 삽입 및 삭제 작업이 비효율적일 수 있다.</p>\n</li>\n</ul>\n<h4 id=\"linkedlist-연결리스트\">LinkedList (연결리스트)</h4>\n<p><img src=\"https://github.com/user-attachments/assets/9522a89a-7f0d-425c-9b77-3aa068b96f55\" alt=\"image\"></p>\n<ul>\n<li><p><code>구조</code> : 연결 리스트는 메모리 상에서 비연속적으로 저장된다. 각 노드는 데이터와 다음 노드에 대한 포인터를 포함하기 때문에, 논리적 저장 순서와 물리적 저장 순서가 다르다.</p>\n</li>\n<li><p><code>메모리 할당</code> : 각 노드는 데이터가 삽입 될 때 마다 동적으로 메모리 공간을 할당 받는다. 이로 인해 배열과 달리 크기 조정이 유연하다는 장점이 있다.</p>\n</li>\n<li><p><code>장점</code> : 삽입 및 삭제가 효율적이고, 메모리 공간을 동적으로 관리할 수 있다.</p>\n</li>\n<li><p><code>단점</code> : 메모리 접근이 비효율적일 수 있다. 배열 처럼 연속적인 메모리 주소를 할당 받지 않았기 때문에 <code>index</code> 를 이용하여 임의로 접근하는 것이 불가능하다.\n 말을 즉슨 <strong>데이터를 탐색할 때 순차적으로 접근해야 한다는 것이다</strong></p>\n</li>\n</ul>\n<h3 id=\"데이터-접근-속도\">데이터 접근 속도</h3>\n<h4 id=\"array-\">Array :</h4>\n<ul>\n<li><p><code>시간복잡도</code> : 배열은 접근과 탐색이 용이하다고 했는데, <code>index</code>를 가지고 있기 때문에 탐색은 $O(1)$ 의 시간복잡도를 가진다. <strong>삽입의 경우는 맨 뒤에 삽입 할 경우는 $O(1)$ 이고,\n나머지 상황에서는 $O(n)$ 이다.</strong></p>\n</li>\n<li><p><code>특징</code> : 랜덤 액세스가 가능하여 임의의 위치에 존재하는 원소를 즉시 조회할 수 있다.</p>\n</li>\n</ul>\n<h4 id=\"linkedlist-\">LinkedList :</h4>\n<ul>\n<li><p><code>시간복잡도</code> : $O(n)$. 특정 노드를 찾기 위해 처음부터 순차적으로 탐색해야 하므로 접근속도가 느린편이다.</p>\n</li>\n<li><p><code>특징</code> : 인덱스가 없기 때문에 원소 접근 시 전체 리스트를 순회해야한다.</p>\n</li>\n</ul>\n<hr>\n<h3 id=\"메모리-효율성\">메모리 효율성</h3>\n<ul>\n<li><p>Array :</p>\n</li>\n<li><p><code>메모리 사용</code> : 연속된 메모리 블록을 사용하기 때문에 메모리 오버헤드가 적다. 하지만 크기를 변경할 수 없기 때문에 메모리 낭비가 발생할 수 있음</p>\n</li>\n<li><p><code>장점</code> : 장점은 역시 <code>캐시 효율성</code>이다 . 데이터의 빠른 접근이 가능하다.</p>\n</li>\n</ul>\n<ul>\n<li><p>LinkedList :</p>\n</li>\n<li><p><code>메모리 사용</code> : 각 노드는 데이터와 추가적인 포인터를 저장해야 하므로 메모리 오버헤드가 큰편이다. 각 노드의 포인터가 추가로 필요</p>\n</li>\n<li><p><code>장점</code> : 동적으로 크기를 조정할 수 있어 메모리 효율적 사용이 가능하다. 마찬가지로 삽입과 삭제 시 메모리 재배치가 필요하지 않다.</p>\n</li>\n</ul>\n<hr>\n<h3 id=\"활용사례\">활용사례</h3>\n<ul>\n<li><p><code>데이터 접근 패턴</code> : 데이터에 빠르게 접근해야 하는 경우에는 배열이 적합하다. Ex_ 웹 페이지 랜더링</p>\n</li>\n<li><p><strong>웹 브라우저는 DOM을 관리할 때 배열을 사용한다. HTML 요소들을 배열로 저장하여 빠르게 검색하고 수정하여 빠른 페이지 렌더링이 이루어진다.</strong></p>\n</li>\n<li><p><code>삽입과 삭제 빈도</code> : 빈번한 삽입과 삭제가 필요한 경우에는 연결리스트가 더 적합하다.</p>\n</li>\n<li><p><code>메모리 사용</code> : 메모리 사용의 효율성을 고려하여 배열 또는 연결리스트를 선택한다. 배열은 메모리 오버헤드가 적지만 크기 조정이 불가능하므로 연결 리스트를 더 선호함</p>\n</li>\n<li><p><code>알고리즘의 복잡도</code> : 빠른 랜덤 액세스가 필요하다면, 배열을 동적 크기 조정과 빠른 삽입/삭제가 필요한 서비스라면 연결리스트를 사용</p>\n</li>\n</ul>\n",
    "pubDate": "Wed, 31 Jul 2024 05:34:35 GMT",
    "thumbnail": null
  },
  {
    "title": "웹 소켓이란?",
    "link": "https://velog.io/@gawgjiug/%EC%9B%B9-%EC%86%8C%EC%BC%93%EC%9D%B4%EB%9E%80",
    "description": "<h3 id=\"웹-소켓이란\">웹 소켓이란?</h3>\n<p> <img src=\"https://github.com/user-attachments/assets/45f6c660-1c64-41cc-866c-f75a2ca2c222\" alt=\"웹소켓\"></p>\n<ul>\n<li><p>웹 소켓은 <code>실시간 통신</code>이 필요할 때 적극적으로 사용되는 기술이다.</p>\n</li>\n<li><p>초기의 인터넷 통신 방식은 주로 HTTP를 이용한 <strong>클라이언트(요청) -&gt; 서버(응답) 모델</strong> 을 통해 진행되었다. 즉 클라이언트가 서버에 요청(Request)을 보내고,\n서버가 이에 응답(Response) 하는 <code>반이중 통신 방식</code>을 따른다.</p>\n</li>\n<li><p>이러한 방식은 페이지를 요청하는 등의 간단한 작업에는 효과적이지만, 실시간으로 데이터를 주고 받는 서비스를 제공하기에는 한계점이 분명히 있다.</p>\n</li>\n<li><p>클라이언트가 서버에게 요청하지 않는 이상 서버는 클라이언트에게 먼저 데이터를 보낼 수 없기에 <code>실시간 통신</code>과 비슷한 상황을 HTTP 통신으로 이루기 위해선</p>\n</li>\n<li><p>클라이언트는 항상 새로운 데이터가 있는지 확인을 하기 위해 서버에 지속적으로 요청을 보낼 수 밖에 없다.</p>\n</li>\n<li><p>이렇게 되면 트래픽을 필요이상으로 증가 시키고, 이로 인해 서버의 비용이 증가될 뿐더러 요청과 응답 사이의 지연시간이 있기 때문에 <code>실시간 통신</code>의 효율성을 저하시킬 수 있다.</p>\n</li>\n</ul>\n<hr>\n<h3 id=\"웹-소켓-이전의-통신-방식\">웹 소켓 이전의 통신 방식</h3>\n<ul>\n<li>웹 소켓이 등장하기 전 주로 사용되던 HTTP 프로토콜을 기반으로 한 실시간 통신 방식은 어떤 것들이 있을까??</li>\n</ul>\n<h4 id=\"폴링polling\">폴링(Polling)</h4>\n<ul>\n<li><p><img src=\"https://github.com/user-attachments/assets/a8128a61-06ec-4381-bf20-0d3705aeab8b\" alt=\"폴링\"></p>\n</li>\n<li><p>폴링은 클라이언트가 주기적으로 서버에 요청을 보내는 방식을 말한다. 기본적으로 <code>일정시간</code>을 정해 놓고 새로운 데이터가 있는지 주기적으로 서버에 요청을 보내서 확인하게 된다.</p>\n</li>\n<li><p>이때, 새로운 데이터가 없더라도 서버는 응답을 보내게 된다.</p>\n</li>\n</ul>\n<pre><code class=\"language-javascript\">// 클라이언트\nsetInterval(function(){\n    fetch(&#39;/server&#39;).then(function(response){\n        console.log(response);\n    });\n}, 5000); // 5초마다 서버에 요청\n\n// 서버 (Node.js)\napp.get(&#39;/server&#39;, function(req, res){\n    res.send(&#39;새로운 데이터&#39;);\n});</code></pre>\n<ul>\n<li><p>간단한 메커니즘으로 구현이 매우 쉽다는 장점이 있지만, <code>불필요한 요청</code> 의 수가 증가할 수 있고 이는 서버 비용의 증가로 이어진다.</p>\n</li>\n<li><p>그리고 요청과 응답사이의 <code>지연 시간</code>이 발생하기 때문에 실시간통신이 제한될 수 밖에 없다.</p>\n</li>\n</ul>\n<h4 id=\"롱-폴링long-polling\">롱 폴링(Long Polling)</h4>\n<ul>\n<li><p><img src=\"https://github.com/user-attachments/assets/5c7182e9-aa3a-429a-a121-d550bfdab886\" alt=\"롱폴링\"></p>\n</li>\n<li><p>롱 폴링은 <code>폴링</code>을 조금 개선한 방식을 말하는데,</p>\n</li>\n<li><p>먼저 클라이언트가 서버에게 요청을 보내면, 서버는 새로운 데이터가 있는지 확인하게 되고, 일정 시간 동안 새로운 데이터가 없다면 <code>Time Out</code>을 발생시키고 응답을 보낸다.</p>\n</li>\n<li><p>반면에 새로운 데이터가 있다면 즉시 새로운 데이터에 대한 응답(Response)을 보낸다.</p>\n</li>\n</ul>\n<pre><code class=\"language-javascript\">// 클라이언트\nfunction longPoll(){\n    fetch(&#39;/server&#39;).then(function(response){\n        console.log(response);\n        longPoll();\n    });\n}\nlongPoll();\n\n// 서버 (Node.js)\napp.get(&#39;/server&#39;, function(req, res){\n    setTimeout(function(){\n        res.send(&#39;새로운 데이터&#39;);\n    }, 10000); // 10초 후에 응답\n});</code></pre>\n<ul>\n<li><p>새로운 데이터가 있거나, 설정한 10초의 시간이 지나면 응답을 보내는 것.</p>\n</li>\n<li><p>이러한 방식을 사용하면 <code>폴링</code>보다는 데이터 업데이트에 반응하는 속도는 빨라지지만, 서버의 부담이 커진다.</p>\n</li>\n<li><p>서버가 클라이언트로부터 요청을 받을 때 부터 응답을 보내기 까지 클라이언트와의 연결이 지속되는데, 동시에 여러 클라이언트가 서비스를 사용하면 그만큼의 연결을 유지해야 하므로 부하가 발생한다.</p>\n</li>\n</ul>\n<h4 id=\"웹-소켓\">웹 소켓</h4>\n<ul>\n<li><p>웹 소켓 통신은 다음과 같은 방식으로 이루어진다.</p>\n</li>\n<li><p><img src=\"https://github.com/user-attachments/assets/620b7732-7f45-487a-8e75-b5a874e6e288\" alt=\"웹소켓\"></p>\n</li>\n</ul>\n<ul>\n<li><p>클라이언트가 서버에게 Websocket 을 연결하자는 요청을 HTTP 를 통해 전송한다. 그것이 가능한 경우에 서버가 이를 수락하는 응답을 HTTP로 보내게 된다.</p>\n</li>\n<li><p>이러한 handshake 과정을 거치고 나면 연결이 이루어지고, 그 때부터 클라이언트와 서버는 HTTP가 아닌 WebSocket 프로토콜을 사용하여 소통한다.</p>\n</li>\n<li><p>HTTP의 <code>편지</code>방식이 아니라, <code>전화통화</code>가 이루어지는 것. 여기서 클라이언트와 서버는 자유롭게 서로에게 메시지를 보낼 수 있게된다.</p>\n</li>\n<li><p><code>WebSocket</code> 에서의 통신은 헤더의 크기가 작고, 오버헤드가 적기 때문에 HTTP 보다 효율적인 통신이 가능하다.</p>\n<blockquote>\n<p>헤더는 우편물에 붙은 송장 과 비슷한것.</p>\n</blockquote>\n</li>\n</ul>\n<pre><code class=\"language-js\">GET /socket\nHost: yong-nyong-tistory.com\nOrigin: https://gwagjiug.com\nConnection: Upgrade\nUpgrade: websocket\nSec-WebSocket-Key: Ivyio/9s+lYongNyongczP8Q==\nSec-WebSocket-Version: 13</code></pre>\n<ul>\n<li>이러한 연결은 클라이언트와 서버 둘 중 한쪽이 연결을 종료하자는 메시지를 보낼 때 까지 지속된다. 한쪽이 <code>close</code> 프레임을 보내면, 다른쪽이 이를 확인하고 <code>close</code> 프레임을 응답으로 보냄으로써 연결이 종료되는 것.</li>\n</ul>\n<blockquote>\n<p>만약에 클라이언트의 폰 혹은 PC가 <code>close</code>를 보내지 못하고 꺼지게 된다면?</p>\n</blockquote>\n<ul>\n<li><p>비정상적인 종료를 감지하는 방법들이 있다.</p>\n</li>\n<li><p>지정된 시간 동안 메시지가 없을 시 확인 패킷을 보내는 방법, 주기족으로 ping,pong 프레임을 주고 받아서 서로의 접속 여부를 확인하는 방법도있다.</p>\n</li>\n<li><p>WebSocket은 하나의 연결을 끝까지 유지하고, 그 과정에서도 적은 자원만 소모하기 때문에 Long Polling 만큼 서버에 부담을 주지 않을 수 있는 것</p>\n</li>\n</ul>\n<hr>\n<h4 id=\"웹소켓의-한계점\">웹소켓의 한계점</h4>\n<ul>\n<li><p>웹 소켓은 서버의 설계에 따라 구현이 복잡해질 수 있다. 특히 <a href=\"https://github.com/gawgjiug/Eureka_CS_Study/blob/main/Network/network_load_balancing.md\">로드밸런싱</a> 이 적용된 서버에서는 고려하고 설정할 부분이 많아지는데,</p>\n</li>\n<li><p>로드밸런싱은 기본적으로 서러 여러 대가 클라이언트 요청을 나눠서 받는 방식인데, 웹 소켓은 특정 서버와의 지속적인 연결 안에서만 이루어지기 때문에 한 서버와 웹 소켓 통신을 시작하면 이후로도 계속 그 서버로만 데이터가 전송되도록 설정해야한다.</p>\n</li>\n<li><p>NGINX,AWS ELB 등 WebSocket을 처리할 수 있는 로드 밸런서를 선택하여 구성하는 등 방법을 찾아 해결해야 한다.</p>\n</li>\n<li><p>WebSocket의 기본 프로토콜인 WS 는 통신이 암호화 되어있지 않기 때문에 SSL/TLS3 인증서를 발급 받은 뒤 이를 사용하여 WSS를 설정해야 한다.</p>\n</li>\n<li><p>그리고 알아둬야 할 것이 기존의 <code>Polling</code> 등의 방식 보다는 훨씬 덜하지만 WebSocket도 서버에 부담을 주는 것은 마찬가지이기 때문에 구현하고자 하는 서비스에 가장 적절한 선택을 하는 것이 중요하다.</p>\n</li>\n</ul>\n",
    "pubDate": "Wed, 31 Jul 2024 05:33:50 GMT",
    "thumbnail": null
  }
]