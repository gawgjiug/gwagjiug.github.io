[
  {
    "title": "캐시 (Cache)?",
    "link": "https://velog.io/@gawgjiug/%EC%BA%90%EC%8B%9C-Cache",
    "description": "<h3 id=\"운영체제-캐시cache\">운영체제 캐시(Cache)</h3>\n<hr>\n<h3 id=\"캐시란\">캐시란??</h3>\n<ul>\n<li><p>CPU 캐시에 대해 알아보기 전에 <code>캐시</code> 라는 개념에 대해 먼저 알아보자</p>\n</li>\n<li><p><code>캐시</code>는 자주 사용하는 데이터를 미리 복사해 놓는 임시 저장 장소를 말한다. 이러한 캐시는 원본 데이터에 접근하는 시간을 절약하기 위해 사용된다. 즉 데이터 검색 속도를 높이기 위함이다. </p>\n</li>\n</ul>\n<h4 id=\"cpu-cache\">CPU cache</h4>\n<p><img src=\"https://github.com/user-attachments/assets/d24f7fe3-3ebb-4965-882a-ef5d5a279be7\" alt=\"image\"></p>\n<p><code>위 이미지는 CPU 캐시의 구조를 소프트웨어 관점으로 보여주는 이미지이다</code></p>\n<ul>\n<li>CPU가 자주 사용할 만한 데이터를 메인 메모리에서 꺼내와 복사 저장해 놓는 임시 저장 장소를 말한다.</li>\n</ul>\n<p><img src=\"https://github.com/user-attachments/assets/9cc9b17e-60c5-4e27-976d-d41d71a96338\" alt=\"image\"></p>\n<p><code>위 이미지는 CPU 캐시의 구조를 하드웨어 관점으로 보여주는 이미지이다</code></p>\n<hr>\n<h4 id=\"데이터-지역성이란\">데이터 지역성이란?</h4>\n<ul>\n<li><p>데이터 지역성은 캐시의 적중률(hit)을 높여 메모리 접근 패턴을 최적화 하여 프로그램 성능을 향상 시키는 데에 중요한 역할을 하는 개념이다.</p>\n</li>\n<li><p>데이터 지역성은 자주 쓰이는 데이터가 시간적으로나 공간적으로 한 곳에 몰려있을 가능성이 높다는 원리를 말한다.</p>\n</li>\n</ul>\n<p><strong>1. 시간지역성</strong> : 시간 지역성은 특정 데이터가 한 번 접근되면, 가가운 미래에 그 데이터가 다시 접근될 가능성이 높다는 것을 의미한다. CPU 캐시가 시간 지역성을 활용하는 방법은 다음과 같습니다.</p>\n<ul>\n<li><p><code>LRU(Lease Recently Used) 알고리즘</code> : 자주 사용되는 데이터를 캐시에 남겨두기 위해 LRU 알고리즘을 사용하여 덜 자주 사용되는 데이터를 제거하고, 최근에 사용된 데이터를 유지합니다.</p>\n</li>\n<li><p>예를 들어, 반복문에서 같은 변수를 여러 번 읽고 쓰는 경우가 있습니다. 이 경우 시간 지역성 때문에 해당 변수는 캐시에 남아 있어 반복문을 빠르게 실행할 수 있는 것.</p>\n</li>\n</ul>\n<hr>\n<p><strong>2. 공간 지역성</strong> : 공간 지역성은 특정 데이터가 접근되면, 그 데이터와 인접한 주소에 있는 데이터도 곧 접근될 가능성이 높다는 것을 의미한다. </p>\n<ul>\n<li><p>CPU 캐시가 공간 지역성을 활용하는 방법은 다음과 같다.</p>\n</li>\n<li><p><code>캐시 라인</code> : 캐시 메모리는 보통 캐시 라인이라는 단위로 데이터를 저장하며, 캐시 라인을 일반적으로 여러 바이트의 데이터를 포함하고 하나의 캐시 라인에 연속된 메모리 주소의 데이터가 저장된다.</p>\n</li>\n<li><p>예를 들어, 배열의 요소를 순차적으로 접근하려는 경우에 공간 지역성 때문에 배열의 연속된 요소들이 캐시에 로드되어 배열 접근이 빠르게 이루어질 수 있음.</p>\n</li>\n</ul>\n<h4 id=\"캐시-동작-방식\">캐시 동작 방식</h4>\n<ul>\n<li><p>캐시 공간은 $O(1)$ 등 낮은 시간복잡도로 접근 가능한 곳을 주료 사용한다.</p>\n</li>\n<li><p>캐시에 원하는 데이터가 없거나 <code>(Cache Miss)</code> 너무 오래 되어 최신성을 잃었을 때 <code>(Expiration)</code></p>\n<ul>\n<li>원본 데이터가 있는 곳에 접근해 데이터를 가져옴</li>\n<li>이 때 데이터를 가져오며 캐시에도 해당 데이터를 복사하거나 갱신한다.</li>\n</ul>\n</li>\n<li><p>캐시에 원하는 데이터가 있을 때 <code>(Cache Hit)</code></p>\n<ul>\n<li>원본 데이터가 있는 공간에 접근하지 않고 바로 해당 데이터를 제공한다.</li>\n</ul>\n</li>\n<li><p>캐시 공간은 작기 때문에 공간이 모자랄 경우 안쓰는 데이터부터 삭제하여 공간을 확보한다 (Eviction</p>\n</li>\n</ul>\n<hr>\n<h4 id=\"캐시-활용-예시\">캐시 활용 예시</h4>\n<h5 id=\"cdn-content-delivery-network\">CDN (Content Delivery Network)</h5>\n<ul>\n<li><p>세계 각지에 캐시 서버를 두어 전송속도를 높이고 부하를 분산하는 시스템을 말한다.</p>\n</li>\n<li><p>Google 은 각 통신사마다 Google Global Cache를 두어 인기있는 YouTube 영상은 미국서버까지 접속할 필요 없이 국내 서버에서 처리하도록 설계하였다.</p>\n</li>\n<li><p>가격이 비싼 국제 회선 비용이 절감되고 버퍼링이 감소한다는 장점을 가짐</p>\n</li>\n</ul>\n<p><img src=\"https://github.com/user-attachments/assets/9ec48025-7202-49b7-9728-ebb0d54c49a2\" alt=\"image\"></p>\n<h5 id=\"웹-캐시\">웹 캐시</h5>\n<ul>\n<li><p>네트워크를 통해 데이터를 가져오는 것은 때때로 하드디스크에서 가져오는 것 보다 느릴때가 있다.</p>\n</li>\n<li><p>브라우저 캐시 : 브라우저는 웹 페이지에 접속할 때 HTML,CSS,JS, 이미지 등을 하드 디스크나 메모리에 캐싱해뒀다가 다음번에 다시 접속할 때 이를 재활용하는 것을 말한다.</p>\n</li>\n<li><p>응답캐시 : 웹 서버 또한 상당수의 경우 동적 웹 페이지라 할지라도 매번 내용이 바뀌지 않는 경우가 더 많기 때문에 서버에서 생성한 HTML을 캐싱해뒀다가 다음번 요청에 이를 재활용 하는 것을 말한다.</p>\n</li>\n</ul>\n",
    "pubDate": "Tue, 16 Jul 2024 12:50:04 GMT",
    "thumbnail": null
  },
  {
    "title": "트리의 부모 찾기",
    "link": "https://velog.io/@gawgjiug/%ED%8A%B8%EB%A6%AC%EC%9D%98-%EB%B6%80%EB%AA%A8-%EC%B0%BE%EA%B8%B0",
    "description": "<ul>\n<li>오랜만에 백준 문제.. 머리가 잘 안돌아가서 쉬운 문제를 풀어봤음.</li>\n</ul>\n<p><a href=\"https://www.acmicpc.net/problem/11725\">백준 11725번 : 트리의 부모 찾기</a></p>\n<p><img src=\"https://velog.velcdn.com/images/gawgjiug/post/ad30b791-ce05-41db-808b-78b28dcc5166/image.png\" alt=\"\"></p>\n<ul>\n<li>트리는 인접 행렬과 인접 리스트를 통해 구현할 수 있는데,  문제에서 N의 개수가 최대 10만이다. 인접 행렬로 구현하면 10만 x 10만 = 총 100만의 공간을 차지하게 되므로 메모리가 4바이트라고 할 때 40기가의 메모리를 필요로 하므로 현재 문제에서는 인접 행렬 방식은 구현할 수 없음.</li>\n</ul>\n<ul>\n<li><p>인접 리스트를 구성해서 간 간선을 읽어 두 노드 사이의 연결을 인접 리스트에 추가한다.</p>\n</li>\n<li><p>DFS 방식을 이용해서 현재 노드의 부모 노드를 찾고, 그 노드의 값을 저장한 배열의 값을 2부터 출력.</p>\n</li>\n</ul>\n<pre><code class=\"language-java\">package Silver_2;\n\nimport java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.util.ArrayList;\nimport java.util.List;\nimport java.util.StringTokenizer;\n\npublic class find_tree_parents {\n\n    private static ArrayList&lt;Integer&gt;[] adjList;\n    private static int[] parents;\n    private static boolean [] visited;\n\n    static int N;\n    public static void main(String[] args) throws IOException {\n\n        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n        StringTokenizer st = null;\n\n        N = Integer.parseInt(br.readLine());\n        parents = new int[N+1];\n        visited = new boolean[N+1];\n        adjList = new ArrayList[N+1];\n\n        for(int i =1; i&lt;=N; i++){\n            adjList[i] = new ArrayList&lt;Integer&gt;();\n            //list 초기화\n        }\n\n        for(int i = 0; i&lt;N-1; i++){\n            st = new StringTokenizer(br.readLine());\n            int v1 = Integer.parseInt(st.nextToken());\n            int v2 = Integer.parseInt(st.nextToken());\n\n            adjList[v1].add(v2);\n            adjList[v2].add(v1);\n\n\n        }\n\n        dfs(1);\n\n\n\n        for(int i = 2; i&lt;=N; i++){\n            System.out.println(parents[i]);\n        }\n\n\n\n    }\n\n    private static void dfs(int v) {\n        visited[v] = true;\n\n        for(int vertex : adjList[v]){\n            if(!visited[vertex]){\n                parents[vertex] = v;\n                dfs(vertex);\n            }\n        }\n\n    }\n}\n/*\n*\n* 1 = true\n* 1넘어가고 2\n* parent[2] = 1 -&gt; 2의 부모는 1\n* dfs(2) */\n</code></pre>\n<ul>\n<li>거의 2주만에 문제 푸니깐 알손실 왔다.. 바빠도 꾸준히 하자 ㅜㅜ</li>\n</ul>\n",
    "pubDate": "Fri, 12 Jul 2024 15:57:10 GMT",
    "thumbnail": null
  },
  {
    "title": "[자료구조] 우선순위 큐",
    "link": "https://velog.io/@gawgjiug/%EC%9E%90%EB%A3%8C%EA%B5%AC%EC%A1%B0-%EC%9A%B0%EC%84%A0%EC%88%9C%EC%9C%84-%ED%81%90",
    "description": "<p>우선순위 큐는 <code>우선순위가 높은 데이터가 먼저 나오는 자료구조다</code>  큐와 동일하게 데이터 삽입과 삭제 연산을 지원한다. 데이터 삭제 연산을 수행하면 우선순위가 가장 높은 데이터를 얻을 수 있다.</p>\n<ul>\n<li><p>우선순위 큐를 구현하는 방식은 배열, 연결 리스트, 완전 이진 트리인 힙이 있다. 각 구현 방식의 시간 복잡도는 다음과 같다. <code>일반적으로 가장 효율적인 방식인 힙을 사용한다.</code></p>\n</li>\n<li><p>배열,연결리스트 모두 삽입과 삭제에서 O(1), O(n)의 시간 복잡도를 가지지만, 힙의 경우에는 두 가지 경우 모두 $O(logn)$ 의 시간복잡도를 가진다.</p>\n</li>\n</ul>\n<h3 id=\"힙\">힙</h3>\n<ul>\n<li>힙은 완전 이진 트리로, 최댓값 또는 최솟값을 빠르게 찾을 수 있는 자료구조다. 우선순위 큐를 구현하는 데 자주 사용한다.</li>\n</ul>\n<p>** 최대 힙 : 부모 노드의 값이 자식 노드의 값보다 크거나 같은 완전 이진 트리이다.**\n** 최소 힙 : 부모 노드의 값이 자식 노드의 값보다 작거나 같은 완전 이진 트리이다.**</p>\n<p><img src=\"https://velog.velcdn.com/images/gawgjiug/post/9f56d685-4215-4cbd-a7d1-c4494b881316/image.png\" alt=\"\"></p>\n<ol>\n<li>삽입 연산</li>\n</ol>\n<ul>\n<li>힙에 데이터를 삽입할 때는 힙의 맨 끝에서 이루어진다.(맨 아래) 부모 노드와 우선순위(최댓값 또는 최솟값)를 비교해 부모 노드보다 우선순위가 높으면 위치를 바꾸면서 루트노드 까지 비교한다.</li>\n</ul>\n<ol start=\"2\">\n<li>삭제 연산</li>\n</ol>\n<ul>\n<li>힙에서 데이터 삭제는 우선순위가 가장 높은 노드를 삭제하는 연산이다. 즉 , 루트 노드를 삭제하게 된다. 삭제한 후에는 루트 노드 자리에 힙의 마지막 노드(마지막 레벨의 가장 오른쪽 노드)를 옮긴 후 재정렬 한다.</li>\n</ul>\n<p><img src=\"https://velog.velcdn.com/images/gawgjiug/post/dad3ec65-246b-4437-8c13-9112e86d6b96/image.png\" alt=\"\"></p>\n<ul>\n<li>루트 노드를 삭제한다. 힙의 마지막 노드를 루트 노드 자리로 옮긴다.</li>\n</ul>\n<p><img src=\"https://velog.velcdn.com/images/gawgjiug/post/6d5891c1-eb30-4d37-8edb-274e6da2b170/image.png\" alt=\"\"></p>\n<p><img src=\"https://velog.velcdn.com/images/gawgjiug/post/67bcd4b9-e434-4c04-8fe8-ff0e1491464d/image.png\" alt=\"\"></p>\n<ul>\n<li>새로운 루트 노드 2와 자식 노드 2개 중에서 우선순위가 높은 자식 노드의 값(6)을 비교하여 자식 노드의 우선순위가 높으므로 위치를 바꾼다.</li>\n</ul>\n<h3 id=\"해시-테이블\">해시 테이블</h3>\n<ul>\n<li><p>해시 테이블은 하나의 키(key)에 대해 하나의 값(value)을 저장하는 형태의 자료 구조이다. </p>\n</li>\n<li><p>키는 해시 함수를 사용해 해시를 얻을 수 있다. <strong>해시</strong>는 값이 저장되어 있는 해시 테이블의 인덱스를 찾을 수 있는 값이다. </p>\n</li>\n<li><p>해시 함수에 키를 넣으면 해시 테이블에서 매칭되는 결과 값에 한번에 접근할 수 있다. 따라서 연산은 평균적으로 $O(1)$ 의 시간 복잡도를 가진다.</p>\n</li>\n<li><p>아래 이미지를 예시를 들자면, 아래와 같은 해시 테이블이 있을 때 &#39;수영&#39;을 해시 함수에 넣으면 4라는 해시를 얻는다. 해시는 인덱스를 의미하므로 해시 테이블에 인덱스 4에 저장된 7이라는 값을 얻을 수 있다.</p>\n</li>\n</ul>\n<p><img src=\"https://velog.velcdn.com/images/gawgjiug/post/01ecf914-d9af-43f6-9203-f6b4f38e9e80/image.png\" alt=\"\"></p>\n<ul>\n<li>하지만 해시 테이블에서는 <code>해시 충돌</code> 이라는 단점이 있다. 해시 충돌은 서로 다른 키에 대해 같은 해시가 도출되는 것을 말한다. 그러한 해시 충돌을 해결하기 위해 체이닝 혹은 개방 주소법이라는 방법론이 개발되었다.</li>\n</ul>\n<h4 id=\"체이닝\">체이닝</h4>\n<ul>\n<li><p>체이닝이란 해시 충돌이 발생하면 <code>같은 해시가 나오는 키의 값을 연결 리스트에 저장하는 방식</code> 이다.</p>\n</li>\n<li><p>연결 리스트에 노드를 저장하므로 저장 공간에 대한 제약이 적다는 장점이 있지만, 하나의 해시(인덱스)에 노드가 몰릴 수 있다는 단점이 있다.)</p>\n</li>\n<li><p>위 그림 처럼 윤아와 서현은 해시테이블 내에서 같은 인덱스 값을 가지고 있지만, 연결리스트로 키값을 연결하여 해시 충돌을 방지하고 있다</p>\n</li>\n<li><p>만약 윤아를 해시 함수에 넣으면 각 노드에는 키와 값 쌍이 저장되어 있기 때문에 같은 인덱스라고 하더라도 구분이 가능한 것.</p>\n</li>\n</ul>\n<p><code>웹 브라우저나 데이터베이스 캐시 시스템에 자주 사용 됨</code></p>\n<h4 id=\"개방-주소법\">개방 주소법</h4>\n<ul>\n<li><p>해시 충돌이 발생했을 때 해당 해시가 아닌 <code>비어 있는 공간에 값을 저장하는 방식</code> 이다. 개방 주소법에는 선형 조사법, 이차 조사법, 이중 해싱이 있다.</p>\n</li>\n<li><p>간단하게 설명해보자면,</p>\n</li>\n</ul>\n<ol>\n<li><p>선형 조사법  : 선형 조사법은 충돌이 발생했을 때, 고정된 간격으로 다음 슬롯을 순차적으로 탐색하여 빈 슬록을 찾는 방법을 말하고 일반적으로 간격을 1로 설정된다.</p>\n</li>\n<li><p>이차 조사법 : 이차 조사법은 충돌이 발생했을 때, 탐색 간격을 제곱 수로 증가시키는 방법이다. 즉, 첫 번째 충돌에서는 $1^2$ 두 번째 충돌에서는 $2^2$ 세 번째 충돌에서는 $3^2$ 의 간격으로 슬록을 탐색하며 빈 공간을 찾는다.</p>\n</li>\n<li><p>이중 해싱 : 이중 해싱은 두 개의 다른 해시 함수를 사용하여 충돌이 발생했을 때, 다른 해시 함수를 한번 더 적용하는 방법을 말한다.</p>\n</li>\n</ol>\n",
    "pubDate": "Thu, 11 Jul 2024 15:02:12 GMT",
    "thumbnail": null
  },
  {
    "title": "[자료구조] 트리",
    "link": "https://velog.io/@gawgjiug/%EC%9E%90%EB%A3%8C%EA%B5%AC%EC%A1%B0-%ED%8A%B8%EB%A6%AC",
    "description": "<h3 id=\"트리\">트리</h3>\n<ul>\n<li><strong>트리</strong> 는 그래프의 한 종류로 사이클이 없어서 계층적 관계를 표현하는 데 유용하다. </li>\n</ul>\n<p><img src=\"https://velog.velcdn.com/images/gawgjiug/post/5a68e164-a1f8-47ff-85d6-e85bc9c28032/image.png\" alt=\"\"></p>\n<ul>\n<li><p>루트노드 : 부모 노드가 없는 노드로 트리에는 하나의 루트 노드가 존재한다.</p>\n</li>\n<li><p>부모 노드 : 루트 노드 방향으로 연결된 노드다. </p>\n</li>\n<li><p>자식 노드 : 루트 노드의 반대 방향으로 연결된 노드다.</p>\n</li>\n<li><p>단말 노드 : 자식 노드가 없는 노드이다.</p>\n</li>\n<li><p>형제 노드 : 부모 노드가 같은 노드 (F,G)</p>\n</li>\n<li><p>레벨 : 루트 노드로 부터 노드의 상대적 위치를 의미함.</p>\n</li>\n<li><p>일반적으로 루트노드의 레벨은 0이다.</p>\n</li>\n<li><p>높이 : 트리의 최대 레베 +1을 의미함</p>\n</li>\n<li><p>차수 : 자식 노드의 개수</p>\n</li>\n</ul>\n<h3 id=\"이진트리\">이진트리</h3>\n<ul>\n<li>이진 트리는 자식 노드가 최대 2개인 트리이다. 대표적인 이진 트리의 종류는 다음과 같다.</li>\n</ul>\n<h4 id=\"완전-이진트리\">완전 이진트리</h4>\n<ul>\n<li>트리의 마지막 레벨을 제외한 모든 레벨에 노드가 채워져 있으며,  마지막 레벨은 왼쪽에서부터 오른쪽으로 노드가 채워져 있는 이진 트리다.</li>\n</ul>\n<p><img src=\"https://velog.velcdn.com/images/gawgjiug/post/1df6768a-305a-447a-a2dd-5cf55c48976e/image.png\" alt=\"\"></p>\n<h4 id=\"포화-이진트리\">포화 이진트리</h4>\n<ul>\n<li>트리의 마지막 레벨 까지 <code>노드가 모두 채워져 있는 이진트리</code> 이다. 따라서 포환 이진 트리는 곧 완전 이진 트리라고 할 수 있다.</li>\n</ul>\n<p><img src=\"https://velog.velcdn.com/images/gawgjiug/post/f028cb56-477b-4523-a954-737bb93a1a16/image.png\" alt=\"\"></p>\n<h4 id=\"이진-탐색-트리-bst-binary-search-tree\">이진 탐색 트리 (BST Binary Search Tree)</h4>\n<ul>\n<li><p>한 노드의 <code>왼쪽 서브 트리는 해당 노드의 값보다 작은 값을 가진 노드로 구성되고, 오른쪽 서브 트리는 해당 노드의 값보다 큰 값을 가진 노드로 구성된 트리다.</code></p>\n</li>\n<li><p>균형 잡힌 이진 탐색 트리에서는 루트 노드와 가까운 노드일 수록 검색해야 하는 노드 개수가 절반으로 줄어든다. 따라서 값을 검색하는 데 $O(logn)$ 이 소요된다. </p>\n</li>\n<li><p>하지만 균형이 잡히지 않은 이진 트리에서는 검색하는데 시간 복잡도가 $O(n)$이 소요 되므로 이진 탐색 트리를 이용하는 장점이 사라진다.</p>\n</li>\n<li><p>그래서 완전 이진 트리로 이진 탐색 트리를 구성하려면 <code>균형 이진 탐색 트리)</code> 가 필요한 것이다. </p>\n</li>\n<li><p>균형 이진 탐색 트리의 대표적인 예로는 레드-블랙 트리와 AVL 트리가 있다.</p>\n</li>\n</ul>\n<p><img src=\"https://velog.velcdn.com/images/gawgjiug/post/38dc5c3c-340b-4cac-9cd5-308de5c17a74/image.png\" alt=\"\"></p>\n<ul>\n<li>이진 탐색 트리에서 데이터의 추가, 삭제 연산 방식은 다음과 같다.</li>\n</ul>\n<p>** 1. 데이터 추가 **</p>\n<ul>\n<li><p>이진 탐색 트리에서 데이터 추가는 루트 노드 부터 차례대로 값을 비교해 나가면서 삽입할 자리는 찾는 방식이다.</p>\n</li>\n<li><p>추가하려는 데이터가 비교하는 노드보다 값이 큰 경우 오른쪽 자식 노드와 비교를 수행하고, 작은 경우는 왼쪽 자식 노드와 비교를 수행한다. </p>\n</li>\n</ul>\n<p>** 2. 데이터 삭제 **</p>\n<ul>\n<li><p>이진 탐색 트리에서 데이터를 삭제하는 경우는 자식 노드의 개수에 따라 3가지로 나눌 수 있다. </p>\n</li>\n<li><p><strong>자식 노드가 없는 경우</strong> : 해당 노드만 삭제하면 된다. </p>\n</li>\n<li><p><strong>자식 노드가 1개인 경우</strong> : 자식 노드를 삭제한 노드의 위치로 옮기면 된다. </p>\n</li>\n<li><p><strong>자식 노드가 2개인 경우</strong> : 오른쪽 서브 트리에서 가장 작은 값을 삭제한 노드 위치로 옮기면 된다.</p>\n</li>\n</ul>\n<h3 id=\"레드-블랙-트리\">레드-블랙 트리</h3>\n<p><img src=\"https://velog.velcdn.com/images/gawgjiug/post/e01fdeaa-7178-4acd-8fc8-628e8cf1f201/image.png\" alt=\"\"></p>\n<ul>\n<li><p>레드 블랙 트리 또한 binary-search tree(이진탐색트리) 의 일종이다.</p>\n</li>\n<li><p>기존의 이진탐색트리 같은 경우 input이 이미 정렬되어 있다면(최악의 경우 한쪽으로 몰린경우), 높이가 n이 되어버리고, 따라서 시간복잡도 또한 O(n)에 도달하게 된다.</p>\n</li>\n<li><p>하지만 레드 블랙 트리의 경우 <strong>특정 조건</strong>을 지키면서 균형잡힌 이진트리가 되기 때문에 Search,Insert,Delete 연산을 최악의 경우에도 O(logN) 안에 가능하도록 해준다.</p>\n</li>\n<li><p>레드블랙 트리는 여러가지 속성을 통해 <strong>특정 조건</strong>을 지켜나가는데, 레드 블랙 트리의 속성을 아래와 같다.</p>\n</li>\n</ul>\n<ol>\n<li><p>노드 색깔 속성 : 각 노드는 빨간색 또는 검은색으로 이루어져있다.</p>\n</li>\n<li><p>루트 속성 : 루트 노드는 항상 검은색이다.</p>\n</li>\n<li><p>리프 노드 속성: 모든 리프 노드(NIL)은 검은색이다 (레드블랙 트리에서는 일반적으로 리프노드를 &#39;NIL&#39; 로 간주하며, 이는 실제 데이터가 없는 더미 노드임.)</p>\n</li>\n<li><p>레드 노드 속성: 빨간색 노드의 자식 노드는 항상 검은색이다. 즉, 빨간색 노드는 연속으로 나올 수 없다. (빨간색 노드의 부모 및 자식 노드는 모두 검은색).</p>\n</li>\n<li><p>경로 속성: 모든 리프 노드에서 루트까지의 경로에는 같은 개수의 검은색 노드가 포함되어있음 이를 &#39;black height&#39;라고함.</p>\n</li>\n</ol>\n<h3 id=\"레드-블랙-트리의-연산\">레드 블랙 트리의 연산</h3>\n<ul>\n<li>레드 블랙 트리에서의 주요 연산들은 삽입, 삭제 , 검색이 있다. 검색은 일반적인 이진 탐색 트리와 동일하게 수행되지만, 삽입과 삭제는 트리의 균형을 유지하기 위해 추가적인 작업이 필요하다.</li>\n</ul>\n<ol>\n<li>삽입</li>\n</ol>\n<ul>\n<li><p>삽입은 일반적인 이진 탐색 트리의 삽입 방식과 유사하지만, 삽입 후 트리의 균형을 맞추기 위해 추가적인 작업이 필요하다. 새로 삽입된 노드는 빨간색으로 표시되며, 다음과 같은 규칙을 통해 트리를 재구성 한다.</p>\n</li>\n<li><p>부모 노드가 검은색인 경우, 추가 작업을 필요없다.</p>\n</li>\n<li><p>부모 노드가 빨간색인 경우, 추가적인 재구성이 필요함. (재구성 방법에는 회전과 색 변경이 있다.)</p>\n</li>\n</ul>\n<ol start=\"2\">\n<li>삭제</li>\n</ol>\n<ul>\n<li>삭제는 일반적인 이진 탐색 트리의 삭제 방식과 유사하지만, 삭제 후 트리의 균형을 맞추기 위해 추가적인 작업이 필요하다. 노드를 삭제 한 후 트리의 속성을 위반하지 않도록 회전과 색깔 변경을 통해 트리를 재구성함.</li>\n</ul>\n<p><strong>우선 삽입 후 재구성 경우의 수</strong> 에 대해서 설명하겠다.</p>\n<p><strong>용어 정의:</strong></p>\n<ul>\n<li>N: 새로 삽입된 노드</li>\n<li>P: N의 부모 노드</li>\n<li>G: N의 조부모 노드</li>\n<li>U: N의 삼촌 노드 (G의 다른 자식)</li>\n</ul>\n<ol>\n<li>P가 빨간색이고, U가 빨간색인 경우 (부모 레벨의 노드가 전부 빨간색인 경우) 4번 속성 위반.(빨간색 노드는 연속으로 나올 수 없음)</li>\n</ol>\n<ul>\n<li><p>P와 U를 검은색으로 변경함. G를 빨간색으로 변경함. 이제 G를 다시 확인한다. </p>\n</li>\n<li><p>만약 G가 루트 노드라면, G를 검은색으로 설정하여 균형을 맞춘다, G가 루트 노드가 아니라면, G의 부모가 빨간색인지 확인하고 위 과정을 반복함.</p>\n</li>\n</ul>\n<ol start=\"2\">\n<li>P가 빨간색이고, U가 검은색인 경우 (삼촌이 검은색인 경우) </li>\n</ol>\n<ul>\n<li>이 경우는 추가적인 회전과 색깔 변경이 필요함 이 경우는 N,P,G 의 상대적인 위치에 따라 다시 나눌 수 있다.</li>\n</ul>\n<p>2-1. N이 P의 오른쪽 자식이고, P가 G의 왼쪽 자식인 경우 (Left_Right Case)</p>\n<ul>\n<li><p>P를 기준으로 우회전한다.. (노드의 오른쪽 자식을 부모로 올리고, 기준 노드는 오른쪽 자식의 왼쪽 자식이 되며, G는 오른쪽 자식(N)의 오른쪽 자식이 된다. )</p>\n</li>\n<li><p>이로 인해 N이 새로운 부모가 된다. </p>\n</li>\n</ul>\n<p>2-2. N이 P의 왼쪽 자식이고, P가 G의 왼쪽 자식인 경우(Left-Left Case)</p>\n<ul>\n<li><p>왼쪽으로 불균형을 이룰 경우에 가운데 노드를 중심으로 오른쪽으로 회전해서 균형을 맞춘다.</p>\n</li>\n<li><p>P가 G의 위치로 올라가고 G는 P의 오른쪽 자식이되고, N은 P의 왼쪽 자식이 된다.</p>\n</li>\n</ul>\n<p>**RR(Right-Right Case)도 마찬가지이다. 가운데 노드를 중심으로 왼쪽으로 회전해서 균형을 맞춘다)</p>\n<ol start=\"3\">\n<li>RL(Right-Left Case)</li>\n</ol>\n<ul>\n<li>P는 N의 오른쪽 자식이되고, P가 G의 위치로 올라가면서 동시에 G는 P의 왼쪽 자식이된다.</li>\n</ul>\n<h4 id=\"결론\">결론</h4>\n<ul>\n<li>레드 블랙 트리는 삽입과 삭제 시 트리가 자동으로 균형을 유지한다는 장점을 가지고 있으며, 검색, 삽입, 삭제 모두 최악의 경우에도 O(nlogn)의 시간복잡도를 보장한다.</li>\n</ul>\n<h3 id=\"avl-트리\">AVL 트리</h3>\n<ul>\n<li><p>AVL 트리또한 이진 탐색트리의 한쪽으로 노드가 쏠리는 현상을 막기 위해 고안된 방식이다.</p>\n</li>\n<li><p>그래서 레드블랙트리와 일정 부분 비슷한데, </p>\n</li>\n<li><p>우선 기본적으로 AVL 트리 또한 이진 탐색 트리의 속성을 가지며, 왼쪽,오른쪽 서브 트리의 높이 차이가 최대 1로 제한되어있다.</p>\n</li>\n<li><p>높이 차이가 1보다 커지면 회전을 통해 균형을 맞춰 높이 차이를 줄인다.</p>\n</li>\n<li><p>삽입, 검색, 삭제의 시간 복잡도가 O(logN)이다.</p>\n</li>\n</ul>\n<p><img src=\"https://velog.velcdn.com/images/gawgjiug/post/4692168e-e2e5-4ba1-be01-fc99e9393e51/image.png\" alt=\"\"></p>\n<p>AVL 트리는 모든 노드의 BF 가 -1,0,1 중 하나여야 한다. 만약 이를 벗어나면 균형이 깨졋다는 것을 의미하고, 이때 회전이 필요한 것</p>\n<blockquote>\n<p>$BF(K) = K의 왼쪽 서브트리의 높이 - K의 오른쪽 서브트리의 높이$</p>\n</blockquote>\n<ul>\n<li>회전에 대해서는 앞서 설명했기 때문에 사진 설명만 추가하겠다.</li>\n</ul>\n<h4 id=\"우회전\">우회전</h4>\n<p><img src=\"https://velog.velcdn.com/images/gawgjiug/post/eae9d2e0-831f-4e1b-9152-a44ca854cd68/image.png\" alt=\"\"></p>\n<h4 id=\"좌회전\">좌회전</h4>\n<p><img src=\"https://velog.velcdn.com/images/gawgjiug/post/0ac2650c-0eb2-454d-8339-6c02cab4832e/image.png\" alt=\"\"></p>\n<h4 id=\"lr-case\">LR Case</h4>\n<p><img src=\"https://velog.velcdn.com/images/gawgjiug/post/851af6b8-81ca-4694-adfa-480d4f8107ef/image.png\" alt=\"\"></p>\n<h4 id=\"rl-case\">RL Case</h4>\n<p><img src=\"https://velog.velcdn.com/images/gawgjiug/post/9bf69f77-ce1e-482e-831d-70653871fba2/image.png\" alt=\"\"></p>\n",
    "pubDate": "Sat, 06 Jul 2024 08:57:27 GMT",
    "thumbnail": null
  },
  {
    "title": "[알고리즘] 순열,조합",
    "link": "https://velog.io/@gawgjiug/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98-%EC%88%9C%EC%97%B4%EC%A1%B0%ED%95%A9",
    "description": "<h3 id=\"순열\">순열</h3>\n<ul>\n<li>순열이란 n 개의 값중에서 r개의 숫자를 모든 순서대로 뽑는 경우를 말한다.</li>\n</ul>\n<p>예를들어 <code>[1,2,3]</code> 이라는 3개의 배열에서 2개의 숫자를 뽑는 경우는</p>\n<blockquote>\n</blockquote>\n<p>[1, 2]\n[1, 3]\n[2, 1]\n[2, 3]\n[3, 1]\n[3, 2]</p>\n<ul>\n<li>사실 구현할 때 헷갈려서 그렇지 한번 구현하고 이해하고 나면 그다지 어렵지 않다.</li>\n</ul>\n<pre><code class=\"language-java\">\npackage java_0621;\n\nimport java.util.Arrays;\n\npublic class PermutationTest {\n    private static int n, r;\n    private static int[] arr; // 원소를 저장할 배열\n    private static boolean[] visited; // 중복을 제거하기 위한 방문 처리\n    public static void main(String[] args) {\n        n = 4;//전체개수\n        r = 2; // 선택할 갯수\n        arr = new int[r]; //선택한 숫자 저장소\n        visited = new boolean[n + 1];//숫자 선택 여부 지정\n        /*n + 1인 이유?\n        * 숫자는 1부터 시작하고 배열은 0부터 시작하기 때문에*/\n        permutation(0);\n    }//end main()\n    // 순열\n    private static void permutation(int cnt) {\n        if (cnt == r) {\n            System.out.println(Arrays.toString(arr));\n            return;\n        }\n        for (int i = 1; i &lt;= n; i++) {\n            if (visited[i]==false) {\n                visited[i] = true;\n                arr[cnt] = i;\n                permutation(cnt + 1);\n                visited[i] = false;\n            }//end if\n        }//end for\n    }//end permutation()\n</code></pre>\n<ul>\n<li><p>전체 숫자의 개수가 n개이고 선택할 숫자의 개수를 r개라고 했을 때, 선택한 숫자를 저장할 r크기의 배열이 하나 필요하고,</p>\n<ul>\n<li><p>4개의 숫자를 방문했는지 체크할 boolean 형 배열이 [n+1] 필요하다. (배열은 0부터 시작 for문을 통해 1부터 방문함)</p>\n</li>\n<li><p>메서드는 cnt가 r이 되면 해당 arr의 요소들을 반환하고 , return 하여 함수호출을 종료한다.</p>\n</li>\n</ul>\n</li>\n</ul>\n<ul>\n<li>백트래킹 방법을 사용하였다</li>\n</ul>\n<h3 id=\"백트래킹이란\">백트래킹이란?</h3>\n<ul>\n<li><p>여기서 백트래킹이란 탐색 알고리즘의 일종으로 가능한 모든 해를 탐색하는 과정에서 특정 조건을 만족하지 않는 경로를 조기에 배제하여 탐색 효율을 높이는 방법이다. 주로 순열,조합,부분집합, 그래프 탐색 문제를 해결하는 데 사용됨.</p>\n</li>\n<li><p>백트래킹은 완전 탐색, 효율적 탐색,재귀적 접근, 상태 되돌리기 등의 특징을 가진다. </p>\n</li>\n<li><p>추후에 자세히 다루겠다.</p>\n</li>\n</ul>\n<h3 id=\"조합\">조합</h3>\n<ul>\n<li><p>조합은 순열과 다르게 순서가 존재하지 않는 r개의 숫자를 뽑는다고 생각하면 된다. </p>\n</li>\n<li><p>순서가 존재하지 않는다 = 즉, 뽑는 순서에 상관없이 같은 숫자로 이루어져있으면 같은 숫자로 취급하기에 해당 경우를 배제한다.</p>\n</li>\n<li><p>순열에서 1,2 와 2,1은 다른 숫자이다. 왜? 순서가 존재하기 때문에</p>\n</li>\n<li><p>하지만, 조합에서 1,2 와 2,1은 같은 숫자이기 때문에 배제한다.</p>\n</li>\n</ul>\n<pre><code class=\"language-java\">\npackage java_0621;\nimport java.util.Arrays;\npublic class Combination_Test {\n    private static int n, r;\n    private static int[] arr; // 원소를 저장할 배열\n    private static boolean[] visited; // 중복을 제거하기 위한 방문 처리\n    public static void main(String[] args) {\n        n = 4;\n        r = 2;\n        arr = new int[r];\n        visited = new boolean[n + 1];\n        combination(0,1);\n    }\n    // 조합\n    private static void combination(int cnt, int start) {\n        if (cnt == r) {\n            System.out.println(Arrays.toString(arr));\n            return;\n        }\n        for (int i = start; i &lt;= n; i++) {\n            arr[cnt] = i;\n            combination(cnt + 1, i + 1); // 오름차순으로 구하면 중복 체크하지 않아도 됨\n        }\n    }\n}</code></pre>\n<ul>\n<li><p>조합에서는 순서가 중요하지 않기 때문에, 선택된 원소의 순서는 상관없다. </p>\n</li>\n<li><p>이를 구현하기 위해 재귀 호출 시 다음 선택할 원소의 범위를 제한하여 중복을 방지한다. 즉, 이전에 선택한 원소보다 큰 원소만 선택하도록 하는 것, </p>\n</li>\n<li><p>순열은 visited 배열을 사용하여 중복 선택을 방지하긴 하지만, 매번 1~n 까지 모든 원소를 고려하여 선택하고, 조합은 이미 함수를 호출 할 때부터 선택된 원소보다 큰 원소에서 시작하기 때문에 중복을 방지할 수 있다.</p>\n</li>\n</ul>\n",
    "pubDate": "Fri, 05 Jul 2024 16:07:14 GMT",
    "thumbnail": null
  },
  {
    "title": "[HTML] block & inline",
    "link": "https://velog.io/@gawgjiug/HTML-block-inline",
    "description": "<h3 id=\"html-block--inline\">HTML block &amp; inline</h3>\n<ul>\n<li><p><code>HTML tag</code> 들은 두가지 형태의 속성을 가지고 웹 브라우저에 출력됨.</p>\n</li>\n<li><p>블록 형태</p>\n</li>\n<li><p>인라인 형태</p>\n</li>\n</ul>\n<h4 id=\"블록block-형태\">블록(block) 형태</h4>\n<ul>\n<li>블록 형태의 속성을 가진 Tag 들은 말 그대로 네모 블록 모양을 가진다. </li>\n<li>항상 새로운 줄에서 시작하며 해당 줄의 모든 너비를 차지함.</li>\n</ul>\n<h4 id=\"div-tag\">div Tag</h4>\n<ul>\n<li><p>블록 형태의 속성을 가진 가장 대표적인 Tag로서</p>\n</li>\n<li><p>다른 HTML Tag 들을 하나로 묶는 데 자주 사용한다.</p>\n</li>\n<li><p>하나로 묶인 HTML Tag에 CSS 스타일을 한번에 적용하는데 자주 사용한다.</p>\n</li>\n</ul>\n<h4 id=\"블록-형태의-대표적인-tags\">블록 형태의 대표적인 Tags</h4>\n<pre><code class=\"language-html\">\n&lt;div&gt; &lt;p&gt; &lt;ol&gt; &lt;ul&gt; &lt;li&gt; &lt;h#&gt; &lt;pre&gt; &lt;blockquote&gt; &lt;form&gt; &lt;table&gt; &lt;header&gt;\n\n&lt;nav&gt; &lt;section&gt; &lt;article&gt; &lt;aside&gt; &lt;footer&gt; &lt;video&gt; &lt;dl&gt; &lt;dt&gt; &lt;dd&gt; &lt;noscript&gt;</code></pre>\n<h4 id=\"인라인inline형태\">인라인(inline)형태</h4>\n<ul>\n<li>인라인 형태의 속성을 가진 Tag들은 새로운 줄에서 시작하지 않으며, 해당 줄의 너비는 내용만큼만 가진다.</li>\n</ul>\n<p>대표적으로 <code>span</code> 태그가 있다 </p>\n<ul>\n<li>텍스트의 특정 부분을 강조하는데 자주 사용하고, 텍스트의 특정 부분에 CSS 스타일을 적용하기 위해 자주 사용한다.</li>\n</ul>\n<pre><code class=\"language-html\">\n&lt;p&gt; 우리는 &lt;span style = &quot;color:red&quot;&gt; HTML &amp; CSS &lt;/span&gt; 를 공부하고 있습니다.\n\n</code></pre>\n<h4 id=\"인라인inline-형태의-대표적인-tags\">인라인(inline) 형태의 대표적인 Tags</h4>\n<pre><code class=\"language-html\">\n\n\n&lt;span&gt; &lt;a&gt; &lt;q&gt; &lt;b&gt; &lt;em&gt; &lt;small&gt; &lt; strong&gt; &lt;sup&gt; &lt;sub&gt; &lt;input&gt; &lt;img&gt;\n\n&lt;br&gt; &lt;big&gt; &lt;select&gt; &lt;i&gt; &lt;button&gt; &lt;code&gt; &lt;textarea&gt; \n&lt;map&gt; &lt;mark&gt; &lt;script&gt;</code></pre>\n",
    "pubDate": "Thu, 04 Jul 2024 14:41:11 GMT",
    "thumbnail": null
  }
]