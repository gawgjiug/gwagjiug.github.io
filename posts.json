[
  {
    "title": "[React] 데이터 흐름 & State 끌어올리기",
    "link": "https://velog.io/@gawgjiug/React-%EB%8D%B0%EC%9D%B4%ED%84%B0-%ED%9D%90%EB%A6%84-State-%EB%81%8C%EC%96%B4%EC%98%AC%EB%A6%AC%EA%B8%B0",
    "description": "<p><img src=\"https://velog.velcdn.com/images/gawgjiug/post/53d42732-237a-4896-b057-703a4f5a220e/image.gif\" alt=\"\"></p>\n<p><a href=\"https://www.youtube.com/shorts/u86KSUc9Ngg?feature=share\">출처</a></p>\n<ul>\n<li><p>리액트는 기본적으로 단방향 데이터 흐름을 가지고 있다. 부모 -&gt; 자식 </p>\n</li>\n<li><p>하지만 부모 컴포넌트에서의 상태가 하위 컴포넌트에 의해 변하는 경우가 종종 있다.</p>\n</li>\n<li><p>예를 들면, 하위 컴포넌트에서의 클릭 이벤트가 부모의 상태를 바꾸어야만 하는 상황이 왔다면, </p>\n</li>\n<li><p>이를 해결할 수 있는 개념이 바로 State 끌어올리기 이다.</p>\n</li>\n<li><p>컴포넌트는 props 형태로 속성을 내려 받아 인자로 사용할 수 있는데, State 끌어올리기는 이 props로 상태를 변경시키는 함수를 전달하여 문제를 해결하는 방법을 말한다.</p>\n</li>\n</ul>\n<blockquote>\n</blockquote>\n<p>상위 컴포넌트의 &quot;상태를 변경하는 함수&quot; 그 자체를 하위 컴포넌트로 전달하고 이 함수를 하위 컴포넌트가 실행한다.</p>\n<p>라는 개념이다.</p>\n<ul>\n<li>여전히 단방향 데이터 흐름의 원칙에 부합하는 해결방식라고 할 수 있다.</li>\n</ul>\n<pre><code class=\"language-javascript\">import React, { useState } from &#39;react&#39;;\n\n// Parent Component\nfunction Parent() {\n  // 부모 컴포넌트의 상태\n  const [count, setCount] = useState(0);\n\n  // 상태를 업데이트하는 함수\n  const handleUpdateCount = () =&gt; {\n    setCount(count + 1);\n  };\n\n  return (\n    &lt;div&gt;\n      &lt;h1&gt;Parent Component&lt;/h1&gt;\n      &lt;p&gt;Count: {count}&lt;/p&gt;\n      {/* Child 컴포넌트에 상태 업데이트 함수를 props로 전달 */}\n      &lt;Child onButtonClick={handleUpdateCount} /&gt;\n    &lt;/div&gt;\n  );\n}\n\n// Child Component\nfunction Child({ onButtonClick }) {\n  return (\n    &lt;div&gt;\n      &lt;h2&gt;Child Component&lt;/h2&gt;\n      {/* 버튼 클릭 시 부모로부터 받은 함수를 호출 */}\n      &lt;button onClick={onButtonClick}&gt;Increase Count&lt;/button&gt;\n    &lt;/div&gt;\n  );\n}\n\nexport default Parent;</code></pre>\n<hr>\n<h3 id=\"정리❗\">정리❗</h3>\n<blockquote>\n</blockquote>\n<p>React는 기본적으로 단방향 데이터 흐름이라는 원칙을 가진다.</p>\n<ul>\n<li>상위 컴포넌트에서 하위로는 이동할 수 있지만 반대로는 불가하다. \n그러나 종종 동일한 데이터에 대한 변경사항을 여러 컴포넌트에 반영할 필요가 생긴다.</li>\n</ul>\n<blockquote>\n<ul>\n<li>이 때, state 끌어올리기 개념으로 데이터 변경사항을 상위 컴포넌트로 전달할 수 있다.</li>\n</ul>\n</blockquote>\n<blockquote>\n<ul>\n<li>데이터를 직접 상위로 전달하는 것과는 다르게, state를 직접 전달하는 것이 아닌 \n   state 갱신 함수를 전달 받아 해당 함수를 실행시키는 원리이다.</li>\n</ul>\n</blockquote>\n",
    "pubDate": "Wed, 28 Aug 2024 07:20:03 GMT",
    "thumbnail": null
  },
  {
    "title": "What is State? ",
    "link": "https://velog.io/@gawgjiug/What-is-State",
    "description": "<h3 id=\"state-in-react\">state in React</h3>\n<ul>\n<li><p>What is State ??</p>\n</li>\n<li><p>컴포넌트는 사용자와의 상호작용 결과로서 화면을 리렌더링 할 때가 자주 있다. 예를 들면 사용자가 Form에 정보를 입력했다던가, 버튼을 클릭해서 이미지를 보여주게 한다던가 하는 동작 말이다.</p>\n</li>\n<li><p>이렇게 컴포넌트는 로직의 처리를 위해 <strong>특정한 값들을 저장해야 할 필요</strong> 가 있으며, React 에서는 이를 <code>state</code> 라고 정의하였다.</p>\n</li>\n<li><p><code>state</code> 값이 변경되었을 경우 React 는 해당 컴포넌트를 리렌더링 한다. 따라서 <code>state</code> 의 변화는 컴포넌트의 리렌더링을 유발시키는 요인이라고 볼 수 있다.</p>\n</li>\n</ul>\n<h3 id=\"로컬-변수와-state의-차이점\">로컬 변수와 state의 차이점</h3>\n<pre><code class=\"language-jsx\">function Counter() {\n    let count = 0;\n\n    function increaseCount() {\n        count += 1;\n        console.log(count);\n    }\n\n    function decreaseCount() {\n        count -= 1;\n        console.log(count);\n    }\n\n    return (\n        &lt;div&gt;\n            &lt;button onClick={increaseCount}&gt;+1&lt;/button&gt;\n            &lt;button onClick={decreaseCount}&gt;-1&lt;/button&gt;\n            &lt;p&gt;Count : {count}&lt;/p&gt;\n        &lt;/div&gt;\n    );\n}\n\nexport default Counter;</code></pre>\n<ul>\n<li><p>해당 코드를 언뜻 보면 평범하게 버튼을 클릭하여 count 값의 증감을 화면에 렌더링하는 코드로 볼 수 있다.</p>\n</li>\n<li><p>하지만 위 코드는 count 값이 화면에 업데이트 되지 않는다.</p>\n</li>\n<li><p>여기서 count 는 Js 일반 지역변수로 선언되었다, React의 상태 관리 메커니즘인 <code>useState</code> 를 사용하지 않았기 때문에, React는 이 변수를 추적하거나 변경 사항을 감지하지 않는다.</p>\n</li>\n<li><p>리렌더링은 React 컴포넌트의 상태(<code>state</code>) 나 속성(<code>props</code>)이 변경될 때 발생한다.</p>\n</li>\n<li><p>현재 코드에서는 <code>count</code>가 일반 지역 변수로 설정되어 있어, 이 값이 변경되어도 컴포넌트가 다시 렌더링 되지 않는다.</p>\n</li>\n</ul>\n<h4 id=\"그래서-왜-count-값이-화면에-업데이트-되지-않는-것인지\">그래서 왜 count 값이 화면에 업데이트 되지 않는 것인지?</h4>\n<ul>\n<li><p>버튼을 클릭하면 increaseCount 나 decreaseCount 함수가 실행되어 <code>count</code> 값을 증기시키거나 감소시킨다.</p>\n</li>\n<li><p>하지만 이러한 변화는 단지 메모리 내에서의 값 변경일 뿐 React 가 이를 인지하지는 못한다. 그리고 상태나 속성이 변경된 것이 아니기 때문에 리렌더링이 발생하지도 않는다.</p>\n</li>\n<li><p>그렇기에 console 에는 count의 변경 값이 잘 나오겠지만, 화면에는 초기 렌더링 상태인 0 을 그대로 유지하는 것이다.</p>\n</li>\n<li><p>이를 해결하기 위해서 useState를 사용하여 count 값을 상태로 선언하고, 상태 변경 함수인 setCount를 사용하여 count 값을 업데이트 해야한다.</p>\n</li>\n</ul>\n<pre><code class=\"language-javascript\">import { useState } from &#39;react&#39;;\n\nfunction Counter() {\n  const [count, setCount] = useState(0); // count를 상태로 선언\n\n  function increaseCount() {\n    setCount(count + 1); // 상태 업데이트\n  }\n\n  function decreaseCount() {\n    setCount(count - 1); // 상태 업데이트\n  }\n\n  return (\n    &lt;div&gt;\n      &lt;button onClick={increaseCount}&gt;+1&lt;/button&gt;\n      &lt;button onClick={decreaseCount}&gt;-1&lt;/button&gt;\n      &lt;p&gt;Count: {count}&lt;/p&gt; {/* 최신 상태 값이 화면에 업데이트됨 */}\n    &lt;/div&gt;\n  );\n}\n\nexport default Counter;</code></pre>\n<ul>\n<li>이렇게 하면 increaseCount나 decreaseCount 함수가 setCount를 호출할 때마다 React가 count 상태의 변경을 감지하고 컴포넌트를 다시 렌더링하여 화면에 최신 상태 값을 반영한다.</li>\n</ul>\n<hr>\n<h3 id=\"state-is-private--isolated\">State is private, &amp;&amp; isolated</h3>\n<ul>\n<li>state 는 자신이 속한 컴포넌트의 종속적이다. 그 말은 즉슨, 만약 같은 컴포넌트를 두 차례 랜더링 하더라도, 각 컴포넌트에 속한 state는 서로 독립적으로 작동한다.</li>\n</ul>\n<h3 id=\"batching\">Batching</h3>\n<ul>\n<li><p>batching 은 React 에서 성능 최적화를 위해 여러 개의 상태 업데이트를 하나의 렌더링 사이클로 묶어서 처리하는 방식을 말한다.</p>\n</li>\n<li><p>이 방식으로 불필요한 리렌더링을 방지하고 성능을 최적화할 수 있다. 예를 들자면, 여러 개의 <code>setState</code> 호출이 있을 때, 각각의 setState 가 호출될 때 마다 컴포넌트가 리렌더링 되는 것이 아니라, 모든 setState 호출을 하나의 이벤트 루프에서 처리하고 한 번만 리렌더링 하는 것이다.</p>\n</li>\n</ul>\n<pre><code class=\"language-javascript\">import React, { useState } from &#39;react&#39;;\n\nfunction BatchExample() {\n  const [count1, setCount1] = useState(0);\n  const [count2, setCount2] = useState(0);\n\n  const handleClick = () =&gt; {\n    // 두 상태 변수를 각각 업데이트합니다.\n    setCount1(count1 + 1);\n    setCount2(count2 + 1);\n\n    // 일반적으로는 두 개의 상태 업데이트가 각자 컴포넌트를 리렌더링할 수 있지만,\n    // React의 Batching 덕분에 한 번의 리렌더링만 발생합니다.\n    console.log(&#39;count1:&#39;, count1, &#39;count2:&#39;, count2);\n  };\n\n  return (\n    &lt;div&gt;\n      &lt;p&gt;Count 1: {count1}&lt;/p&gt;\n      &lt;p&gt;Count 2: {count2}&lt;/p&gt;\n      &lt;button onClick={handleClick}&gt;Increase Counts&lt;/button&gt;\n    &lt;/div&gt;\n  );\n}\n\nexport default BatchExample;</code></pre>\n<hr>\n<h3 id=\"리액트의-setstate-비동기처리\">리액트의 <code>setState</code> 비동기처리</h3>\n<ul>\n<li><code>setState</code> 함수가 호출될 때 즉시 상태가 변경되는 것이 아니라, 상태 업데이트 요청이 예약되고 리액트가 최적의 타이밍에 이 요청을 처리한다. 이러한 방식은 컴포넌트가 불필요하게 여러 번 리렌더링 되는 것을 방지한다.</li>\n</ul>\n<pre><code class=\"language-javascript\">import React, { useState } from &#39;react&#39;;\n\nfunction Counter() {\n  const [count, setCount] = useState(0);\n\n  const handleClick = () =&gt; {\n    setCount(count + 1); // 상태 업데이트 요청\n    console.log(&#39;Inside handleClick:&#39;, count); // 기존의 count 값을 출력\n  };\n\n  return (\n    &lt;div&gt;\n      &lt;p&gt;Count: {count}&lt;/p&gt;\n      &lt;button onClick={handleClick}&gt;Increase Count&lt;/button&gt;\n    &lt;/div&gt;\n  );\n}\n\nexport default Counter;</code></pre>\n<ol>\n<li><p>handleClick 함수를 호출한다</p>\n</li>\n<li><p>setCount(count + 1) 호출 여기서 함수가 count 값을 1 증가시키도록 요청, 하지만 이 시점에서 상태가 즉시 변경되지는 않음</p>\n</li>\n<li><p>console.log 실행: console.log는 이전의 count 값을 출력한다. 상태 업데이트가 비동기로 처리되기 때문에 count 는 아직 변경되지 않았기 때문.</p>\n</li>\n<li><p>리렌더링 리액트가 다음 리렌더링 주기에서 상태 업데이트를 적용하고 컴포넌트를 다시 렌더링 한다. </p>\n</li>\n</ol>\n<h3 id=\"비동기의-이유\">비동기의 이유</h3>\n<ul>\n<li><p>성능 최적화 : 여러 개의 상태 업데이트 요청을 한 번에 처리하여 리렌더링 횟수를 줄인다. 예를 들어, 연속적으로 여러 번 setState가 호출되면, 리액트는 이를 모아서 한 번만 리렌더링한다.</p>\n</li>\n<li><p>일관된 UI 상태 유지 : 비동기 업데이트를 통해 컴포넌트가 중간 상태를 보지 않고, 항상 이관된 상태를 유지한다. 만약 상태 업데이트가 동기적으로 처리된다면, 각 상태 변경 후에 컴포넌트가 즉시 리렌더링 되어 UI가 깜빡이거나 불안정해질 수 있음.</p>\n</li>\n<li><p>Batching(일괄 처리): React는 이벤트 핸들러 내에서 여러 setState 호출이 발생하더라도 이를 일괄 처리하여 한 번의 리렌더링만 발생시키도록 최적화한다.</p>\n</li>\n</ul>\n",
    "pubDate": "Wed, 28 Aug 2024 07:09:03 GMT",
    "thumbnail": null
  },
  {
    "title": "[React] React 의 Props && Children",
    "link": "https://velog.io/@gawgjiug/React-React-%EC%9D%98-Props-Children",
    "description": "<ul>\n<li>props와 state는 React 에서 데이터를 다룰 때 사용하는 개념이다.</li>\n</ul>\n<blockquote>\n<p>props : 부모에서 자식 컴포넌트로 데이터를 넘겨줄 때 사용하며 , 직접적으로 수정할 수 없는 값이다.</p>\n</blockquote>\n<blockquote>\n<p>state : Component 내부에서 관리하는 데이터로, 변경이 가능한 값을 말한다.</p>\n</blockquote>\n<h3 id=\"props\">Props</h3>\n<ul>\n<li>React 에서 한 Component 에서 다른 Component로 데이터를 전송할 때 사용하는 특수 객체가 props이다.</li>\n</ul>\n<h4 id=\"단방향-데이터-흐름\">단방향 데이터 흐름</h4>\n<ul>\n<li>그러나 <code>Props는 단방향으로 데이터를 전송한다는 특징</code> 이 있다. 그러므로 자식에서 부모로, 동일한 레벨의 Component로 Props를 전달하는 것은 불가능하다.</li>\n</ul>\n<pre><code class=\"language-jsx\">import &#39;./App.css&#39;;\nimport { useState } from &#39;react&#39;;\nimport Register from &#39;./components/Register&#39;;\nimport HookExam from &#39;./components/HookExam&#39;;\nimport Button from &#39;./components/Button&#39;;\nfunction App() {\n  // const [count, setCount] = useState(0);\n\n  const buttonProps = {\n    text: &#39;메일&#39;,\n    color: &#39;lightcoral&#39;,\n    a: 1,\n    b: 2,\n    c: 3,\n  };\n\n  return (\n    &lt;&gt;\n      &lt;Button {...buttonProps} /&gt;\n      &lt;Button text={&#39;블로그&#39;}&gt;\n        &lt;div&gt;자식요소&lt;/div&gt;\n        &lt;span&gt;다른 자식요소&lt;/span&gt;\n      &lt;/Button&gt;\n    &lt;/&gt;\n  );\n}\n\nexport default App;</code></pre>\n<pre><code class=\"language-jsx\">const Button = ({ text, color = &#39;black&#39;, children }) =&gt; {\n  //이벤트 객체\n  const onClickButton = (e) =&gt; {\n    console.log(e);\n    console.log(text);\n  };\n  // 마우스 엔터 이벤트 핸들러\n  const onMouseEnter = (e) =&gt; {\n    e.target.style.backgroundColor = &#39;lightgreen&#39;;\n  };\n\n  // 마우스가 버튼을 떠날 때 배경색을 원래대로 돌리는 핸들러\n  const onMouseLeave = (e) =&gt; {\n    e.target.style.backgroundColor = &#39;&#39;;\n  };\n\n  console.log(`children = ${children}`);\n  return (\n    &lt;button\n      onClick={onClickButton}\n      onMouseEnter={onMouseEnter}\n      onMouseLeave={onMouseLeave}\n      style={{ color: color }}\n    &gt;\n      {text} - {color.toUpperCase()}\n      {children}\n    &lt;/button&gt;\n  );\n};\n\nexport default Button;</code></pre>\n<p><img src=\"https://velog.velcdn.com/images/gawgjiug/post/1d0adf8e-46ea-4fe2-ae8f-1da66fe3735d/image.png\" alt=\"\"></p>\n<ul>\n<li><p>props로 데이터를 전달하는 방법은 우선 Component에 prop을 정의하고 값을 할당해야 한다.</p>\n</li>\n<li><p>부모 컴포넌트인 App.jsx에서 ButtonProps를 정의하고, Button 컴포넌트를 호출하면서 동시에 props로 값을 넘겨주었다.</p>\n</li>\n<li><p>하나의 컴포넌트에는 spread 연산자로 buttonProps 객체의 값 전체를 넘겨주었고, 다른 하나의 Button 컴포넌트는 직접 text 값을 넘겨주어 표시하였다.</p>\n</li>\n<li><p>여기서 children 개념이 등장하는데, React 공식 문서에서는 Children의 소개글을</p>\n</li>\n</ul>\n<blockquote>\n<p>여는 태그와 닫는 태그를 모두 포함하는 JSX 표현식에서 해당 태그 사이의\n내용은 특수 소품으로 전달됩니다 props.children. 여는 태그와 닫는 태그 사이에 문자열을 넣으면  props.children 해당 문자열이 됩니다.</p>\n</blockquote>\n<ul>\n<li><p>라고 번역되어 있다. 한 마디로 풀어서 말하면, &quot;태그와 태그 사이의 모든 애용을 표시하기 위해 사용되는 특수한 props&quot; 라고 할 수 있다.</p>\n</li>\n<li><p>즉,  컴포넌트가 렌더링될 때, 컴포넌트의 태그 사이에 포함된 내용을 자동으로 자식요소로 전달하는 특수한 prop 이라고 할 수 있다.</p>\n</li>\n<li><p>위 코드에서 첫 번째 <code>Button</code> 컴포넌트는 <code>text</code>와 <code>color</code> props를 전달받지 않으므로 기본값이 적용된다.</p>\n</li>\n<li><p>두 번째 <code>Button</code> 컴포넌트는 <code>text</code>와 <code>color</code> 를 전달 받으며, <code>div</code> 와 <code>span</code> 요소를 <code>children</code> 으로 전달한다.</p>\n</li>\n<li><p>children은 Button 컴포넌트의 시작 태그와 종료 태그 사이에 포함된 내용이 됩니다. 예를 들어, 두 번째 Button 컴포넌트에서 {children}은 <div>자식요소</div>와 <span>다른 자식요소</span>를 포함한다.</p>\n</li>\n</ul>\n<hr>\n<h3 id=\"요약\">요약</h3>\n<ul>\n<li><code>children</code> : React에서 컴포넌트의 시작 태그와 종료 태그 사이에 포함된 모든 내용을 의미한다. 이 내용은 자식 컴포넌트의 <code>children</code> prop 으로 전달되어 컴포넌트 내부에서 사용된다.</li>\n</ul>\n",
    "pubDate": "Wed, 28 Aug 2024 05:32:43 GMT",
    "thumbnail": null
  },
  {
    "title": "JS (비동기 프로그래밍 , 이벤트 루프 & 테스크 큐)",
    "link": "https://velog.io/@gawgjiug/JS-%EB%B9%84%EB%8F%99%EA%B8%B0-%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8D-%EC%9D%B4%EB%B2%A4%ED%8A%B8-%EB%A3%A8%ED%94%84-%ED%85%8C%EC%8A%A4%ED%81%AC-%ED%81%90",
    "description": "<h3 id=\"비동기-프로그래밍\">비동기 프로그래밍</h3>\n<ul>\n<li><p>Javascript는 기본적으로 <code>싱글 스레드 언어</code> 이다. &#39;싱글&#39; 스레드라 한 번에 하나의 작업만 수행이 가능하다.</p>\n</li>\n<li><p>멀티 스레드를 지원하여 원하는 코드 로직을 동시에 수행 시키는 멀티 작업이 가능한 <code>Java</code> 나 <code>Python</code> 과는 다른 것</p>\n</li>\n<li><p>하지만 당연히 웹 애플리케이션에서는 네트워크 요청이나 이벤트 처리, 타이머와 같은 작업은 멀티 (병렬) 처리되어야 한다. 만일 싱글 스레드로 브라우저 동작이 한번에 하나씩 수행하게 되면, 우리가 파일을 다운로드 받을 동안 브라우저는 파일을 다 받을 때 까지 정지하게 됨..</p>\n</li>\n<li><p>따라서 파일 다운, 네트워크 요청, 타이머, 애니메이션 이러한 시간이 소요되고 반복적인 작업들은 JS 엔진이 아니라 <strong>브라우저 내부의 멀티 스레드인 Web APIs</strong> 에서 비동기적으로 처리된다. </p>\n</li>\n</ul>\n<p><img src=\"https://velog.velcdn.com/images/gawgjiug/post/3430120e-27c4-42c7-b762-4323b826b8d4/image.png\" alt=\"\"></p>\n<ul>\n<li>즉, 비동기로 동작하는 핵심요소는 JS 언어가 아니라 브라우저라는 소프트웨어가 가지고 있다고 보면된다. </li>\n</ul>\n<hr>\n<h3 id=\"이벤트-루프-event-loop\">이벤트 루프 (Event Loop)</h3>\n<ul>\n<li>이벤트 루프는 비동기 작업이 처리되는 어떠한 메커니즘을 의미한다. 싱글 스레드 환경에서 이벤트 루프는 자바스크립트와 같은 비동기 프로그래밍 언어에서 매우 중요하게 작용한다.</li>\n</ul>\n<p><img src=\"https://velog.velcdn.com/images/gawgjiug/post/175fef60-0fd0-40f8-8c9d-e162d20a440a/image.png\" alt=\"\"></p>\n<ul>\n<li>자바스크립트의 작업을 멀티 스레드로 돌려 작업을 동시에 처리시키게 한다던가, 또는 여러 작업 중 어떤 작업을 우선으로 동작시킬 것인지 결정하는 컨트롤을 하기 위해 존재하는 것이 이벤트 루프인 것이다.</li>\n</ul>\n<p><img src=\"https://velog.velcdn.com/images/gawgjiug/post/d79b62fb-e59a-43da-b95f-8cbaa1ecf0b1/image.png\" alt=\"\"></p>\n<p><img src=\"https://velog.velcdn.com/images/gawgjiug/post/b01c7430-b135-48d8-8a5a-b65c8151671f/image.png\" alt=\"\"></p>\n<p><img src=\"https://velog.velcdn.com/images/gawgjiug/post/f73dc984-fb2f-4cc5-b917-f4a9a489d580/image.png\" alt=\"\"></p>\n<ul>\n<li><p>위 그림을 참고하여 이벤트 루프와 <code>테스크 큐</code> 에 개념에 대해서 설명할 수 있다.</p>\n</li>\n<li><p>이벤트 루프는 브라우저 내부의 <code>Call Stack</code>, <code>Task Queue</code> , <code>Web APIs</code> 등의 요소들을 모니터링 하면서 비동기적으로 실행되는 작업들을 관리하고 이를 순서대로 처리하여 프로그램의 실행 흐름을 제어하는 녀석이다. </p>\n</li>\n<li><p>간단하게 말하면 <code>브라우저의 동작 타이밍을 제어하는 관리자</code> 라고 보면된다.</p>\n</li>\n<li><p>여기서 <code>콜 스택(Call Stack)</code> 이란 함수가 호출될 때 그 함수가 실행되는 환경(컨텍스트)이 스택에 추가되는 공간을 말한다.</p>\n</li>\n<li><p><code>테스크 큐(Task Queue)</code> 는 비동기 작업의 콜백 함수들이 대기하는 큐 공간을 말한다. WebAPIs에서 진행되는 비동기 작업이 완료되면 해당 작업의 콜백이 테스크 큐에 추가된다.</p>\n</li>\n<li><p><code>이벤트 루프</code> 는 콜 스택이 비어있을 때 테스크 큐에 있는 작업을 콜 스택으로 이동시켜 실행한다. 이러한 과정을 통해 비동기 작업이 실행되는 것.</p>\n</li>\n</ul>\n",
    "pubDate": "Tue, 20 Aug 2024 13:54:14 GMT",
    "thumbnail": null
  },
  {
    "title": "JS (변수 & 호이스팅)",
    "link": "https://velog.io/@gawgjiug/JS-%EB%B3%80%EC%88%98-%ED%98%B8%EC%9D%B4%EC%8A%A4%ED%8C%85",
    "description": "<h2 id=\"1-호이스팅-hoisting\">1. 호이스팅 (Hoisting)</h2>\n<h3 id=\"개요\">개요</h3>\n<ul>\n<li><p>호이스팅은 자바스크립트에서 변수와 함수 선언이 코드 실행 전에 메모리 상단으로 끌어올려지는 현상이다. </p>\n</li>\n<li><p>이로 인해 변수와 함수는 실제 코드 실행 전에 선언될 수 있다.</p>\n</li>\n</ul>\n<h3 id=\"변수-호이스팅\">변수 호이스팅</h3>\n<ul>\n<li><p><strong>예시 코드</strong>:</p>\n<pre><code class=\"language-javascript\">console.log(x); // undefined\nvar x = 5;\nconsole.log(x); // 5</code></pre>\n<ul>\n<li>위 코드는 호이스팅에 의해 다음과 같이 변환된다.</li>\n</ul>\n</li>\n</ul>\n<pre><code class=\"language-javascript\">  var x;\n  console.log(x); // undefined\n  x = 5;\n  console.log(x); // 5</code></pre>\n<ul>\n<li><p>여기서 변수 &#39;x&#39;는 선언만 끌어올려지고, 초기화는 원래 위치에서 이루어진다.</p>\n</li>\n<li><p><code>var</code>는 선언과 동시에 초기화가 이루어진다. 즉, 선언과 동시에 undefiend가 할당되는 것.</p>\n</li>\n<li><p>그러나 <code>let</code> 과 <code>const</code>는 다르다. 선언만 될 뿐 초기화가 이루어지지 않는 <code>TDZ</code> 에 들어가게 된다.</p>\n</li>\n<li><p><code>TDZ</code>란? Temporal Dead Zone 으로 자바스크립의 변수 생성 단계 중 첫 번째 단계인 <strong>선언</strong> 단계에서 변수 객체가 생성되고 초기화 되지 않은 상태에 이른 것을 말한다.</p>\n</li>\n<li><p>모든 선언(function, var, let, const, 및 class)는 Javascript에서 호이스팅 되며, var 선언은 undefined로 초기화 되지만, let 및 const 선언은 초기화 되지 않은 상태로 유지된다.</p>\n</li>\n</ul>\n<pre><code class=\"language-java\">console.log(hoist); // Output: undefined\nvar hoist = &#39;The variable has been hoisted.&#39;;</code></pre>\n<pre><code class=\"language-javascript\">console.log(hoist); // Output: ReferenceError: hoist is not defined ...\nlet hoist = &#39;The variable has been hoisted.&#39;;</code></pre>\n<h3 id=\"함수-호이스팅\">함수 호이스팅</h3>\n<ul>\n<li>함수는 선언 자체가 호이스팅 되어 호출하기 전에 정의된 함수를 사용할 수 있다.</li>\n</ul>\n<pre><code class=\"language-javascript\">foo(); // &quot;Hello&quot;\n\nfunction foo() {\n    console.log(&quot;Hello&quot;);\n}</code></pre>\n<h3 id=\"결론\">결론</h3>\n<ul>\n<li><p>호이스팅은 함수를 어디에 선언 하였든지, 신경 스지 않고 필요한 곳에서 자유롭게 사용하기 위해 만들어진 기능이다.</p>\n</li>\n<li><p>그러나 이 기능이 때로는 의도치 않은 버그를 생성할 여지가 있고, 따라서 호이스팅을 의도적으로 사용하는 경우가 아니라면 호이스팅이 되지 않거나,</p>\n</li>\n<li><p>TDZ 으로 초기화 되는 <code>let</code>,<code>const</code> 함수 표현식을 사용하는 것을 권장</p>\n</li>\n</ul>\n<hr>\n<h2 id=\"2-var-키워드의-문제점\">2. &#39;var&#39; 키워드의 문제점</h2>\n<h3 id=\"스코프-문제\">스코프 문제</h3>\n<ul>\n<li><p><code>var</code> 로 선언된 변수는 함수 전체에서 유효하다. 블록 내에서 선언을 해도 블록 외부에서 접근 가능한 것이 특징이고</p>\n</li>\n<li><p><code>let</code> 으로 선언된 변수는 블록 내에서만 유효하다. 블록 외부에서 접근하려고하면 <code>ReferenceError</code> 가 발생</p>\n</li>\n</ul>\n<pre><code class=\"language-javascript\">function example() {\n    if (true) {\n        var x = 10;\n    }\n    console.log(x); // 10\n}\n\nexample();</code></pre>\n<h3 id=\"재선언-문제\">재선언 문제</h3>\n<ul>\n<li>같은 스코프 내에서 같은 이름의 변수를 여러 번 선언할 수 있다. 이러한 점은 코드의 예측 가능성을 낮출 수 있음</li>\n</ul>\n<pre><code class=\"language-javascript\">var z = 30;\nvar z = 40; // 재선언 가능\nconsole.log(z); // 40</code></pre>\n",
    "pubDate": "Tue, 13 Aug 2024 08:36:22 GMT",
    "thumbnail": null
  },
  {
    "title": "JS 'this' ",
    "link": "https://velog.io/@gawgjiug/JS-this",
    "description": "<h3 id=\"this는-무엇인가\">this는 무엇인가?</h3>\n<hr>\n<ul>\n<li><p>대부분의 경우 <code>tihs</code>의 값은 함수를 호출한 방법에 의해 결정된다.</p>\n</li>\n<li><p><code>this</code> 는 호출한 놈을 말한다.</p>\n</li>\n<li><p>기본적으로는 <code>this</code> 는 window 객체를 말한다.</p>\n</li>\n<li><p>예외의 경우 </p>\n</li>\n</ul>\n<ol>\n<li><p>화살표 함수에서 <code>this</code> 가 조금 달라진다.</p>\n</li>\n<li><p>Strict Mode에서는 <code>this</code> 가 조금 달라진다.</p>\n</li>\n</ol>\n<h4 id=\"this\">this</h4>\n<hr>\n<ul>\n<li>대부분의 경우 <code>this</code> 의 값은 함수를 호출한 방법 즉,  호출한 놈에 의해 결정된다.</li>\n</ul>\n<pre><code class=\"language-js\">function printThis() {\n  console.log(this);\n}\nprintThis(); // window 객체\n\nlet person1 = {\n  name: &#39;김길동&#39;,\n  whoIsThis: printThis,\n};\n\nlet person2 = {\n  name: &#39;홍길동&#39;,\n  whoIsThis: printThis,\n};\n\nlet person3 = {\n  name: &#39;짐길동&#39;,\n  whoIsThis: printThis,\n};\n\nperson1.whoIsThis(); // person1 객체\nperson2.whoIsThis(); // person2 객체\nperson3.whoIsThis(); // person3 객체</code></pre>\n<h4 id=\"bind-함수\">bind 함수</h4>\n<ul>\n<li><code>bind</code> 함수로 <code>this</code>를 설정할 수 있다.</li>\n</ul>\n<pre><code class=\"language-js\">function print() {\n  console.log(&#39;this: &#39;, this);\n  console.log(&#39;this.fullname: &#39;, this.fullname);\n}\n\nlet person1 = {\n  fullname: &#39;홍길동&#39;,\n};\nlet person2 = {\n  fullname: &#39;김길동&#39;,\n};\nlet bindPrint = print.bind(person1); // person1 객체로 바인딩\nbindPrint(); // person1\nlet bindPrint2 = bindPrint.bind(person2);\nbindPrint2(); // person1! bind는 단 한번만 할 수 있다.</code></pre>\n<h4 id=\"arrow-function-this\">Arrow Function this</h4>\n<hr>\n<ul>\n<li><p>화살표 함수가 나오기 전 까지는 함수는 어떻게 호출되는지에 따라 자신의 <code>this</code> 값을 정의했다.</p>\n</li>\n<li><p>하지만 화살표 함수는 자신을 포함하고 있는 외부 Scope에서 this를 계승받는다.</p>\n</li>\n</ul>\n<pre><code class=\"language-js\">let person = {\n  name: &#39;곽지욱&#39;,\n  printThis: function () {\n    console.log(this) //person 객체\n    setTimeout(() =&gt; {\n      console.log(this); // person 객체\n    });\n  },\n};</code></pre>\n<ul>\n<li>화살표 함수를 사용할 경우 나를 감싸고 있는 상위 스코프의 this를 계승받기 때문에 person 객체를 받는 것</li>\n</ul>\n<pre><code class=\"language-js\">let person = {\n    name: &#39;곽지욱&#39;,\n    printThis: () =&gt; {\n        console.log(this); // window 객체 출력\n    }\n};</code></pre>\n<ul>\n<li>그렇기에 위 경우에서는 상위 스코프가 전역 스코프이기 때문에 window 객체를 출력하는 것</li>\n</ul>\n<h4 id=\"strict-mode\">Strict Mode</h4>\n<hr>\n<ul>\n<li>엄격 모드에서는 호출한 놈이 없을 경우 기본값을 <code>window</code>로 하지 않고 <code>undefined</code>로 한다.</li>\n</ul>\n<pre><code class=\"language-js\">&#39;use strict&#39;;\nfunction printThis() {\n    console.log(this);\n}\nprintThis(); // undefined</code></pre>\n",
    "pubDate": "Mon, 12 Aug 2024 08:41:56 GMT",
    "thumbnail": null
  }
]