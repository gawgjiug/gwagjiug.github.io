[
  {
    "title": "React 날씨 정보 API 호출 ",
    "link": "https://velog.io/@gawgjiug/React-%EB%82%A0%EC%94%A8-%EC%A0%95%EB%B3%B4-API-%ED%98%B8%EC%B6%9C",
    "description": "<p>첫번째로 사이트에서 <code>APIKEY</code>를 가져와야 한다.</p>\n<blockquote>\n<p><a href=\"https://openweathermap.org\">https://openweathermap.org</a></p>\n</blockquote>\n<p>위의 링크를 타고 들어가서 회원가입을 한 후에 자기 닉네임 -&gt; my API Keys 에 들어가서 API 키를 가져오면 된다.</p>\n<h3 id=\"1-위치-정보-가져오기\">1. 위치 정보 가져오기</h3>\n<ul>\n<li><p>우선 사용자의 현재 위치를 가져오기 위해<code>navigator.geolacation.getCurrentPosition</code> 메서드를 사용한다. </p>\n</li>\n<li><p>이 메서드는 사용자의 위치 정보를 가져와 lat(위도), lon(경도) 값을 <code>location</code> 상태에 저장한다. 이때 위치 정보 가져오기에 실패할 경우 오류 메시지를 설정한다</p>\n</li>\n</ul>\n<pre><code class=\"language-javascript\">useEffect(() =&gt; {\n  const getLocation = () =&gt; {\n    if (!navigator.geolocation) {\n      setError(&#39;Geolocation is not supported by your browser&#39;);\n      return;\n    }\n\n    navigator.geolocation.getCurrentPosition(\n      (position) =&gt; {\n        setLocation({\n          lat: position.coords.latitude,\n          lon: position.coords.longitude,\n        });\n      },\n      () =&gt; {\n        setError(&#39;Unable to retrieve your location&#39;);\n      }\n    );\n  };\n\n  getLocation();\n}, []);</code></pre>\n<h4 id=\"2-날씨-및-공기질-데이터-가져오기\">2. 날씨 및 공기질 데이터 가져오기</h4>\n<ul>\n<li><p>위치 정보가 설정되면, OpenWeatherMap API 호출하여 현재 날씨, 공기질, 3일간의 에보 데이터를 가져온다. </p>\n</li>\n<li><p>데이터를 가져오기 위해 <code>fetch</code> API를 사용하며, 비동기적으로 모든 API 호출이 완료될 때 까지 기다리기 위해 <code>Promise.all</code>을 사용한다.</p>\n</li>\n</ul>\n<pre><code class=\"language-javascript\">useEffect(() =&gt; {\n  const fetchData = async () =&gt; {\n    if (!location) return;\n\n    try {\n      const { lat, lon } = location;\n      const weatherUrl = `https://api.openweathermap.org/data/2.5/weather?lat=${lat}&amp;lon=${lon}&amp;appid=${apiKey}&amp;units=metric`;\n      const airQualityUrl = `https://api.openweathermap.org/data/2.5/air_pollution?lat=${lat}&amp;lon=${lon}&amp;appid=${apiKey}`;\n      const forecastUrl = `https://api.openweathermap.org/data/2.5/forecast?lat=${lat}&amp;lon=${lon}&amp;appid=${apiKey}&amp;units=metric`;\n\n      const [weatherResponse, airQualityResponse, forecastResponse] =\n        await Promise.all([\n          fetch(weatherUrl),\n          fetch(airQualityUrl),\n          fetch(forecastUrl),\n        ]);\n\n      if (\n        !weatherResponse.ok ||\n        !airQualityResponse.ok ||\n        !forecastResponse.ok\n      ) {\n        throw new Error(&#39;Failed to fetch weather or air quality data&#39;);\n      }\n\n      const weatherData = await weatherResponse.json();\n      const airQualityData = await airQualityResponse.json();\n      const forecastData = await forecastResponse.json();\n\n      setWeatherData(weatherData);\n      setAirQualityData(airQualityData);\n      setForecastData(forecastData);\n      setLoading(false);\n    } catch (err) {\n      setError(err.message);\n      setLoading(false);\n    }\n  };\n\n  fetchData();\n}, [location, apiKey]);\n</code></pre>\n<ul>\n<li><p>이 useEffect 훅은 location과 apikey가 변경될 때 마다 실행되며, fetch 함수를 이용해서 네트워크 요청을 만들어서 데이터를 가져오는 데 사용된다.</p>\n</li>\n<li><p>주로 RESTful API 서버와 통신하여 데이터를 가져오거나 전송하는 데 사용된다.</p>\n</li>\n<li><p>async 는 함수 앞에 붙여서 해당 함수가 비동기 작업을 수행함을 나타낸다. </p>\n</li>\n<li><p><code>async</code> 함수는 항상 Promise를 반환하며 비동기 작업이 완료되면 resolve 상태의 Promise를 반환하며 오류가 발생하면 rejected 상태의 Promise를 반환한다.</p>\n</li>\n<li><p>Promise.all 을 사용해서 세 가지 데이터를 병렬로 가져온다. 병렬로 요청을 보내기 때문에, 순차적으로 요청하는 것보다 더 빠르게 데이터를 가져올 수 있다.</p>\n</li>\n</ul>\n<h3 id=\"3-json-데이터-파싱\">3. Json 데이터 파싱</h3>\n<pre><code class=\"language-javascript\">\nconst weatherData = await weatherResponse.json();\nconst airQualityData = await airQualityResponse.json();\nconst forecastData = await forecastResponse.json();\n</code></pre>\n<ul>\n<li><code>fetch</code> 요청으로부터 받은 응답은 JSON 으로 파싱한다. 이 과정도 비동기이기 때문에 await 키워드를 사용하여 처리한다.</li>\n</ul>\n<p><img src=\"https://velog.velcdn.com/images/gawgjiug/post/5b6a0abc-2333-4760-b031-706486ef990b/image.png\" alt=\"\"></p>\n",
    "pubDate": "Mon, 02 Sep 2024 12:18:46 GMT",
    "thumbnail": null
  },
  {
    "title": "useReducer",
    "link": "https://velog.io/@gawgjiug/useReducer",
    "description": "<ul>\n<li><p>useReducer()는 useState()와 같은 상태 관리, 상태 업데이트 훅이다.</p>\n</li>\n<li><p>변경할 값이 많을 때, 즉 상태 관리할 데이터가 많아질 때 주로 많이 사용한다.</p>\n</li>\n<li><p>좀 더 구조화된 방식으로 상태를 관리하고 싶을 때 사용할 수 있다.</p>\n</li>\n<li><p>const [state,dispatch] = useReducer(reducer,initialState);</p>\n</li>\n<li><p>state : 상태이름</p>\n</li>\n<li><p>dispatch : 상태를 변경할 때 필요한 정보를 전달하는 &#39;함수&#39;(주문서)</p>\n</li>\n<li><p>reducer : dispatch를 확인해서 state를 변경해주는 &#39;함수&#39;</p>\n</li>\n<li><p>initialState : state에 전달할 초기 값</p>\n</li>\n</ul>\n<h4 id=\"서론\">서론</h4>\n<ul>\n<li>리액트에서 상태 관리(업데이트)를 다루는 훅은 2가지 종류가 있다.</li>\n</ul>\n<p>1.useState()</p>\n<p>2.useReducer()</p>\n<ul>\n<li>useReducer는 클래스 컴포넌트에서 setState와 메서드와 유사한 역할을 하지만 좀 더 구조화된 방식으로 상태를 관리할 수 있도록 도와준다.</li>\n</ul>\n<h4 id=\"선언\">선언</h4>\n<pre><code class=\"language-javascript\">const [todos, dispatch] = useReducer(reducer, mockData);\n</code></pre>\n<ul>\n<li>todos state의 useReducer를 선언하였다. 초기 값으로 mockData를 넣어주었다.</li>\n</ul>\n<hr>\n<pre><code class=\"language-javascript\">function reducer(state, action) {\n  switch (action.type) {\n    case &#39;CREATE&#39;:\n      return [action.data, ...state];\n    case &#39;UPDATE&#39;:\n      return state.map((item) =&gt;\n        item.id === action.targetId ? { ...item, isDone: !item.isDone } : item\n      );\n    case &#39;DELETE&#39;:\n      return state.filter((item) =&gt; item.id !== action.targetId);\n    default:\n      return state;\n  }\n}</code></pre>\n<ul>\n<li><p>위는 내가 작성한 Todo App의 reducer 함수 정의 부분이다</p>\n</li>\n<li><p>reducer 함수는 두 개의 인수를 받는다. <code>state</code> (현재 상태) 와 <code>action</code> 액션 객체</p>\n</li>\n<li><p><code>action.type</code> 에 따라 다른 상태 변경 로직을 실행한다.</p>\n</li>\n<li><p>예를 들면 CREATE 는 새 할일을 상태(state)에 추가하는 부분인데. action.type 이 CREATE로 들어오게 되면, 새로운 할 일을 기존의 state 배열 앞에 추가하고 새로운 배열을 반환한다.</p>\n</li>\n</ul>\n<hr>\n<p>그리고 onCreate 함수는 이렇게 작성하였다.</p>\n<pre><code class=\"language-javascript\">const onCreate = (content) =&gt; {\n  dispatch({\n    type: &#39;CREATE&#39;,\n    data: {\n      id: idRef.current++,\n      isDone: false,\n      content: content,\n      date: new Date().getTime(),\n    },\n  });\n};</code></pre>\n<p>새 할 일을 나타내는 객체를 생성하고 <code>CREATE</code> 액션과 함께 dispatch를 호출한다. dispatch 함수에 이렇게 타입과 data를 객체 형태로 선언할 수 있다.</p>\n<ul>\n<li>이때 dispatch에 전달되는 객체는 액션 객체로, type 속성과 데이터(data)를 포함하고 있습니다.</li>\n</ul>\n<hr>\n<h4 id=\"usereducer를-사용하는-이유\">useReducer를 사용하는 이유</h4>\n<ol>\n<li><strong>useReducer를 사용한 코드 예시</strong></li>\n</ol>\n<pre><code class=\"language-javascript\">import { useReducer } from &#39;react&#39;;\n\nconst mockData = [\n  { id: 0, isDone: false, content: &#39;React 공부하기&#39;, date: new Date().getTime() },\n  { id: 1, isDone: false, content: &#39;빨래&#39;, date: new Date().getTime() },\n  { id: 2, isDone: false, content: &#39;운동&#39;, date: new Date().getTime() },\n];\n\nfunction reducer(state, action) {\n  switch (action.type) {\n    case &#39;CREATE&#39;:\n      return [action.data, ...state];\n    case &#39;UPDATE&#39;:\n      return state.map((item) =&gt;\n        item.id === action.targetId ? { ...item, isDone: !item.isDone } : item\n      );\n    case &#39;DELETE&#39;:\n      return state.filter((item) =&gt; item.id !== action.targetId);\n    default:\n      return state;\n  }\n}\n\nfunction App() {\n  const [todos, dispatch] = useReducer(reducer, mockData);\n\n  const onCreate = (content) =&gt; {\n    dispatch({\n      type: &#39;CREATE&#39;,\n      data: {\n        id: Date.now(),\n        isDone: false,\n        content: content,\n        date: new Date().getTime(),\n      },\n    });\n  };\n\n  const onUpdate = (targetId) =&gt; {\n    dispatch({ type: &#39;UPDATE&#39;, targetId });\n  };\n\n  const onDelete = (targetId) =&gt; {\n    dispatch({ type: &#39;DELETE&#39;, targetId });\n  };\n\n  return (\n    &lt;div&gt;\n      {/* UI Components here */}\n    &lt;/div&gt;\n  );\n}</code></pre>\n<ul>\n<li>위 코드에서 <code>useReducer</code>를 사용함으로써 상태 관리 로직이 <code>reducer</code> 함수 하나에 집약되어 있으며, 상태 업데이트가 모두 dispatch 함수를 통해 일관되게 이루어진다는 것을 알 수 있다.</li>\n</ul>\n<p><strong>2. useReducer를 사용하지 않고 useState만 사용한다면?</strong></p>\n<pre><code class=\"language-javascript\">import { useState, useRef } from &#39;react&#39;;\n\nconst mockData = [\n  { id: 0, isDone: false, content: &#39;React 공부하기&#39;, date: new Date().getTime() },\n  { id: 1, isDone: false, content: &#39;빨래&#39;, date: new Date().getTime() },\n  { id: 2, isDone: false, content: &#39;운동&#39;, date: new Date().getTime() },\n];\n\nfunction App() {\n  const [todos, setTodos] = useState(mockData);\n  const idRef = useRef(3);\n\n  const onCreate = (content) =&gt; {\n    const newTodo = {\n      id: idRef.current++,\n      isDone: false,\n      content: content,\n      date: new Date().getTime(),\n    };\n    setTodos([newTodo, ...todos]);\n  };\n\n  const onUpdate = (targetId) =&gt; {\n    setTodos(\n      todos.map((item) =&gt;\n        item.id === targetId ? { ...item, isDone: !item.isDone } : item\n      )\n    );\n  };\n\n  const onDelete = (targetId) =&gt; {\n    setTodos(todos.filter((item) =&gt; item.id !== targetId));\n  };\n\n  return (\n    &lt;div&gt;\n      {/* UI Components here */}\n    &lt;/div&gt;\n  );\n}</code></pre>\n<h4 id=\"usereducer와-usestate-비교\">useReducer와 useState 비교</h4>\n<ul>\n<li><p>코드 분리와 가독성 측면</p>\n</li>\n<li><p>useReducer : <code>redecer</code> 함수에 모든 상태 변경 로직이 정의되어 있다, 이로 인해 상태 관리 로직이 한 곳에 집중되어 있으며, 상태가 어떻게 변경되는지를 쉽게 파악할 수 있다. 또한 상태 업데이트가 모두 <code>dispatch</code> 를 통해 일관되게 이루어지므로 코드 가독성과 유지보수성이 높아진다.</p>\n</li>\n<li><p>useState: 상태 변경 로직이 onCreate, onUpdate, onDelete 함수 내부에 직접 구현되어 있다. 상태 변경 로직이 분산되어 있어, 시간이 지남에 따라 코드의 복잡성이 증가하고 유지보수가 어려워질 수 있다.</p>\n</li>\n<li><p>상태 업데이트 방식</p>\n</li>\n<li><p>useReducer: dispatch를 사용하여 상태 업데이트 요청을 보냅니다. 이 방식은 상태 변경을 명확하고 예측 가능하게 만들어 줍니다. 또한, action 객체를 사용하여 상태 변경에 필요한 추가적인 정보를 전달할 수 있습니다.</p>\n</li>\n<li><p>useState: 상태를 직접 변경하기 위해 setTodos를 호출합니다. 이 방식은 간단한 상태 변경에는 적합하지만, 복잡한 상태 변경 로직이 필요한 경우 코드가 지저분해질 수 있습니다.</p>\n</li>\n</ul>\n",
    "pubDate": "Mon, 02 Sep 2024 07:08:18 GMT",
    "thumbnail": null
  },
  {
    "title": "useEffect",
    "link": "https://velog.io/@gawgjiug/useEffect",
    "description": "<h2 id=\"useeffect\">useEffect</h2>\n<ul>\n<li><p>useEffect() 함수는 리액트 컴포넌트가 렌더링 될 때마다 특정 작업(Side Effect)을 실행할 수 있도록 하는 리액트 Hook 이다.</p>\n</li>\n<li><p>여기서 SideEffect 는 컴포넌트가 렌더링 된 이후에 비동기로 처리되어야 하는 부수적인 효과들을 뜻한다.</p>\n</li>\n<li><p>useEffect는 component가 mount 됐을 때, unmout 됐을 때, update 됐을 때, <strong>특정 작업을 처리할 수 있다</strong> </p>\n</li>\n</ul>\n<blockquote>\n<p>즉, 클래스형 컴포넌트에서 사용할 수 있었던 생명주기 매소드를 함수형 컴포넌트에서도 사용할 수 있게 된 것을 말한다.</p>\n</blockquote>\n<h4 id=\"useeffect-사용방법\">useEffect 사용방법</h4>\n<blockquote>\n<p>useEffect(function,deps)</p>\n</blockquote>\n<ul>\n<li><p>function : 수행하고자 하는 작업 (리액트가 기억 했다가 DOM 업데이트 후 불러내는 함수)</p>\n</li>\n<li><p>deps : 배열 형태이며 , 배열 안에는 검사하고자 하는 특정 값 or 빈배열\ndeps에 특정 값을 넣게 되면 컴포넌트가 mount 될 때와 지정한 값이 업데이트 될 때 useEffect를 실행한다.</p>\n</li>\n</ul>\n<ol>\n<li>componentDidMount</li>\n</ol>\n<ul>\n<li>Component가 mount 됐을 때 (처음 나타났을 때 실행)</li>\n</ul>\n<pre><code class=\"language-javascript\">useEffect(() = &gt;{\n\nconsole.log(&#39;mount&#39;);\n},[])</code></pre>\n<ul>\n<li>컴포넌트가 화면에 가장 처음 렌더링 될 때 한 번만 실행하고 싶다면 deps 위치에 빈 배열을 넣어준다.</li>\n</ul>\n<pre><code class=\"language-javascript\">useEffect(() = &gt;{\n\nconsole.log(&#39;렌더링 될 때 마다&#39;);\n})</code></pre>\n<ul>\n<li>만약 배열을 생략하면 리렌더링 될 때마다 실행된다.</li>\n</ul>\n<ol start=\"2\">\n<li>componentDidUpdate</li>\n</ol>\n<ul>\n<li>Component가 update 될 때 (특정 props, state가 바뀔 때 실행)</li>\n</ul>\n<pre><code class=\"language-javascript\">useEffect(() = &gt;{\n\nconsole.log(&#39;update&#39;);\n},[name])</code></pre>\n<ul>\n<li><p>특정 값이 업데이트 될 때 실행하고 싶다면, deps 위치의 배열 안에 검사하고 싶은 값을 넣어줍니다.</p>\n</li>\n<li><p>하지만 업데이트 될 때만 실행되는 것이 아니라 마운트 될 때도 실행된다. 만약 업데이트 될 때만 실행시키고 싶다면 아래와 같은 방법을 사용한다</p>\n</li>\n</ul>\n<pre><code class=\"language-javascript\">const mounted = useRef(false)\n\nuseEffect(() =&gt;{\nif(!mounted.current){\n\nmounted.current = true;\n}else{\nconsole.log(name);\n}\n\n},[name])</code></pre>\n<ul>\n<li><p>mounted는 useRef(false)로 초기화됩니다. 즉, mounted.current의 초기값은 false입니다.\nuseEffect 훅이 실행됩니다. 이 훅은 name이 변경될 때마다 실행되도록 되어있지만, 처음 렌더링될 때도 한 번 실행됩니다.</p>\n</li>\n<li><p>!mounted.current 조건이 참(true)이므로 if 블록이 실행됩니다. 따라서 mounted.current = true;가 실행되어 mounted.current의 값이 true로 변경됩니다.</p>\n</li>\n<li><p>이 시점에서 console.log(name);는 실행되지 않습니다.\nname이 변경될 때:</p>\n</li>\n<li><p>name이 변경될 때마다 useEffect가 다시 실행됩니다.</p>\n</li>\n<li><p>이제 mounted.current는 true이기 때문에 !mounted.current 조건이 거짓(false)이 됩니다.</p>\n</li>\n<li><p>따라서 else 블록이 실행되어 console.log(name);가 실행됩니다. 이 시점에서 name의 현재 값이 콘솔에 출력됩니다.\n이후 name이 또 변경될 때마다:</p>\n</li>\n<li><p>mounted.current는 이미 true로 설정되어 있기 때문에 계속해서 else 블록이 실행되며 console.log(name);가 실행됩니다.</p>\n</li>\n</ul>\n<p>** 3.componentDidUnMount**</p>\n<ul>\n<li>component가 unmount 될 때 (사라질 때) &amp; update 되기 직전에 실행</li>\n</ul>\n<pre><code class=\"language-javascript\">const mounted = useRef(false);\n\nuseEffect(() =&gt; {\n  if (!mounted.current) {\n    mounted.current = true;\n  } else {\n    console.log(name);\n  }\n\n  // 정리(cleanup) 함수\n  return () =&gt; {\n    console.log(&#39;컴포넌트가 언마운트되었습니다.&#39;);\n  };\n}, [name]);\n</code></pre>\n<ul>\n<li>cleanup 함수 반환 (return 뒤에 나오는 함수이며, useEffect에 대한 뒷정리 함수라고 한다.)</li>\n</ul>\n<ol>\n<li><p>언마운트 될 때만 cleanup 함수를 실행하고 싶다면, 두 번째 파라미터에 빈 배열을 넣고 return 문과 cleanup 함수를 선언해주면 된다.</p>\n</li>\n<li><p>특정 값이 업데이트 되기 직전에 cleanup 함수를 실행하고 싶다면 deps 배열 안에 검사하고 싶은 값을 넣어준다.</p>\n</li>\n</ol>\n<ul>\n<li><p>정리 함수(clean up) 는 메모리 누수를 방지하고,  이벤트 리스너나 타이머 등의 리소스를 해제하는 데 유영하다.</p>\n</li>\n<li><p>예를 들어 웹 소켓 연결을 닫거나, 구독을 취소하거나, 이벤트 리스너를 제거하는 등의 작업을 수행할 수 있다.</p>\n</li>\n</ul>\n",
    "pubDate": "Mon, 02 Sep 2024 05:13:00 GMT",
    "thumbnail": null
  },
  {
    "title": "useRef",
    "link": "https://velog.io/@gawgjiug/useRef",
    "description": "<h3 id=\"useref\">useRef</h3>\n<ul>\n<li><p>useRef는 .current 프로퍼티로 전달된 인자로 초기화된 변경가능한 ref 객체를 반환한다. 반환된 객체는 컴포넌트의 전 생애주기를 통해 유지될 것</p>\n</li>\n<li><p>useRef는 리액트 Hook의 한 종류로 Ref는 reference의 줄임말이다.</p>\n</li>\n<li><p>useRef를 이용하면 특정한 DOM 요소에 접근할 때 불필요한 리렌더링이 발생하지 않는다는 장점이 있다.</p>\n</li>\n<li><p>즉, useRef는 <code>useState</code>와 같이 값을 저장하는 변수로 사용되지만 state 처럼 값이 변경될 때 마다 리렌더링이 발생하지는 않는다는 것이다.</p>\n</li>\n<li><p>그렇다면 JS 변수와는 어떤 차이점이 있을까??</p>\n</li>\n<li><p>js 변수는 리렌더링이 발생하면 값이 계속 초기화되지만, useRef를 사용하면 리렌더링이 되더라도 값을 계속 저장하기 때문이다.</p>\n</li>\n<li><p>이제 2가지 경우를 예제 코드로 살펴보자.</p>\n</li>\n</ul>\n<h4 id=\"예제-1-useref-를-사용하여-dom-요소에-접근하기\">예제 1 &#39;useRef&#39; 를 사용하여 DOM 요소에 접근하기</h4>\n<ul>\n<li>이 예제에서는 <code>useRef</code> 를 사용하여 특정 DOM 요소를 참조하고 버튼 클릭 시 해당 요소에 포커스를 설정하도록 하였다.</li>\n</ul>\n<pre><code class=\"language-javascript\">import React, { useRef } from &#39;react&#39;;\n\nfunction InputFocus() {\n  // useRef로 초기화된 inputRef를 생성\n  const inputRef = useRef(null);\n\n  const handleFocus = () =&gt; {\n    // current 프로퍼티를 통해 input 요소에 접근\n    inputRef.current.focus();\n  };\n\n  return (\n    &lt;div&gt;\n      &lt;input ref={inputRef} type=&quot;text&quot; placeholder=&quot;클릭하면 포커스가 이동합니다.&quot; /&gt;\n      &lt;button onClick={handleFocus}&gt;입력란에 포커스&lt;/button&gt;\n    &lt;/div&gt;\n  );\n}\n\nexport default InputFocus;</code></pre>\n<ul>\n<li>버튼을 클릭하면 <code>handleFocus</code> 함수가 실행되면서, <code>useRef</code> 에 focus가 가능하다.</li>\n</ul>\n<h4 id=\"예제-2-useref-를-사용하여-리렌더링-없이-값-유지하기\">예제 2: useRef 를 사용하여 리렌더링 없이 값 유지하기</h4>\n<ul>\n<li>이 예제에서는 <code>useRef</code>를 사용하여 버튼 클릭 횟수를 카운트하지만, <code>useState</code> 와 달리 리렌더링 없이 값을 유지한다.</li>\n</ul>\n<pre><code class=\"language-javascript\">import React, { useRef, useState } from &#39;react&#39;;\n\nfunction ClickCounter() {\n  // useRef로 초기화된 countRef를 생성\n  const countRef = useRef(0);\n  const [renderCount, setRenderCount] = useState(0);\n\n  const handleClick = () =&gt; {\n    // countRef의 current 값을 증가시킴\n    countRef.current++;\n    console.log(`버튼 클릭 횟수: ${countRef.current}`);\n  };\n\n  const handleRender = () =&gt; {\n    // 컴포넌트를 리렌더링\n    setRenderCount(renderCount + 1);\n  };\n\n  return (\n    &lt;div&gt;\n      &lt;button onClick={handleClick}&gt;클릭 횟수 증가&lt;/button&gt;\n      &lt;button onClick={handleRender}&gt;리렌더링&lt;/button&gt;\n      &lt;p&gt;리렌더링 횟수: {renderCount}&lt;/p&gt;\n      &lt;p&gt;콘솔에서 클릭 횟수를 확인하세요.&lt;/p&gt;\n    &lt;/div&gt;\n  );\n}\n\nexport default ClickCounter;</code></pre>\n<ul>\n<li><p>위 예제에서는 countRef 라는 <code>useRef</code>훅을 사용하여 버튼 클릭 횟수를 저장한다. \n<code>handleClick</code> 함수가 호출될 때마다 <code>countRef,current</code> 값이 증가하지만, 이 값의 변경은 컴포넌트를 리렌더링 하지 않고,</p>\n</li>\n<li><p>리렌더링이 발생하는 경우에도 값이 계속해서 유지되는 것을 볼 수 있다.</p>\n</li>\n</ul>\n<hr>\n<h4 id=\"장점\">장점</h4>\n<ul>\n<li>자주 변경되는 값을 state에 담으면 리렌더링도 자주 일어나기 때문에 성능에 부정적인 영향을 미칠 수 있지만, useRef를 이용하면 값이 변경될 때마다 렌더링이 일어나지 않는다.</li>\n</ul>\n",
    "pubDate": "Thu, 29 Aug 2024 05:29:34 GMT",
    "thumbnail": null
  },
  {
    "title": "[React] 데이터 흐름 & State 끌어올리기",
    "link": "https://velog.io/@gawgjiug/React-%EB%8D%B0%EC%9D%B4%ED%84%B0-%ED%9D%90%EB%A6%84-State-%EB%81%8C%EC%96%B4%EC%98%AC%EB%A6%AC%EA%B8%B0",
    "description": "<p><img src=\"https://velog.velcdn.com/images/gawgjiug/post/53d42732-237a-4896-b057-703a4f5a220e/image.gif\" alt=\"\"></p>\n<p><a href=\"https://www.youtube.com/shorts/u86KSUc9Ngg?feature=share\">출처</a></p>\n<ul>\n<li><p>리액트는 기본적으로 단방향 데이터 흐름을 가지고 있다. 부모 -&gt; 자식 </p>\n</li>\n<li><p>하지만 부모 컴포넌트에서의 상태가 하위 컴포넌트에 의해 변하는 경우가 종종 있다.</p>\n</li>\n<li><p>예를 들면, 하위 컴포넌트에서의 클릭 이벤트가 부모의 상태를 바꾸어야만 하는 상황이 왔다면, </p>\n</li>\n<li><p>이를 해결할 수 있는 개념이 바로 State 끌어올리기 이다.</p>\n</li>\n<li><p>컴포넌트는 props 형태로 속성을 내려 받아 인자로 사용할 수 있는데, State 끌어올리기는 이 props로 상태를 변경시키는 함수를 전달하여 문제를 해결하는 방법을 말한다.</p>\n</li>\n</ul>\n<blockquote>\n</blockquote>\n<p>상위 컴포넌트의 &quot;상태를 변경하는 함수&quot; 그 자체를 하위 컴포넌트로 전달하고 이 함수를 하위 컴포넌트가 실행한다.</p>\n<p>라는 개념이다.</p>\n<ul>\n<li>여전히 단방향 데이터 흐름의 원칙에 부합하는 해결방식라고 할 수 있다.</li>\n</ul>\n<pre><code class=\"language-javascript\">import React, { useState } from &#39;react&#39;;\n\n// Parent Component\nfunction Parent() {\n  // 부모 컴포넌트의 상태\n  const [count, setCount] = useState(0);\n\n  // 상태를 업데이트하는 함수\n  const handleUpdateCount = () =&gt; {\n    setCount(count + 1);\n  };\n\n  return (\n    &lt;div&gt;\n      &lt;h1&gt;Parent Component&lt;/h1&gt;\n      &lt;p&gt;Count: {count}&lt;/p&gt;\n      {/* Child 컴포넌트에 상태 업데이트 함수를 props로 전달 */}\n      &lt;Child onButtonClick={handleUpdateCount} /&gt;\n    &lt;/div&gt;\n  );\n}\n\n// Child Component\nfunction Child({ onButtonClick }) {\n  return (\n    &lt;div&gt;\n      &lt;h2&gt;Child Component&lt;/h2&gt;\n      {/* 버튼 클릭 시 부모로부터 받은 함수를 호출 */}\n      &lt;button onClick={onButtonClick}&gt;Increase Count&lt;/button&gt;\n    &lt;/div&gt;\n  );\n}\n\nexport default Parent;</code></pre>\n<hr>\n<h3 id=\"정리❗\">정리❗</h3>\n<blockquote>\n</blockquote>\n<p>React는 기본적으로 단방향 데이터 흐름이라는 원칙을 가진다.</p>\n<ul>\n<li>상위 컴포넌트에서 하위로는 이동할 수 있지만 반대로는 불가하다. \n그러나 종종 동일한 데이터에 대한 변경사항을 여러 컴포넌트에 반영할 필요가 생긴다.</li>\n</ul>\n<blockquote>\n<ul>\n<li>이 때, state 끌어올리기 개념으로 데이터 변경사항을 상위 컴포넌트로 전달할 수 있다.</li>\n</ul>\n</blockquote>\n<blockquote>\n<ul>\n<li>데이터를 직접 상위로 전달하는 것과는 다르게, state를 직접 전달하는 것이 아닌 \n   state 갱신 함수를 전달 받아 해당 함수를 실행시키는 원리이다.</li>\n</ul>\n</blockquote>\n",
    "pubDate": "Wed, 28 Aug 2024 07:20:03 GMT",
    "thumbnail": null
  },
  {
    "title": "What is State? ",
    "link": "https://velog.io/@gawgjiug/What-is-State",
    "description": "<h3 id=\"state-in-react\">state in React</h3>\n<ul>\n<li><p>What is State ??</p>\n</li>\n<li><p>컴포넌트는 사용자와의 상호작용 결과로서 화면을 리렌더링 할 때가 자주 있다. 예를 들면 사용자가 Form에 정보를 입력했다던가, 버튼을 클릭해서 이미지를 보여주게 한다던가 하는 동작 말이다.</p>\n</li>\n<li><p>이렇게 컴포넌트는 로직의 처리를 위해 <strong>특정한 값들을 저장해야 할 필요</strong> 가 있으며, React 에서는 이를 <code>state</code> 라고 정의하였다.</p>\n</li>\n<li><p><code>state</code> 값이 변경되었을 경우 React 는 해당 컴포넌트를 리렌더링 한다. 따라서 <code>state</code> 의 변화는 컴포넌트의 리렌더링을 유발시키는 요인이라고 볼 수 있다.</p>\n</li>\n</ul>\n<h3 id=\"로컬-변수와-state의-차이점\">로컬 변수와 state의 차이점</h3>\n<pre><code class=\"language-jsx\">function Counter() {\n    let count = 0;\n\n    function increaseCount() {\n        count += 1;\n        console.log(count);\n    }\n\n    function decreaseCount() {\n        count -= 1;\n        console.log(count);\n    }\n\n    return (\n        &lt;div&gt;\n            &lt;button onClick={increaseCount}&gt;+1&lt;/button&gt;\n            &lt;button onClick={decreaseCount}&gt;-1&lt;/button&gt;\n            &lt;p&gt;Count : {count}&lt;/p&gt;\n        &lt;/div&gt;\n    );\n}\n\nexport default Counter;</code></pre>\n<ul>\n<li><p>해당 코드를 언뜻 보면 평범하게 버튼을 클릭하여 count 값의 증감을 화면에 렌더링하는 코드로 볼 수 있다.</p>\n</li>\n<li><p>하지만 위 코드는 count 값이 화면에 업데이트 되지 않는다.</p>\n</li>\n<li><p>여기서 count 는 Js 일반 지역변수로 선언되었다, React의 상태 관리 메커니즘인 <code>useState</code> 를 사용하지 않았기 때문에, React는 이 변수를 추적하거나 변경 사항을 감지하지 않는다.</p>\n</li>\n<li><p>리렌더링은 React 컴포넌트의 상태(<code>state</code>) 나 속성(<code>props</code>)이 변경될 때 발생한다.</p>\n</li>\n<li><p>현재 코드에서는 <code>count</code>가 일반 지역 변수로 설정되어 있어, 이 값이 변경되어도 컴포넌트가 다시 렌더링 되지 않는다.</p>\n</li>\n</ul>\n<h4 id=\"그래서-왜-count-값이-화면에-업데이트-되지-않는-것인지\">그래서 왜 count 값이 화면에 업데이트 되지 않는 것인지?</h4>\n<ul>\n<li><p>버튼을 클릭하면 increaseCount 나 decreaseCount 함수가 실행되어 <code>count</code> 값을 증기시키거나 감소시킨다.</p>\n</li>\n<li><p>하지만 이러한 변화는 단지 메모리 내에서의 값 변경일 뿐 React 가 이를 인지하지는 못한다. 그리고 상태나 속성이 변경된 것이 아니기 때문에 리렌더링이 발생하지도 않는다.</p>\n</li>\n<li><p>그렇기에 console 에는 count의 변경 값이 잘 나오겠지만, 화면에는 초기 렌더링 상태인 0 을 그대로 유지하는 것이다.</p>\n</li>\n<li><p>이를 해결하기 위해서 useState를 사용하여 count 값을 상태로 선언하고, 상태 변경 함수인 setCount를 사용하여 count 값을 업데이트 해야한다.</p>\n</li>\n</ul>\n<pre><code class=\"language-javascript\">import { useState } from &#39;react&#39;;\n\nfunction Counter() {\n  const [count, setCount] = useState(0); // count를 상태로 선언\n\n  function increaseCount() {\n    setCount(count + 1); // 상태 업데이트\n  }\n\n  function decreaseCount() {\n    setCount(count - 1); // 상태 업데이트\n  }\n\n  return (\n    &lt;div&gt;\n      &lt;button onClick={increaseCount}&gt;+1&lt;/button&gt;\n      &lt;button onClick={decreaseCount}&gt;-1&lt;/button&gt;\n      &lt;p&gt;Count: {count}&lt;/p&gt; {/* 최신 상태 값이 화면에 업데이트됨 */}\n    &lt;/div&gt;\n  );\n}\n\nexport default Counter;</code></pre>\n<ul>\n<li>이렇게 하면 increaseCount나 decreaseCount 함수가 setCount를 호출할 때마다 React가 count 상태의 변경을 감지하고 컴포넌트를 다시 렌더링하여 화면에 최신 상태 값을 반영한다.</li>\n</ul>\n<hr>\n<h3 id=\"state-is-private--isolated\">State is private, &amp;&amp; isolated</h3>\n<ul>\n<li>state 는 자신이 속한 컴포넌트의 종속적이다. 그 말은 즉슨, 만약 같은 컴포넌트를 두 차례 랜더링 하더라도, 각 컴포넌트에 속한 state는 서로 독립적으로 작동한다.</li>\n</ul>\n<h3 id=\"batching\">Batching</h3>\n<ul>\n<li><p>batching 은 React 에서 성능 최적화를 위해 여러 개의 상태 업데이트를 하나의 렌더링 사이클로 묶어서 처리하는 방식을 말한다.</p>\n</li>\n<li><p>이 방식으로 불필요한 리렌더링을 방지하고 성능을 최적화할 수 있다. 예를 들자면, 여러 개의 <code>setState</code> 호출이 있을 때, 각각의 setState 가 호출될 때 마다 컴포넌트가 리렌더링 되는 것이 아니라, 모든 setState 호출을 하나의 이벤트 루프에서 처리하고 한 번만 리렌더링 하는 것이다.</p>\n</li>\n</ul>\n<pre><code class=\"language-javascript\">import React, { useState } from &#39;react&#39;;\n\nfunction BatchExample() {\n  const [count1, setCount1] = useState(0);\n  const [count2, setCount2] = useState(0);\n\n  const handleClick = () =&gt; {\n    // 두 상태 변수를 각각 업데이트합니다.\n    setCount1(count1 + 1);\n    setCount2(count2 + 1);\n\n    // 일반적으로는 두 개의 상태 업데이트가 각자 컴포넌트를 리렌더링할 수 있지만,\n    // React의 Batching 덕분에 한 번의 리렌더링만 발생합니다.\n    console.log(&#39;count1:&#39;, count1, &#39;count2:&#39;, count2);\n  };\n\n  return (\n    &lt;div&gt;\n      &lt;p&gt;Count 1: {count1}&lt;/p&gt;\n      &lt;p&gt;Count 2: {count2}&lt;/p&gt;\n      &lt;button onClick={handleClick}&gt;Increase Counts&lt;/button&gt;\n    &lt;/div&gt;\n  );\n}\n\nexport default BatchExample;</code></pre>\n<hr>\n<h3 id=\"리액트의-setstate-비동기처리\">리액트의 <code>setState</code> 비동기처리</h3>\n<ul>\n<li><code>setState</code> 함수가 호출될 때 즉시 상태가 변경되는 것이 아니라, 상태 업데이트 요청이 예약되고 리액트가 최적의 타이밍에 이 요청을 처리한다. 이러한 방식은 컴포넌트가 불필요하게 여러 번 리렌더링 되는 것을 방지한다.</li>\n</ul>\n<pre><code class=\"language-javascript\">import React, { useState } from &#39;react&#39;;\n\nfunction Counter() {\n  const [count, setCount] = useState(0);\n\n  const handleClick = () =&gt; {\n    setCount(count + 1); // 상태 업데이트 요청\n    console.log(&#39;Inside handleClick:&#39;, count); // 기존의 count 값을 출력\n  };\n\n  return (\n    &lt;div&gt;\n      &lt;p&gt;Count: {count}&lt;/p&gt;\n      &lt;button onClick={handleClick}&gt;Increase Count&lt;/button&gt;\n    &lt;/div&gt;\n  );\n}\n\nexport default Counter;</code></pre>\n<ol>\n<li><p>handleClick 함수를 호출한다</p>\n</li>\n<li><p>setCount(count + 1) 호출 여기서 함수가 count 값을 1 증가시키도록 요청, 하지만 이 시점에서 상태가 즉시 변경되지는 않음</p>\n</li>\n<li><p>console.log 실행: console.log는 이전의 count 값을 출력한다. 상태 업데이트가 비동기로 처리되기 때문에 count 는 아직 변경되지 않았기 때문.</p>\n</li>\n<li><p>리렌더링 리액트가 다음 리렌더링 주기에서 상태 업데이트를 적용하고 컴포넌트를 다시 렌더링 한다. </p>\n</li>\n</ol>\n<h3 id=\"비동기의-이유\">비동기의 이유</h3>\n<ul>\n<li><p>성능 최적화 : 여러 개의 상태 업데이트 요청을 한 번에 처리하여 리렌더링 횟수를 줄인다. 예를 들어, 연속적으로 여러 번 setState가 호출되면, 리액트는 이를 모아서 한 번만 리렌더링한다.</p>\n</li>\n<li><p>일관된 UI 상태 유지 : 비동기 업데이트를 통해 컴포넌트가 중간 상태를 보지 않고, 항상 이관된 상태를 유지한다. 만약 상태 업데이트가 동기적으로 처리된다면, 각 상태 변경 후에 컴포넌트가 즉시 리렌더링 되어 UI가 깜빡이거나 불안정해질 수 있음.</p>\n</li>\n<li><p>Batching(일괄 처리): React는 이벤트 핸들러 내에서 여러 setState 호출이 발생하더라도 이를 일괄 처리하여 한 번의 리렌더링만 발생시키도록 최적화한다.</p>\n</li>\n</ul>\n",
    "pubDate": "Wed, 28 Aug 2024 07:09:03 GMT",
    "thumbnail": null
  }
]