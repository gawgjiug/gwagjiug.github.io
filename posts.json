[
  {
    "title": "그리디 알고리즘 with 백준",
    "link": "https://velog.io/@gawgjiug/%EA%B7%B8%EB%A6%AC%EB%94%94-%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98-with-%EB%B0%B1%EC%A4%80",
    "description": "<h3 id=\"그리디-알고리즘greedy-alhorithm\">그리디 알고리즘(Greedy Alhorithm)</h3>\n<ul>\n<li><p>그리디 알고리즘이란?</p>\n</li>\n<li><p>최적의 값을 구해야 하는 상황에서 사용되는 근시안적인 방법론으로 &#39;각 단계에서 최적이라고 생각되는 것을 선택&#39; 해 나가는 방식으로 진행하여 최종적인 해답에 도달하는 알고리즘이다</p>\n</li>\n<li><p>이때, 항상 최적의 값을 보장하는 것이 아니라 사실은 최적의 값의 &#39;근사한 값&#39; 을 목표로 하고 있는 것</p>\n</li>\n<li><p>순간마다 하는 선택은 그 순간 기점으로 지역적으로 최적의 선택이지만, 그 선택들을 계속 수집하한 결과인 최종적(전역적)인 해답은 최적이라는 보장이 없음</p>\n</li>\n</ul>\n<h4 id=\"그리디-알고리즘-문제를-해결하는-방법\">그리디 알고리즘 문제를 해결하는 방법</h4>\n<p><strong>1. 선택 절차 : 현재 상태에서의 최적의 해답을 선택한다.</strong>\n<strong>2. 적절성 검사 : 선택된 해가 문제의 조건을 만족하는지 검사한다.</strong>\n<strong>3. 해답 검사 : 원래의 문제가 해결되었는지 검사하고, 해결되지 않았다면 선택 절차로 돌아가 위 과정 반복</strong></p>\n<h4 id=\"❗️탐욕-알고리즘을-일상-예시-1--매트로이드\">❗️탐욕 알고리즘을 일상 예시 1 – 매트로이드</h4>\n<ul>\n<li>물견 가격은 4040원 이고, 손님이 5,000원을 주며 거스름돈의 동전의 개수를 최소한으로 하여 거슬러 달라고 한다.</li>\n</ul>\n<h4 id=\"탐욕-알고리즘의-문제-해결-과정을-적용\">탐욕 알고리즘의 문제 해결 과정을 적용</h4>\n<ol>\n<li><p>선택 절차\n거스름돈의 동전 개수를 줄이기 위해 현재 가장 가치가 높은 동전을 우선 선택한다.</p>\n</li>\n<li><p>적절성 검사\n1번 과정을 통해 선택된 동전들의 합이 거슬러 줄 금액을 초과하는지 검사한다.\n초과하면 가장 마지막에 선택한 동전을 삭제하고, 1번으로 돌아가 한 단계 작은 동전을 선택한다.</p>\n</li>\n<li><p>해답 검사\n선택된 동전들의 합이 거슬러 줄 금액과 일치하는지 검사한다.\n액수가 부족하면 1번 과정부터 다시 반복한다.</p>\n</li>\n</ol>\n<h4 id=\"탐욕-알고리즘-문제-풀이-with-백준\">탐욕 알고리즘 문제 풀이 with 백준</h4>\n<p><a href=\"https://www.acmicpc.net/problem/1931\">백준 1931번: 회의실 배정</a></p>\n<p><img src=\"https://velog.velcdn.com/images/gawgjiug/post/26a38497-2a12-4a6a-a7fe-e475552e97b5/image.png\" alt=\"\"></p>\n<pre><code class=\"language-java\">\nimport java.util.Arrays;\nimport java.util.Comparator;\nimport java.util.Scanner;\n\npublic class Main {\n    public static void main(String[] args) {\n\n\n        //백줕 1931번\n\n        Scanner sc = new Scanner(System.in);\n\n        int N = sc.nextInt();\n\n        /*time[][0] 은 시작 지점을 의미\n        * time[][1] 은 종료 시점을 의미*/\n\n        int [][] time = new int[N][2];\n\n        for(int i = 0 ; i&lt;N; i++){\n            time[i][0] = sc.nextInt(); //시작\n            time[i][1] = sc.nextInt(); //종료\n        }\n\n        Arrays.sort(time, new Comparator&lt;int[]&gt;() {\n            @Override\n            public int compare(int[] o1, int[] o2) {\n                if(o1[1] == o2[1]){\n                    return o1[0] - o2[0]; //종료 시간이 같을 경우 시작 시간이 빠른 순으로 정렬\n                }\n                return o1[1] - o2[1];\n            }\n        });\n\n        int count =0;\n        int prev_end_time = 0;\n\n        for(int i = 0; i&lt;N; i++){\n            if (prev_end_time &lt;= time[i][0]){ //직전 종료시간이 다음 회의 시작 시간보다 작거나 같으면 갱신\n                prev_end_time = time[i][1];\n                count++;\n            }\n        }\n\n        System.out.println(count);\n\n\n    }\n}</code></pre>\n<ul>\n<li><p>회의의 시작시간과 종료시간 각각을 2차원 배열로 저장한다</p>\n</li>\n<li><p>Array.sort를 사용하여 회의 배열을 정렬, 정렬 기준은 종료시간 만약 종료 시간이 같은 회의가 있을 경우, 시작 시간이 빠른 순서로 정렬</p>\n</li>\n<li><p>직전 종료시간(5)이 다음 회의시작 시간(6or5) 보다 작거나 같으면 갱신한다.</p>\n</li>\n</ul>\n",
    "pubDate": "Mon, 05 Aug 2024 07:20:03 GMT",
    "thumbnail": null
  },
  {
    "title": "배열 Vs 연결리스트",
    "link": "https://velog.io/@gawgjiug/%EB%B0%B0%EC%97%B4-Vs-%EC%97%B0%EA%B2%B0%EB%A6%AC%EC%8A%A4%ED%8A%B8",
    "description": "<h3 id=\"array-vs-linkedlist\">Array VS LinkedList</h3>\n<hr>\n<p>Array 와 LinkedList의 비교이다.</p>\n<h4 id=\"array배열\">Array(배열)</h4>\n<p><img src=\"https://github.com/user-attachments/assets/2f9b35a2-f258-4bcd-8c22-2e3c47ba26dc\" alt=\"image\"></p>\n<ul>\n<li><p><code>구조</code> : 배열은 메모리 상에서 <code>연속적</code>으로 저장된다. 각 원소는 고정된 <code>크기</code>를 가지며, 논리적 저장 순서와 물리적 저장 순서가 일치한다.</p>\n</li>\n<li><p><code>메모리 할당</code> : 배열의 크기는 고정되고, 선언 시 컴파일 타임에 메모리 공간이 할당된다. 이로 인해 메모리의 동적 크기 조정이 불가능하다는 특징을 갖는다.</p>\n</li>\n<li><p><code>장점</code> : 메모리 접근이 간단하고 빠르다. 연속된 메모리 블록을 사용하므로 <a href=\"https://github.com/gawgjiug/Eureka_CS_Study/blob/main/OS/os_cache.md\">캐시</a> 효율성이 높다.</p>\n</li>\n<li><p><code>단점</code> : 크기를 미리 정해야 하며, 크기 조정이 불가능 하여 필요한 만큼의 공간을 정확히 예측해야 하고, 삽입 및 삭제 작업이 비효율적일 수 있다.</p>\n</li>\n</ul>\n<h4 id=\"linkedlist-연결리스트\">LinkedList (연결리스트)</h4>\n<p><img src=\"https://github.com/user-attachments/assets/9522a89a-7f0d-425c-9b77-3aa068b96f55\" alt=\"image\"></p>\n<ul>\n<li><p><code>구조</code> : 연결 리스트는 메모리 상에서 비연속적으로 저장된다. 각 노드는 데이터와 다음 노드에 대한 포인터를 포함하기 때문에, 논리적 저장 순서와 물리적 저장 순서가 다르다.</p>\n</li>\n<li><p><code>메모리 할당</code> : 각 노드는 데이터가 삽입 될 때 마다 동적으로 메모리 공간을 할당 받는다. 이로 인해 배열과 달리 크기 조정이 유연하다는 장점이 있다.</p>\n</li>\n<li><p><code>장점</code> : 삽입 및 삭제가 효율적이고, 메모리 공간을 동적으로 관리할 수 있다.</p>\n</li>\n<li><p><code>단점</code> : 메모리 접근이 비효율적일 수 있다. 배열 처럼 연속적인 메모리 주소를 할당 받지 않았기 때문에 <code>index</code> 를 이용하여 임의로 접근하는 것이 불가능하다.\n 말을 즉슨 <strong>데이터를 탐색할 때 순차적으로 접근해야 한다는 것이다</strong></p>\n</li>\n</ul>\n<h3 id=\"데이터-접근-속도\">데이터 접근 속도</h3>\n<h4 id=\"array-\">Array :</h4>\n<ul>\n<li><p><code>시간복잡도</code> : 배열은 접근과 탐색이 용이하다고 했는데, <code>index</code>를 가지고 있기 때문에 탐색은 $O(1)$ 의 시간복잡도를 가진다. <strong>삽입의 경우는 맨 뒤에 삽입 할 경우는 $O(1)$ 이고,\n나머지 상황에서는 $O(n)$ 이다.</strong></p>\n</li>\n<li><p><code>특징</code> : 랜덤 액세스가 가능하여 임의의 위치에 존재하는 원소를 즉시 조회할 수 있다.</p>\n</li>\n</ul>\n<h4 id=\"linkedlist-\">LinkedList :</h4>\n<ul>\n<li><p><code>시간복잡도</code> : $O(n)$. 특정 노드를 찾기 위해 처음부터 순차적으로 탐색해야 하므로 접근속도가 느린편이다.</p>\n</li>\n<li><p><code>특징</code> : 인덱스가 없기 때문에 원소 접근 시 전체 리스트를 순회해야한다.</p>\n</li>\n</ul>\n<hr>\n<h3 id=\"메모리-효율성\">메모리 효율성</h3>\n<ul>\n<li><p>Array :</p>\n</li>\n<li><p><code>메모리 사용</code> : 연속된 메모리 블록을 사용하기 때문에 메모리 오버헤드가 적다. 하지만 크기를 변경할 수 없기 때문에 메모리 낭비가 발생할 수 있음</p>\n</li>\n<li><p><code>장점</code> : 장점은 역시 <code>캐시 효율성</code>이다 . 데이터의 빠른 접근이 가능하다.</p>\n</li>\n</ul>\n<ul>\n<li><p>LinkedList :</p>\n</li>\n<li><p><code>메모리 사용</code> : 각 노드는 데이터와 추가적인 포인터를 저장해야 하므로 메모리 오버헤드가 큰편이다. 각 노드의 포인터가 추가로 필요</p>\n</li>\n<li><p><code>장점</code> : 동적으로 크기를 조정할 수 있어 메모리 효율적 사용이 가능하다. 마찬가지로 삽입과 삭제 시 메모리 재배치가 필요하지 않다.</p>\n</li>\n</ul>\n<hr>\n<h3 id=\"활용사례\">활용사례</h3>\n<ul>\n<li><p><code>데이터 접근 패턴</code> : 데이터에 빠르게 접근해야 하는 경우에는 배열이 적합하다. Ex_ 웹 페이지 랜더링</p>\n</li>\n<li><p><strong>웹 브라우저는 DOM을 관리할 때 배열을 사용한다. HTML 요소들을 배열로 저장하여 빠르게 검색하고 수정하여 빠른 페이지 렌더링이 이루어진다.</strong></p>\n</li>\n<li><p><code>삽입과 삭제 빈도</code> : 빈번한 삽입과 삭제가 필요한 경우에는 연결리스트가 더 적합하다.</p>\n</li>\n<li><p><code>메모리 사용</code> : 메모리 사용의 효율성을 고려하여 배열 또는 연결리스트를 선택한다. 배열은 메모리 오버헤드가 적지만 크기 조정이 불가능하므로 연결 리스트를 더 선호함</p>\n</li>\n<li><p><code>알고리즘의 복잡도</code> : 빠른 랜덤 액세스가 필요하다면, 배열을 동적 크기 조정과 빠른 삽입/삭제가 필요한 서비스라면 연결리스트를 사용</p>\n</li>\n</ul>\n",
    "pubDate": "Wed, 31 Jul 2024 05:34:35 GMT",
    "thumbnail": null
  },
  {
    "title": "웹 소켓이란?",
    "link": "https://velog.io/@gawgjiug/%EC%9B%B9-%EC%86%8C%EC%BC%93%EC%9D%B4%EB%9E%80",
    "description": "<h3 id=\"웹-소켓이란\">웹 소켓이란?</h3>\n<p> <img src=\"https://github.com/user-attachments/assets/45f6c660-1c64-41cc-866c-f75a2ca2c222\" alt=\"웹소켓\"></p>\n<ul>\n<li><p>웹 소켓은 <code>실시간 통신</code>이 필요할 때 적극적으로 사용되는 기술이다.</p>\n</li>\n<li><p>초기의 인터넷 통신 방식은 주로 HTTP를 이용한 <strong>클라이언트(요청) -&gt; 서버(응답) 모델</strong> 을 통해 진행되었다. 즉 클라이언트가 서버에 요청(Request)을 보내고,\n서버가 이에 응답(Response) 하는 <code>반이중 통신 방식</code>을 따른다.</p>\n</li>\n<li><p>이러한 방식은 페이지를 요청하는 등의 간단한 작업에는 효과적이지만, 실시간으로 데이터를 주고 받는 서비스를 제공하기에는 한계점이 분명히 있다.</p>\n</li>\n<li><p>클라이언트가 서버에게 요청하지 않는 이상 서버는 클라이언트에게 먼저 데이터를 보낼 수 없기에 <code>실시간 통신</code>과 비슷한 상황을 HTTP 통신으로 이루기 위해선</p>\n</li>\n<li><p>클라이언트는 항상 새로운 데이터가 있는지 확인을 하기 위해 서버에 지속적으로 요청을 보낼 수 밖에 없다.</p>\n</li>\n<li><p>이렇게 되면 트래픽을 필요이상으로 증가 시키고, 이로 인해 서버의 비용이 증가될 뿐더러 요청과 응답 사이의 지연시간이 있기 때문에 <code>실시간 통신</code>의 효율성을 저하시킬 수 있다.</p>\n</li>\n</ul>\n<hr>\n<h3 id=\"웹-소켓-이전의-통신-방식\">웹 소켓 이전의 통신 방식</h3>\n<ul>\n<li>웹 소켓이 등장하기 전 주로 사용되던 HTTP 프로토콜을 기반으로 한 실시간 통신 방식은 어떤 것들이 있을까??</li>\n</ul>\n<h4 id=\"폴링polling\">폴링(Polling)</h4>\n<ul>\n<li><p><img src=\"https://github.com/user-attachments/assets/a8128a61-06ec-4381-bf20-0d3705aeab8b\" alt=\"폴링\"></p>\n</li>\n<li><p>폴링은 클라이언트가 주기적으로 서버에 요청을 보내는 방식을 말한다. 기본적으로 <code>일정시간</code>을 정해 놓고 새로운 데이터가 있는지 주기적으로 서버에 요청을 보내서 확인하게 된다.</p>\n</li>\n<li><p>이때, 새로운 데이터가 없더라도 서버는 응답을 보내게 된다.</p>\n</li>\n</ul>\n<pre><code class=\"language-javascript\">// 클라이언트\nsetInterval(function(){\n    fetch(&#39;/server&#39;).then(function(response){\n        console.log(response);\n    });\n}, 5000); // 5초마다 서버에 요청\n\n// 서버 (Node.js)\napp.get(&#39;/server&#39;, function(req, res){\n    res.send(&#39;새로운 데이터&#39;);\n});</code></pre>\n<ul>\n<li><p>간단한 메커니즘으로 구현이 매우 쉽다는 장점이 있지만, <code>불필요한 요청</code> 의 수가 증가할 수 있고 이는 서버 비용의 증가로 이어진다.</p>\n</li>\n<li><p>그리고 요청과 응답사이의 <code>지연 시간</code>이 발생하기 때문에 실시간통신이 제한될 수 밖에 없다.</p>\n</li>\n</ul>\n<h4 id=\"롱-폴링long-polling\">롱 폴링(Long Polling)</h4>\n<ul>\n<li><p><img src=\"https://github.com/user-attachments/assets/5c7182e9-aa3a-429a-a121-d550bfdab886\" alt=\"롱폴링\"></p>\n</li>\n<li><p>롱 폴링은 <code>폴링</code>을 조금 개선한 방식을 말하는데,</p>\n</li>\n<li><p>먼저 클라이언트가 서버에게 요청을 보내면, 서버는 새로운 데이터가 있는지 확인하게 되고, 일정 시간 동안 새로운 데이터가 없다면 <code>Time Out</code>을 발생시키고 응답을 보낸다.</p>\n</li>\n<li><p>반면에 새로운 데이터가 있다면 즉시 새로운 데이터에 대한 응답(Response)을 보낸다.</p>\n</li>\n</ul>\n<pre><code class=\"language-javascript\">// 클라이언트\nfunction longPoll(){\n    fetch(&#39;/server&#39;).then(function(response){\n        console.log(response);\n        longPoll();\n    });\n}\nlongPoll();\n\n// 서버 (Node.js)\napp.get(&#39;/server&#39;, function(req, res){\n    setTimeout(function(){\n        res.send(&#39;새로운 데이터&#39;);\n    }, 10000); // 10초 후에 응답\n});</code></pre>\n<ul>\n<li><p>새로운 데이터가 있거나, 설정한 10초의 시간이 지나면 응답을 보내는 것.</p>\n</li>\n<li><p>이러한 방식을 사용하면 <code>폴링</code>보다는 데이터 업데이트에 반응하는 속도는 빨라지지만, 서버의 부담이 커진다.</p>\n</li>\n<li><p>서버가 클라이언트로부터 요청을 받을 때 부터 응답을 보내기 까지 클라이언트와의 연결이 지속되는데, 동시에 여러 클라이언트가 서비스를 사용하면 그만큼의 연결을 유지해야 하므로 부하가 발생한다.</p>\n</li>\n</ul>\n<h4 id=\"웹-소켓\">웹 소켓</h4>\n<ul>\n<li><p>웹 소켓 통신은 다음과 같은 방식으로 이루어진다.</p>\n</li>\n<li><p><img src=\"https://github.com/user-attachments/assets/620b7732-7f45-487a-8e75-b5a874e6e288\" alt=\"웹소켓\"></p>\n</li>\n</ul>\n<ul>\n<li><p>클라이언트가 서버에게 Websocket 을 연결하자는 요청을 HTTP 를 통해 전송한다. 그것이 가능한 경우에 서버가 이를 수락하는 응답을 HTTP로 보내게 된다.</p>\n</li>\n<li><p>이러한 handshake 과정을 거치고 나면 연결이 이루어지고, 그 때부터 클라이언트와 서버는 HTTP가 아닌 WebSocket 프로토콜을 사용하여 소통한다.</p>\n</li>\n<li><p>HTTP의 <code>편지</code>방식이 아니라, <code>전화통화</code>가 이루어지는 것. 여기서 클라이언트와 서버는 자유롭게 서로에게 메시지를 보낼 수 있게된다.</p>\n</li>\n<li><p><code>WebSocket</code> 에서의 통신은 헤더의 크기가 작고, 오버헤드가 적기 때문에 HTTP 보다 효율적인 통신이 가능하다.</p>\n<blockquote>\n<p>헤더는 우편물에 붙은 송장 과 비슷한것.</p>\n</blockquote>\n</li>\n</ul>\n<pre><code class=\"language-js\">GET /socket\nHost: yong-nyong-tistory.com\nOrigin: https://gwagjiug.com\nConnection: Upgrade\nUpgrade: websocket\nSec-WebSocket-Key: Ivyio/9s+lYongNyongczP8Q==\nSec-WebSocket-Version: 13</code></pre>\n<ul>\n<li>이러한 연결은 클라이언트와 서버 둘 중 한쪽이 연결을 종료하자는 메시지를 보낼 때 까지 지속된다. 한쪽이 <code>close</code> 프레임을 보내면, 다른쪽이 이를 확인하고 <code>close</code> 프레임을 응답으로 보냄으로써 연결이 종료되는 것.</li>\n</ul>\n<blockquote>\n<p>만약에 클라이언트의 폰 혹은 PC가 <code>close</code>를 보내지 못하고 꺼지게 된다면?</p>\n</blockquote>\n<ul>\n<li><p>비정상적인 종료를 감지하는 방법들이 있다.</p>\n</li>\n<li><p>지정된 시간 동안 메시지가 없을 시 확인 패킷을 보내는 방법, 주기족으로 ping,pong 프레임을 주고 받아서 서로의 접속 여부를 확인하는 방법도있다.</p>\n</li>\n<li><p>WebSocket은 하나의 연결을 끝까지 유지하고, 그 과정에서도 적은 자원만 소모하기 때문에 Long Polling 만큼 서버에 부담을 주지 않을 수 있는 것</p>\n</li>\n</ul>\n<hr>\n<h4 id=\"웹소켓의-한계점\">웹소켓의 한계점</h4>\n<ul>\n<li><p>웹 소켓은 서버의 설계에 따라 구현이 복잡해질 수 있다. 특히 <a href=\"https://github.com/gawgjiug/Eureka_CS_Study/blob/main/Network/network_load_balancing.md\">로드밸런싱</a> 이 적용된 서버에서는 고려하고 설정할 부분이 많아지는데,</p>\n</li>\n<li><p>로드밸런싱은 기본적으로 서러 여러 대가 클라이언트 요청을 나눠서 받는 방식인데, 웹 소켓은 특정 서버와의 지속적인 연결 안에서만 이루어지기 때문에 한 서버와 웹 소켓 통신을 시작하면 이후로도 계속 그 서버로만 데이터가 전송되도록 설정해야한다.</p>\n</li>\n<li><p>NGINX,AWS ELB 등 WebSocket을 처리할 수 있는 로드 밸런서를 선택하여 구성하는 등 방법을 찾아 해결해야 한다.</p>\n</li>\n<li><p>WebSocket의 기본 프로토콜인 WS 는 통신이 암호화 되어있지 않기 때문에 SSL/TLS3 인증서를 발급 받은 뒤 이를 사용하여 WSS를 설정해야 한다.</p>\n</li>\n<li><p>그리고 알아둬야 할 것이 기존의 <code>Polling</code> 등의 방식 보다는 훨씬 덜하지만 WebSocket도 서버에 부담을 주는 것은 마찬가지이기 때문에 구현하고자 하는 서비스에 가장 적절한 선택을 하는 것이 중요하다.</p>\n</li>\n</ul>\n",
    "pubDate": "Wed, 31 Jul 2024 05:33:50 GMT",
    "thumbnail": null
  },
  {
    "title": "로드 밸런싱",
    "link": "https://velog.io/@gawgjiug/%EB%A1%9C%EB%93%9C-%EB%B0%B8%EB%9F%B0%EC%8B%B1",
    "description": "<h3 id=\"로드-밸런싱\">로드 밸런싱</h3>\n<h4 id=\"load-balancer\">Load Balancer</h4>\n<ul>\n<li><p>로드 밸런서란 일반적으로 서버의 부하를 분산 해주는 장치 또는 기술을 뜻한다.</p>\n</li>\n<li><p>보통은 서버 상단 네트워크에 위치하고 있으며, 서버 한대에 트래픽이 집중되지 않도록 트래픽을 관리하여 각 서버가 최적의 효율을 발휘할 수 있게 해주는 역할을 수행한다.</p>\n</li>\n</ul>\n<p><img src=\"https://github.com/user-attachments/assets/cc2ad198-adb0-4173-bccb-dc5e16c97e6e\" alt=\"image\"></p>\n<ul>\n<li><p>Client가 Sever에게 어떠한 <code>요청</code>을 하게되면 loadBalancer에서 해당 요청을 받아들여서 비교적 한가한 서버에게 트래픽을 분산하여 과부화를 방지하는 역할이다.</p>\n</li>\n<li><p>서버에 부하를 분산하는 것 뿐만 아니라 트래픽 자체도 분산하기 위해 사용되지만 요즘은 SLB(Server Load Balancing)이 주를 이루고 있다.</p>\n</li>\n</ul>\n<h4 id=\"load-balancer-기본기능\">Load Balancer 기본기능</h4>\n<h5 id=\"health-check\">Health Check</h5>\n<ul>\n<li>서버가 정상적으로 작동하는지 주기적으로 확인하는 기능을 말한다. 비정상적인 서버를 트래픽 분배 대상에서 제외시킴으로써 서비스의 가용성과 안정성을 높인다.</li>\n</ul>\n<p><strong>1-1 ICMP</strong></p>\n<ul>\n<li><p>VIP에 연결된 리얼 서버에 대해 ICMP(ping)로 헬스 체크를 수행하는 방법입니다. 단순히 서버가 살아 있는지 여부만 체크할 수 있으므로 자주 사용하지는 않는다.</p>\n</li>\n<li><p>서버의 생존 여부는 확인할 수 있지만, 애플리케이션 레벨의 상태는 알 수 없다.</p>\n</li>\n<li><p>애플리케이션 레벨에서 Health Check를 하기 위해선 데이터베이스 쿼리를 통해 데이터베이스 상태를 확인하거나, 애플리케이션 내부의 특정 모듈이 정상적으로 작동하는지\n확인하는 API End Point를 호출하는 방법이 있다.</p>\n</li>\n</ul>\n<p>이러한 방법을 사용하면 애플리케이션의 구체적인 상태를 점검할 수 있으며, 문제가 발생한 지점을 보다 정확히 파악할 수 있다.</p>\n<p><strong>1-2 TCP HandShake</strong></p>\n<ul>\n<li><p>가장 기본적인 헬스 체크 방법은 로드 밸런서에 설정된 서버의 서비스 포트를 확인하는 것이다.</p>\n</li>\n<li><p>데이터 베이스 서버나 특정 포트에서 서비스 중인 애플리케이션 서버의 가용성을 확인하는 데 사용되고, 포트가 열려 있는지, 서버가 수신 대기 상태인지를 빠르게 확인 할 수 있음</p>\n</li>\n</ul>\n<h5 id=\"health-check의-구성요소\">Health Check의 구성요소</h5>\n<ul>\n<li><p>주기 (Interval) : 헬스 체크를 수행하는 주기이다. 주기가 짧은 수록 서버 상태를 빨리 감지할 수 있지만, 서버에 대한 Overhead 증가할 수 있다.</p>\n</li>\n<li><p>타임아웃(Timeout) : 헬스 체크 요청에 대한 응답을 기다리는 최대 시간을 말한다. 타임아웃을 초과하면 해당 헬스 체크는 실패로 간주 된다.</p>\n</li>\n<li><p>재시도 횟수(Retry Attempts) : 서버가 일시적으로 응답하지 않을 경우를 대비하여, 헬스 체크를 재시도하는 횟수이다. 일반적으로는 여러 번 실패한 후에 서버를 비정상으로 간주한다.</p>\n</li>\n<li><p>임계값(Thresholds) : 서버를 비정상 또는 정상으로 간주하기 위한 헬스 체크 성공 및 실패 횟수 기준을 말한다. 예를 들어 3번 연속 실패시 server is 비정상...</p>\n</li>\n</ul>\n<h5 id=\"health-check의-중요성\">Health Check의 중요성</h5>\n<ul>\n<li><p>서버가 정상적으로 작동하는지 확인하기 때문에 안정적인 서비스를 제공하는 것에 기여할 수 있고,  서버의 장애를 신속하게 감지하고 문제를 해결할 수 있도록 도움을 준다.</p>\n</li>\n<li><p>HeathCheck 를 통해 자동화된 장애 복구 프로세스를 트리거하여 서버가 정상 상태로 돌아오면 자동으로 트래픽을 다시 분배한다.</p>\n</li>\n</ul>\n<h5 id=\"load-balancing-algorithm\">Load Balancing Algorithm</h5>\n<p><strong>1. Least Connection 알고리즘</strong></p>\n<ul>\n<li><p>한글로 풀어쓰면 <code>최소 연결</code> 알고리즘이다. 말 그대로 가장 적게 연결 되어 있는 서버에 세션을 할당해주는 방식을 말한다</p>\n</li>\n<li><p>서버에 분배된 세션들이 일정하지 않은 경우에 적합하며, 부하를 줄이는 측면에서 많이 사용된다.</p>\n</li>\n</ul>\n<p><strong>2.Round Robin 알고리즘</strong></p>\n<ul>\n<li><p>순차적으로 돌아가며 세션을 할당해주는 방식을 말한다. 요청이 오면 단순히 그 요청을 순서대로 서버에 분배해주는데, 첫 번째 요청은 미리 등록된 첫 번째 서버\n두번째 요청은 두 번째 서버에 할당해준다.</p>\n</li>\n<li><p>로드밸런싱 대상 서버의 스펙이 동일하고, 처리시간 혹은 세션지속시간이 짧은 애플리케이션의 경우 이러한 방식이 적합하다.</p>\n</li>\n</ul>\n<p><strong>3.Hash 알고리즘</strong></p>\n<ul>\n<li><p>특정 사용자는 특성 서버로만 할당시키는 방식을 말한다. 이외에도 특정한 기준을 잡아 특정 서버에 매핑하여 고정적으로 트래픽을 분산해주는 방식을 말한다.</p>\n</li>\n<li><p>일반적으로는 출발지 (Client)의 IP가 그 기준이 되고, 특정 IP주소나 포트를 갖는 사용자들은 특정 서버로만 세션을 맺도록 하여 특정 IP주소나 포트에서 접속량이 특히 많을 때 관리가 편한 방식이다.</p>\n</li>\n</ul>\n",
    "pubDate": "Tue, 30 Jul 2024 06:05:49 GMT",
    "thumbnail": null
  },
  {
    "title": "캐시 (Cache)?",
    "link": "https://velog.io/@gawgjiug/%EC%BA%90%EC%8B%9C-Cache",
    "description": "<h3 id=\"운영체제-캐시cache\">운영체제 캐시(Cache)</h3>\n<hr>\n<h3 id=\"캐시란\">캐시란??</h3>\n<ul>\n<li><p>CPU 캐시에 대해 알아보기 전에 <code>캐시</code> 라는 개념에 대해 먼저 알아보자</p>\n</li>\n<li><p><code>캐시</code>는 자주 사용하는 데이터를 미리 복사해 놓는 임시 저장 장소를 말한다. 이러한 캐시는 원본 데이터에 접근하는 시간을 절약하기 위해 사용된다. 즉 데이터 검색 속도를 높이기 위함이다. </p>\n</li>\n</ul>\n<h4 id=\"cpu-cache\">CPU cache</h4>\n<p><img src=\"https://github.com/user-attachments/assets/d24f7fe3-3ebb-4965-882a-ef5d5a279be7\" alt=\"image\"></p>\n<p><code>위 이미지는 CPU 캐시의 구조를 소프트웨어 관점으로 보여주는 이미지이다</code></p>\n<ul>\n<li>CPU가 자주 사용할 만한 데이터를 메인 메모리에서 꺼내와 복사 저장해 놓는 임시 저장 장소를 말한다.</li>\n</ul>\n<p><img src=\"https://github.com/user-attachments/assets/9cc9b17e-60c5-4e27-976d-d41d71a96338\" alt=\"image\"></p>\n<p><code>위 이미지는 CPU 캐시의 구조를 하드웨어 관점으로 보여주는 이미지이다</code></p>\n<hr>\n<h4 id=\"데이터-지역성이란\">데이터 지역성이란?</h4>\n<ul>\n<li><p>데이터 지역성은 캐시의 적중률(hit)을 높여 메모리 접근 패턴을 최적화 하여 프로그램 성능을 향상 시키는 데에 중요한 역할을 하는 개념이다.</p>\n</li>\n<li><p>데이터 지역성은 자주 쓰이는 데이터가 시간적으로나 공간적으로 한 곳에 몰려있을 가능성이 높다는 원리를 말한다.</p>\n</li>\n</ul>\n<p><strong>1. 시간지역성</strong> : 시간 지역성은 특정 데이터가 한 번 접근되면, 가가운 미래에 그 데이터가 다시 접근될 가능성이 높다는 것을 의미한다. CPU 캐시가 시간 지역성을 활용하는 방법은 다음과 같습니다.</p>\n<ul>\n<li><p><code>LRU(Lease Recently Used) 알고리즘</code> : 자주 사용되는 데이터를 캐시에 남겨두기 위해 LRU 알고리즘을 사용하여 덜 자주 사용되는 데이터를 제거하고, 최근에 사용된 데이터를 유지합니다.</p>\n</li>\n<li><p>예를 들어, 반복문에서 같은 변수를 여러 번 읽고 쓰는 경우가 있습니다. 이 경우 시간 지역성 때문에 해당 변수는 캐시에 남아 있어 반복문을 빠르게 실행할 수 있는 것.</p>\n</li>\n</ul>\n<hr>\n<p><strong>2. 공간 지역성</strong> : 공간 지역성은 특정 데이터가 접근되면, 그 데이터와 인접한 주소에 있는 데이터도 곧 접근될 가능성이 높다는 것을 의미한다. </p>\n<ul>\n<li><p>CPU 캐시가 공간 지역성을 활용하는 방법은 다음과 같다.</p>\n</li>\n<li><p><code>캐시 라인</code> : 캐시 메모리는 보통 캐시 라인이라는 단위로 데이터를 저장하며, 캐시 라인을 일반적으로 여러 바이트의 데이터를 포함하고 하나의 캐시 라인에 연속된 메모리 주소의 데이터가 저장된다.</p>\n</li>\n<li><p>예를 들어, 배열의 요소를 순차적으로 접근하려는 경우에 공간 지역성 때문에 배열의 연속된 요소들이 캐시에 로드되어 배열 접근이 빠르게 이루어질 수 있음.</p>\n</li>\n</ul>\n<h4 id=\"캐시-동작-방식\">캐시 동작 방식</h4>\n<ul>\n<li><p>캐시 공간은 $O(1)$ 등 낮은 시간복잡도로 접근 가능한 곳을 주료 사용한다.</p>\n</li>\n<li><p>캐시에 원하는 데이터가 없거나 <code>(Cache Miss)</code> 너무 오래 되어 최신성을 잃었을 때 <code>(Expiration)</code></p>\n<ul>\n<li>원본 데이터가 있는 곳에 접근해 데이터를 가져옴</li>\n<li>이 때 데이터를 가져오며 캐시에도 해당 데이터를 복사하거나 갱신한다.</li>\n</ul>\n</li>\n<li><p>캐시에 원하는 데이터가 있을 때 <code>(Cache Hit)</code></p>\n<ul>\n<li>원본 데이터가 있는 공간에 접근하지 않고 바로 해당 데이터를 제공한다.</li>\n</ul>\n</li>\n<li><p>캐시 공간은 작기 때문에 공간이 모자랄 경우 안쓰는 데이터부터 삭제하여 공간을 확보한다 (Eviction</p>\n</li>\n</ul>\n<hr>\n<h4 id=\"캐시-활용-예시\">캐시 활용 예시</h4>\n<h5 id=\"cdn-content-delivery-network\">CDN (Content Delivery Network)</h5>\n<ul>\n<li><p>세계 각지에 캐시 서버를 두어 전송속도를 높이고 부하를 분산하는 시스템을 말한다.</p>\n</li>\n<li><p>Google 은 각 통신사마다 Google Global Cache를 두어 인기있는 YouTube 영상은 미국서버까지 접속할 필요 없이 국내 서버에서 처리하도록 설계하였다.</p>\n</li>\n<li><p>가격이 비싼 국제 회선 비용이 절감되고 버퍼링이 감소한다는 장점을 가짐</p>\n</li>\n</ul>\n<p><img src=\"https://github.com/user-attachments/assets/9ec48025-7202-49b7-9728-ebb0d54c49a2\" alt=\"image\"></p>\n<h5 id=\"웹-캐시\">웹 캐시</h5>\n<ul>\n<li><p>네트워크를 통해 데이터를 가져오는 것은 때때로 하드디스크에서 가져오는 것 보다 느릴때가 있다.</p>\n</li>\n<li><p>브라우저 캐시 : 브라우저는 웹 페이지에 접속할 때 HTML,CSS,JS, 이미지 등을 하드 디스크나 메모리에 캐싱해뒀다가 다음번에 다시 접속할 때 이를 재활용하는 것을 말한다.</p>\n</li>\n<li><p>응답캐시 : 웹 서버 또한 상당수의 경우 동적 웹 페이지라 할지라도 매번 내용이 바뀌지 않는 경우가 더 많기 때문에 서버에서 생성한 HTML을 캐싱해뒀다가 다음번 요청에 이를 재활용 하는 것을 말한다.</p>\n</li>\n</ul>\n",
    "pubDate": "Tue, 16 Jul 2024 12:50:04 GMT",
    "thumbnail": null
  },
  {
    "title": "트리의 부모 찾기",
    "link": "https://velog.io/@gawgjiug/%ED%8A%B8%EB%A6%AC%EC%9D%98-%EB%B6%80%EB%AA%A8-%EC%B0%BE%EA%B8%B0",
    "description": "<ul>\n<li>오랜만에 백준 문제.. 머리가 잘 안돌아가서 쉬운 문제를 풀어봤음.</li>\n</ul>\n<p><a href=\"https://www.acmicpc.net/problem/11725\">백준 11725번 : 트리의 부모 찾기</a></p>\n<p><img src=\"https://velog.velcdn.com/images/gawgjiug/post/ad30b791-ce05-41db-808b-78b28dcc5166/image.png\" alt=\"\"></p>\n<ul>\n<li>트리는 인접 행렬과 인접 리스트를 통해 구현할 수 있는데,  문제에서 N의 개수가 최대 10만이다. 인접 행렬로 구현하면 10만 x 10만 = 총 100만의 공간을 차지하게 되므로 메모리가 4바이트라고 할 때 40기가의 메모리를 필요로 하므로 현재 문제에서는 인접 행렬 방식은 구현할 수 없음.</li>\n</ul>\n<ul>\n<li><p>인접 리스트를 구성해서 간 간선을 읽어 두 노드 사이의 연결을 인접 리스트에 추가한다.</p>\n</li>\n<li><p>DFS 방식을 이용해서 현재 노드의 부모 노드를 찾고, 그 노드의 값을 저장한 배열의 값을 2부터 출력.</p>\n</li>\n</ul>\n<pre><code class=\"language-java\">package Silver_2;\n\nimport java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.util.ArrayList;\nimport java.util.List;\nimport java.util.StringTokenizer;\n\npublic class find_tree_parents {\n\n    private static ArrayList&lt;Integer&gt;[] adjList;\n    private static int[] parents;\n    private static boolean [] visited;\n\n    static int N;\n    public static void main(String[] args) throws IOException {\n\n        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n        StringTokenizer st = null;\n\n        N = Integer.parseInt(br.readLine());\n        parents = new int[N+1];\n        visited = new boolean[N+1];\n        adjList = new ArrayList[N+1];\n\n        for(int i =1; i&lt;=N; i++){\n            adjList[i] = new ArrayList&lt;Integer&gt;();\n            //list 초기화\n        }\n\n        for(int i = 0; i&lt;N-1; i++){\n            st = new StringTokenizer(br.readLine());\n            int v1 = Integer.parseInt(st.nextToken());\n            int v2 = Integer.parseInt(st.nextToken());\n\n            adjList[v1].add(v2);\n            adjList[v2].add(v1);\n\n\n        }\n\n        dfs(1);\n\n\n\n        for(int i = 2; i&lt;=N; i++){\n            System.out.println(parents[i]);\n        }\n\n\n\n    }\n\n    private static void dfs(int v) {\n        visited[v] = true;\n\n        for(int vertex : adjList[v]){\n            if(!visited[vertex]){\n                parents[vertex] = v;\n                dfs(vertex);\n            }\n        }\n\n    }\n}\n/*\n*\n* 1 = true\n* 1넘어가고 2\n* parent[2] = 1 -&gt; 2의 부모는 1\n* dfs(2) */\n</code></pre>\n<ul>\n<li>거의 2주만에 문제 푸니깐 알손실 왔다.. 바빠도 꾸준히 하자 ㅜㅜ</li>\n</ul>\n",
    "pubDate": "Fri, 12 Jul 2024 15:57:10 GMT",
    "thumbnail": null
  }
]